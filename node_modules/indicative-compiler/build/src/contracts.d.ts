import { ParsedRule, Message } from 'indicative-parser';
export declare type ConsumerFn<T extends any = any> = (field: string, type: 'literal' | 'object' | 'array', rules: ParsedRule[], dotPath: string[], pointer: string) => T;
export declare type ArrayWrapper<T extends any = any, U extends any = any> = (index: string, field: string, children: (T | U)[], dotPath: string[]) => U;
export declare type ValidationDataRoot = {
    tip: any;
    original: any;
    pointer: string;
    arrayPointer?: string;
    parentArray?: any[];
    currentIndex?: number;
};
export declare type ValidateFunction = (data: ValidationDataRoot, field: string, args: any[], config: unknown) => boolean | Promise<boolean>;
export declare type ValidationDefination = {
    async: boolean;
    compile?: (args: any[]) => any[];
    validate: ValidateFunction;
};
export declare type SanitizationDataRoot = Pick<ValidationDataRoot, Exclude<keyof ValidationDataRoot, 'pointer' | 'arrayPointer'>>;
export declare type SanitizeFunction = (data: SanitizationDataRoot, field: string, args: any[], config: unknown) => void;
export declare type SanitizationDefination = {
    compile?: (args: any[]) => any[];
    sanitize: SanitizeFunction;
};
export interface ErrorFormatterContract {
    addError(error: string | Error, field: string, ruleName: ParsedRule['name'], args: ParsedRule['args']): void;
    toJSON(): any;
}
export interface CollectorContract {
    formatter: ErrorFormatterContract;
    hasErrors: boolean;
    getErrors(): ReturnType<ErrorFormatterContract['toJSON']>;
    getData(): any;
    setValue(pointer: string, value: any): void;
    setError(pointer: string, rule: ParsedRule, message: Message | Error): void;
}
