"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_get_1 = __importDefault(require("lodash.get"));
class ArrayWrapper {
    constructor(_field, _index, _childValidators, _dotPath) {
        this._field = _field;
        this._index = _index;
        this._childValidators = _childValidators;
        this._dotPath = _dotPath;
        this._pointer = this._dotPath.concat(this._field).join('.');
        this.async = !!this._childValidators.find((validator) => validator.async);
    }
    _getDataCopy(data) {
        const value = lodash_get_1.default(data.tip, this._pointer);
        if (!Array.isArray(value)) {
            return null;
        }
        return {
            original: data.original,
            pointer: '',
            tip: null,
            parentArray: value,
            currentIndex: this._index === '*' ? 0 : Number(this._index),
            arrayPointer: data.arrayPointer
                ? `${data.arrayPointer}.${data.currentIndex}.${this._pointer}`
                : this._pointer,
        };
    }
    _executeValidations(data, collector, config, bail) {
        let hasFailures = false;
        for (let validator of this._childValidators) {
            const passed = validator.exec(data, collector, config, bail);
            if (!passed) {
                hasFailures = true;
                if (bail) {
                    break;
                }
            }
        }
        return !hasFailures;
    }
    async _executeAsyncValidations(data, collector, config, bail) {
        let hasFailures = false;
        for (let validator of this._childValidators) {
            let passed = true;
            if (validator.async) {
                passed = await validator.execAsync(data, collector, config, bail);
            }
            else {
                passed = validator.exec(data, collector, config, bail);
            }
            if (!passed) {
                hasFailures = true;
                if (bail) {
                    break;
                }
            }
        }
        return !hasFailures;
    }
    exec(data, collector, config, bail = false) {
        const dataCopy = this._getDataCopy(data);
        if (!dataCopy) {
            return true;
        }
        if (this._index !== '*') {
            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];
            return this._executeValidations(dataCopy, collector, config, bail);
        }
        let index = 0;
        let hasFailures = false;
        for (let item of dataCopy.parentArray) {
            dataCopy.tip = item;
            dataCopy.currentIndex = index;
            let passed = true;
            passed = this._executeValidations(dataCopy, collector, config, bail);
            if (!passed) {
                hasFailures = true;
                if (bail) {
                    break;
                }
            }
            index++;
        }
        return !hasFailures;
    }
    async execAsync(data, collector, config, bail = false) {
        const dataCopy = this._getDataCopy(data);
        if (!dataCopy) {
            return true;
        }
        if (this._index !== '*') {
            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];
            return this._executeAsyncValidations(dataCopy, collector, config, bail);
        }
        let index = 0;
        let hasFailures = false;
        for (let item of dataCopy.parentArray) {
            dataCopy.tip = item;
            dataCopy.currentIndex = index;
            const passed = await this._executeAsyncValidations(dataCopy, collector, config, bail);
            if (!passed) {
                hasFailures = true;
                if (bail) {
                    break;
                }
            }
            index++;
        }
        return !hasFailures;
    }
}
exports.ArrayWrapper = ArrayWrapper;
