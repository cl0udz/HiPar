var fs = require('fs'),
    path = require('path'),
    babylon = require('babylon');

var uAMD = babylon.parse(
    fs.readFileSync(path.join(__dirname, 'uAMD.js')).toString()
);


function BundlerError(message) {
    this.message = message || 'An error occured in bundler';
}
BundlerError.prototype = new Error();
BundlerError.prototype.constructor = BundlerError;
BundlerError.prototype.name = 'BundlerError';



function createLiteral(value) {
    return { type: 'StringLiteral', value: value, raw: '\''+value+'\'' };
}

function createIdentifier(name) {
    return { type: 'Identifier', name: name };
}

function entryPoint(main) {
    return {
        type: 'ExpressionStatement',
        expression: {
            type: 'CallExpression',
            callee: createIdentifier('require'),
            arguments: [{
                type: 'ArrayExpression',
                elements: [ createLiteral(main) ]
            }]
        }
    };
}

function deps(ast) {
    return ast.program.body[0].expression.arguments[1].elements.map(function(d) {
        return d.value;
    }).filter(function(value) {
        return value !== 'exports' && value !== 'module';
    });
}

function isDefine(node) {
    return node &&
        node.type === 'ExpressionStatement' &&
        node.expression.type === 'CallExpression' &&
        node.expression.callee.name === 'define';
}

function findDefine(node) {
    while (node &&
        node.type === 'ExpressionStatement' &&
        node.expression.type === 'CallExpression' &&
        node.expression.callee.type === 'FunctionExpression' ) {

        return node.expression.callee.body[0];
    }

    return node;
}


function Bundler(options) {
    options = options || {};

    this.state = options.state || {};

    this.state.files = this.state.files || {};
    this.state.packages = this.state.packages || [];

    this.out = options.out || 'main-built.js';
    var parts = (options.main || 'main.js').split('/');

    var main = parts.pop().replace(/\.js$/, '');
    var pkgname = parts.join('/');

    this.state.localPackages = [
        {
            name: pkgname,
            main: main,
            location: pkgname
        }
    ];

    this.loader = uAMD;
    this.entryPoint = entryPoint(pkgname);

    this.mergePackages();
}

Bundler.prototype.mergePackages = function() {
    this.packages = this.state.localPackages.concat(this.state.packages);

    this.namemap = {};

    var k, v;
    for (k in this.packages) {
        v = this.packages[k];
        this.namemap[v.name.length?path.join(v.name, v.main):v.main] = v.name;
    }
};

Bundler.prototype.setPackages = function(packages) {
    this.state.packages = packages;
    this.mergePackages();
};

Bundler.prototype.absname = function(name) {
    // figure out package name
    var pkgs = this.packages.filter(function(p) {
        return new RegExp('^' + p.location).test(name);
    });

    var maxlen = Math.max.apply(null, pkgs.map(function(p) {
        return p.location.length;
    }));

    var pkg = pkgs.filter(function(p) {
        return p.location.length === maxlen;
    })[0];

    var pkgloclen = pkg.location.length;
    var intraname = name.slice(pkgloclen ? pkgloclen + 1 : 0);
    // figure out module name
    var modname = path.join(pkg.name, intraname).replace(/\.js$/, '');

    // use short version module entrypoint
    if (typeof this.namemap[modname] !== 'undefined') {
        modname = this.namemap[modname];
    }

    return modname;
};

Bundler.prototype.setSourceFile = function(name, ast) {
    var depname, modname, i, defineArgs, dir;

    // find define call
    ast.program.body = [ findDefine(ast.program.body[0]) ];
    if (!isDefine(ast.program.body[0])) {
        return;
    }

    modname = this.absname(name);
    // set module name
    defineArgs = ast.program.body[0].expression.arguments;
    if (defineArgs && defineArgs[0].type !== 'Literal') {
        defineArgs.unshift(createLiteral(modname));
    } else {
        modname = defineArgs[0].value;
    }

    // make module names absolute
    for (i=0; i<ast.program.body[0].expression.arguments[1].elements.length; i++) {
        depname = ast.program.body[0].expression.arguments[1].elements[i].value;

        // convert relative to absolute paths
        if (depname[0] === '.') {
            dir = path.dirname(name);
            var fullpath = path.normalize(path.join(dir, depname));
            ast.program.body[0].expression.arguments[1].elements[i].value = this.absname(fullpath);
        }
    }

    this.state.files[modname] = ast;
};

Bundler.prototype.pkglist = function() {
    var files = this.state.files,
        mods = [],
        todo = [ this.state.localPackages[0].name ],
        next, i, j, deplist;

    for(;;) {
        next = [];
        for (i=0; i<todo.length; i++) {
            if (~mods.indexOf(todo[i])) {
                continue;
            }

            if (!files[todo[i]]) {
                throw new BundlerError('The main module `' + todo[i] +
                    '` was not added to the bundler.');
            }

            mods.unshift(todo[i]);
            deplist = deps(files[todo[i]]);

            for (j=0; j<deplist.length; j++) {
                if (files[deplist[j]]) {
                    next.push(deplist[j]);
                } else {
                    throw new BundlerError('Package ' + deplist[j] +
                        ' is required, but missing.');
                }
            }

        }

        if (!next.length) {
            break;
        }

        todo = next;
    }
    return mods.sort();
};

Bundler.prototype.order = function(mods) {
    var ordered = [],
        i, resolved;

    var inOrdered = function (dep) {
        return ~ordered.indexOf(dep);
    };

    while (mods.length !== ordered.length) {
        for (i=0; i<mods.length; i++) {
            if (~ordered.indexOf(mods[i])) {
                continue;
            }

            resolved = deps(this.state.files[mods[i]]).every(inOrdered);

            if (resolved) {
                ordered.push(mods[i]);
            }
        }
    }
    return ordered;
};

Bundler.prototype.catast = function(mods) {
    var i;
    var ast = {
        type: 'File',
        program: {
            type: 'Program',
            body: [],
            comments: []
        },
        sourceType: 'script'
    };

    ast.program.body = ast.program.body.concat(this.loader.program.body);

    for (i=0; i<mods.length; i++) {
        ast.program.body = ast.program.body.concat(this.state.files[mods[i]].program.body);
    }

    ast.program.body = ast.program.body.concat(this.entryPoint);
    return ast;
};

Bundler.prototype.bundle = function() {
    var mods = this.pkglist();
    return this.catast(mods);
};

module.exports.Bundler = Bundler;
