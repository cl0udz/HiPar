import http from 'http';
import https from 'https';
import fs from 'fs';
import express from 'express';
import compression from 'compression';
import mime from 'mime';
import path from 'path';
import sio from 'socket.io';
import url from 'url';
import minimatch from 'minimatch';
import crypto from 'crypto';
import { BasePipe } from '../pipe';
import { dedent } from '../utils';


const reloadCode = `
+function() {
    io.connect(window.location.origin, { path: '/__reload' })
    .on('reconnect', function() { location.reload(); })
    .on('page', function() { location.reload(); })
    .on('css', function() {
        var links = document.getElementsByTagName('link'),
            date = new Date().valueOf();
        for (var i=0; i<links.length; i++) {
            var tag = links[i];
            if (/stylesheet/i.test(tag.rel) && tag.href) {
                var href = tag.href.replace(/(&|\\?)\\d+/, ''),
                    query = (~href.indexOf('?')?'&':'?') + date;
                tag.href = href + query;
            }
        }
    });
}();
`;


const reloadScript = `
    <script type="text/javascript" src="/__reload/socket.io.js"></script>
    <script type="text/javascript">${reloadCode}    </script>
`;


const dirlisting = dedent`
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>listing directory {directory}</title>
        <style>
            body {
              margin: 0;
              padding: 80px 100px;
              font-family: "Helvetica Neue", "Lucida Grande", "Arial";
              background-image: linear-gradient(#fff, #ece9e9);
              background-repeat: no-repeat;
              color: #555;
              -webkit-font-smoothing: antialiased;
            }
            h1 {
              margin: 0 0 18px 0;
              font-size: 36px;
              color: #343434;
            }
            a {
              color: #555;
              text-decoration: none;
            }
            a:hover {
              *color: #303030;
              color: #49607E;
              background: #DCD9D9;
            }
            a.dir {
              display: block;
            }
        </style>
    </head>
    <body>
        <h1>{segments}</h1>
        {files}
    </body>
</html>
`;


function csp(config, hostnames, reload) {
    const defaults = {
        defaultSrc: ['\'none\''],
        connectSrc: ['\'self\''],
        fontSrc: ['\'self\''],
        frameSrc: ['\'self\''],
        imgSrc: ['\'self\''],
        mediaSrc: ['\'self\''],
        objectSrc: ['\'self\''],
        scriptSrc: ['\'self\''],
        styleSrc: ['\'self\'']
    };

    const dasherize = (s) => s.replace(/([A-Z])/g, (_, m) => `-${m.toLowerCase()}`);

    const headerValues = Object.entries(defaults).map(([key, value]) => {
        config[key] = config[key] || value;

        if (reload) {
            if (key === 'scriptSrc') {
                const hash = crypto.createHash('sha256');
                hash.update(reloadCode);
                config[key].push(`'sha256-${hash.digest('base64')}'`);
            } else if (key === 'connectSrc') {
                if (!~hostnames.indexOf('localhost')) {
                    hostnames = hostnames.concat(['localhost']);
                }
                config[key].push(hostnames.map(function(h) {
                    return `ws://${h}:*`;
                }).join(' '));
            }
        }
        return (dasherize(key)) + ' ' + (config[key].join(' '));
    });
    const headerValue = headerValues.join('; ');
    return function(req, res, next) {
        if (!minimatch(req.path.split('/').pop(), '*.html')) {
            return next();
        }
        res.setHeader('Content-Security-Policy', headerValue);
        return next();
    };
}


function memory(files, reload) {
    function setHeader(res, pathname, data) {
        if (!res.getHeader('ETag')) {
            res.setHeader('ETag', data.length);
        }
        if (!res.getHeader('Date')) {
            res.setHeader('Date', new Date().toUTCString());
        }
        if (!res.getHeader('Cache-Control')) {
            res.setHeader('Cache-Control', 'public, max-age=0');
        }
        if (!res.getHeader('Last-Modified')) {
            res.setHeader('Last-Modified', new Date().toUTCString());
        }
        if (!res.getHeader('Content-Type')) {
            let type = mime.lookup(pathname);
            const charset = mime.charsets.lookup(type);
            type += charset ? '; charset=' + charset : '';
            return res.setHeader('Content-Type', type);
        }
    }

    function isFile(pathname) {
        //return files[pathname];
        return Object
            .keys(files)
            .filter((p) => pathname.substr(0, p.length) === p)[0];
    }

    function isDirectory(pathname) {
        if (pathname === '') {
            return true;
        } else if (pathname[pathname.length - 1] !== '/') {
            return false;
        } else {
            const r = new RegExp('^' + pathname);
            for (let name in files) {
                if (r.test(name)) {
                    return true;
                }
            }
        }
        return false;
    }

    function contents(pathname) {
        const r = new RegExp('^' + pathname);
        const strip = new RegExp('^' + pathname + '([^/]+)([/]?).*');
        const contents = [];
        if (pathname) {
            contents.push('..');
        }

        for (let name in files) {
            if (!r.test(name)) {
                continue;
            }
            const clean = name.replace(strip, '$1$2');
            if (!~contents.indexOf(clean)) {
                contents.push(clean);
            }
        }
        contents.sort();
        return contents;
    }

    function serveFile(res, pathname) {
        let data = files[pathname];
        if (reload && minimatch(pathname, reload)) {
            data = new Buffer(
                data.toString().replace(/<head>/, '<head>' + reloadScript)
            );
        }
        setHeader(res, pathname, data);
        res.write(Buffer(data));
        return res.end();
    }

    return function(req, res, next) {
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            return next();
        }

        const originalUrl = url.parse(req.originalUrl);
        let pathname = originalUrl.pathname.replace(/^\//, '');

        if (isFile(pathname)) {
            return serveFile(res, isFile(pathname));
        } else if (isDirectory(pathname) && isFile(`${pathname}index.html`)) {
            return serveFile(res, `${pathname}index.html`);
        } else if (isDirectory(pathname)) {
            const fs = contents(pathname);
            const up = (num) => Array.from(Array(num), () => '..').join('/');
            const segments = pathname.split('/');
            segments.unshift('');
            segments.pop();
            const segs = segments.map((f, i) => {
                return '<a href="' + (up(segments.length - 1 - i)) + '">' + f + '/</a>';
            });
            const links = fs.map((f) => `<a class="dir" href="${f}">${f}</a>`);

            const str = dirlisting
                .replace('{directory}', pathname)
                .replace('{segments}', segs.join(''))
                .replace('{files}', links.join(''));

            res.write(str);
            return res.end();
        } else if (isDirectory(`${pathname}/`)) {
            originalUrl.pathname += '/';
            const target = url.format(originalUrl);
            res.statusCode = 303;
            res.setHeader('Location', target);
            return res.end('Redirecting to ' + target);
        }

        let testname = path.dirname(pathname);
        while(testname) {
            if (testname === '.') {
                testname = '';
            }
            if (isDirectory(testname) && isFile(`${testname}index.html`)) {
                return serveFile(res, `${testname}index.html`);
            }
            testname = path.dirname(testname);
        }

        return next();
    };
}


function proxy(pattern, target, web) {
    const regex = new RegExp(pattern);

    const proxy = require('http-proxy').createProxyServer({
        target: target,
        ws: true,
        changeOrigin: true
    });

    proxy.on('error', function (e, req, res) {
        web.log('error', `Error proxying to ${target}`);
        if (req.get('Accept') === 'text/event-stream') {
            res.writeHead(200, {
                'Content-Type': 'text/event-stream'
            });
            res.end();
        }
    });

    web.server.on('upgrade', function (req, socket, head) {
        if (regex.test(req.url)) {
            web.log('verbose', `Proxying websocket to ${req.url}`);
            proxy.ws(req, socket, head);
        }
    });

    return function(req, res, next) {
        if (regex.test(req.url)) {
            return proxy.web(req, res);
        } else {
            next();
        }
    };
}

export default class ExtPipe extends BasePipe {
    constructor() {
        super(...arguments);

        this.defaultConfig({
            hostnames: [],
            port: 8613,
            reload: null,
            middleware: [],
            key: '',
            cert: '',
            csp: {},
            proxy: []
        });

        this.defaultState({
            files: {}
        });
    }

    static schema() {
        return {
            description: 'Webserver with optional Testem and Reload integration.',
            properties: {
                hostnames: {
                    description: 'List of hostnames for webserver (default: [])',
                    type: 'array',
                    items: {
                        type: 'string',
                        uniqueItems: true
                    }
                },
                key: {
                    description: 'Private key to use for SSL (default: "")',
                    type: 'string'
                },
                cert: {
                    description: 'Public x509 certificate to use (default: "")',
                    type: 'string'
                },
                port: {
                    description: 'Server port (default: 8613)',
                    type: 'integer'
                },
                reload: {
                    description: 'Pages to inject reload code to (default: "")',
                    type: 'string'
                },
                csp: {
                    description: 'Content security policy settings (default: "{...}")',
                    type: 'object'
                },
                middleware: {
                    description: 'Middleware modules to add to the webserver (default: [])',
                    type: 'array',
                    items: {
                        type: 'string'
                    },
                    uniqueItems: true
                },
                proxy: {
                    description: 'Proxy server configuration (default: [])',
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            pattern: { type: 'string' },
                            target: { type: 'string' }
                        }
                    }
                }
            }
        };
    }

    init() {
        this.app = express();

        if (this.config.key && this.config.cert) {
            this.server = https.createServer({
                key: fs.readFileSync(this.config.key),
                cert: fs.readFileSync(this.config.cert)
            }, this.app);
        } else {
            this.server = http.Server(this.app);
        }

        for (let cproxy of this.config.proxy) {
            this.log('info', `Proxying to /${cproxy.pattern}/ to ${cproxy.target}`);
            this.app.use(proxy(cproxy.pattern, cproxy.target, this));
        }

        this.app.use(compression());
        this.app.use(csp(this.config.csp, this.config.hostnames, this.config.reload));
        this.sockets = {};
        this.server.on('connection', socket => {
            const key = `${socket.remoteAddress}:${socket.remotePort}`;
            this.sockets[key] = socket;
            this.log('verbose', `Connection from ${key}`);
            socket.on('close', () => {
                this.log('verbose', `Close connection from ${key}`);
                delete this.sockets[key];
                socket.destroy();
            });
        });

        this.io = sio(this.server, {
            'log level': 0,
            'path': '/__reload'
        });

        this.app.use(require('body-parser').json({
            limit: '50mb',
            type: [
                'application/json',
                'application/*+json'
            ]
        }));
        this.mws = [];
        for (let mw of this.config.middleware) {
            this.mws[mw] = require(path.relative(__dirname, mw))(this.server);
            this.app.use(this.mws[mw]);
        }
        this.app.use(memory(this.state.files, this.config.reload));

        return super.init();
    }

    async start() {
        this.server.listen(this.config.port);
        const protocol = `http${this.config.key ? 's' : ''}`;
        const address = `${protocol}://localhost:${this.config.port}`;
        this.log('info', 'Listening on ' + address);
        return super.start();
    }

    async stop() {
        return new Promise(resolve => {
            this.io.close();
            this.server.close(() => {
                this.log('info', 'Webserver teardown complete');
                resolve(super.stop());
            });
            for (let [key, socket] of Object.entries(this.sockets)) {
                this.log('info', `Force closing connection ${key}`);
                socket.end();
                socket.destroy();
            }
        }).catch(err => {
            this.log('error', `Webserver teardown failed ${err}`);
        });
    }

    async remoteAdd(file) {
        file.addCount += 1;
        this.state.files[file.name] = '';
        return super.remoteAdd(file);
    }

    async remoteChange(file) {
        this.state.files[file.name] = await file.content();
        if (/\.css$/.test(file.name)) {
            this.io.sockets.emit('css');
        } else {
            this.io.sockets.emit('page');
        }
        return super.remoteChange(file);
    }

    async remoteUnlink(file) {
        try {
            file.addCount -= 1;
            delete this.state.files[file.name];
            this.io.sockets.emit('page');
            return super.remoteUnlink(file);
        } catch (err) {
            this.log('error', err.stack);
        }
    }
}
