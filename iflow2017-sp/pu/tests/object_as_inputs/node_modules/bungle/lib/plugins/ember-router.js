import { parse } from 'babylon';
import generate from 'babel-generator';

import { InputContentPipe } from '../pipe';
import { dedent } from '../utils';


export default class ExtPipe extends InputContentPipe {
    constructor() {
        super(...arguments);

        this.defaultConfig({
            pattern: '**/routes-*.js'
        });

        this.terminal = true;
    }

    static schema() {
        return {
            description: 'Build main Ember router from partial routes.',
            properties: {
                filename: {
                    description: 'Filename of the generated router',
                    type: 'string'
                }
            },
            required: ['filename']
        };
    }

    async generate(/*file*/) {
        if (this.config.debug) {
            this.log('debug', '#C# ' + this.config.filename);
        }

        const partials = [];

        for (let filename of Object.keys(this.state.remoteFiles)) {
            const file = this.remoteFile(filename);
            const content = await file.content();

            try {
                const ast = parse(content, {
                    sourceType: 'module'
                });

                const defs = ast.program.body[0].declaration.properties;

                for (let def of defs) {
                    const key =  def.key.value;
                    const exprs = def.value.body.body;
                    partials.push({key, exprs});
                }
            } catch(err) {
                this.log('error', err);
            }
        }

        partials.sort((a, b) => a.key.length - b.key.length);


        function find(res, key) {
            let root = res.program.body[2].expression.arguments[0].body.body;

            if (key) {
                const parts = key.split('.');

                for (let part of parts) {
                    root = root
                        .filter(r => r.expression.arguments[0].value === part)
                        .map(r => {
                            const last = r.expression.arguments.slice(-1)[0];
                            if (last.type === 'FunctionExpression') {
                                return last.body.body;
                            }

                            const fn = parse('(function() {})')
                                .program.body[0].expression;
                            r.expression.arguments.push(fn);
                            return fn.body.body;
                        })[0];
                }
            }
            return root;
        }

        const res = parse(dedent `
            import Ember from 'ember';

            var Router = Ember.Router.extend({
                location: 'history'
            });

            Router.map(function() {
            });

            export default Router;
        `, {
            sourceType: 'module'
        });

        for (let partial of partials) {
            const ancestor = find(res, partial.key);
            ancestor.splice.apply(ancestor, [-1,0].concat(partial.exprs));
        }
        const code = generate(res, {
            compact:true,
            comments: false
        }, '');

        return code.code;
    }
}
