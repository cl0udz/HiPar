import fs from 'fs';
import path from 'path';

import commander from 'commander';

import { Runner } from  './runner';

function list(val) {
    return val.split(',');
}

function clone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    const o = obj.constructor();
    for (let key in obj) {
        o[key] = clone(obj[key]);
    }
    return o;
}

function merge(o, n) {
    o = clone(o);
    n = clone(n);

    function f(o, n) {
        for (let k in n) {
            const v = n[k];
            if (k === '*') {
                for (let k2 in o) {
                    f(o[k2], clone(v));
                }
            } else {
                if (o[k] === null || typeof o[k] !== 'object') {
                    o[k] = v;
                } else {
                    f(o[k], v);
                }
            }
        }
        return o;
    }
    return f(o, n);
}


function print(string) {
    process.stdout.write(`${string}\n`);
}


export class Cli {
    constructor(argv) {
        argv = argv || process.argv;

        this.runner = new Runner();
        this.args = commander
            .version(require(path.join(__dirname, '..', 'package.json')).version)
            .usage('[options] <profile>')
            .option('-c, --checkconfig', 'validate config file')
            .option('-D, --debug', 'enable debug output')
            .option('-e, --enable <pipe[,pipe]>', 'enable pipes', list, [])
            .option('-d, --disable <pipe[,pipe]>', 'disable pipes', list, [])
            .option('-r, --reset', 'reset all bungle caches')
            .option('-L, --listpipes', 'show list available pipes')
            .option('-H, --pipehelp <pipe|all>', 'show help for pipe', list)
            .parse(argv);
    }

    listprofiles(profiles, current) {
        print('Profiles:');
        for (let [name, profile] of Object.entries(profiles)) {
            const indicator = name === current ? '*' : ' ';
            const padded = `${name}${Array(20 - name.length).join(' ')}`;
            print(`    ${indicator} ${padded}${profile.description}`);
        }
        print('');
    }

    listpipes() {
        print('Available pipes:');
        const pipes = this.runner.loadPipes();
        for (let [id, pipe] of Object.entries(pipes)) {
            const padded = `${id}${Array(25 - id.length).join(' ')}`;
            const description = pipe.schema().description.split('\n')[0];
            print(`    ${padded}${description}`);
        }
    }

    pipehelp(pipenames) {
        const pipes = this.runner.loadPipes(~pipenames.indexOf('all') ? null : pipenames);

        for (let [name, pipe] of Object.entries(pipes)) {
            const schema = pipe.schema();
            print(`\n${name}\n${Array(name.length + 1).join('=')}\n`);
            print(schema.description);
            print(`\nOptions (*=required)\n--------------------`);
            const attrs = Object.keys(schema.properties || {}).sort();
            for (let attr of attrs) {
                if (attr === 'pipe') {
                    continue;
                }
                const prop = schema.properties[attr];
                let type;
                if (prop.type === 'array') {
                    type = 'array of ' + prop.items.type + 's';
                } else {
                    type = prop.type;
                }
                const req = ~(schema.required || []).indexOf(attr) ? '* ' : '  ';
                attr = `${attr}${Array(16 - attr.length).join(' ')}`;
                type = `${type}${Array(20 - type.length).join(' ')}`;
                print(`${req}${attr}${type}${prop.description}`);
            }
            print('\n');
        }
    }

    run() {
        if (this.args.listpipes) {
            return this.listpipes(this.args.listpipes);
        } else if (this.args.pipehelp) {
            return this.pipehelp(this.args.pipehelp);
        } else {
            this.rundir = process.cwd();
            const config = this.load(this.rundir);
            if (!config) {
                return;
            }

            config.bungle = config.bungle || {};
            config.pipes = config.pipes || {};
            config.profiles = config.profiles || {};

            const cliConfig = {
                reset: !!this.args.reset,
                checkconfig: !!this.args.checkconfig,
                logger: {}
            };

            if (this.args.debug) {
                cliConfig.logger.console = 'debug';
            }

            const bungle = merge(config.bungle, cliConfig);
            const profileName = this.args.args[0] || 'default';
            const profile = config.profiles[profileName];
            if (!profile) {
                print(`Profile ${profileName} does not exist`);
                return;
            }
            const pipes = merge(config.pipes, profile.config);
            for (let [id, pipeconfig] of Object.entries(pipes)) {
                const disableViaCfg = pipeconfig.enabled === false;
                const disableViaCmd = ~this.args.disable.indexOf(id);
                const enableViaCmd = ~this.args.enable.indexOf(id);
                if (disableViaCfg || disableViaCmd && !enableViaCmd) {
                    pipes[id].enabled = false;
                }
            }
            this.config = {
                bungle: bungle,
                pipes: pipes,
                profiles: config.profiles
            };
            return this.runner.run(this.config);
        }
    }

    load(dir) {
        const configfile = path.join(dir, 'bungle.json');

        if (fs.existsSync(configfile)) {
            const data = fs.readFileSync(configfile, 'utf8');
            let config;
            try {
                config = JSON.parse(data);
            } catch (err) {
                print(`Cannot parse bungle.json: ${err.message}`);
            }
            process.chdir(dir);
            return config;
        } else {
            dir = path.dirname(dir);
            if (dir === '/') {
                print('Cannot find a bungle.json config file');
                return;
            }
            return this.load(dir);
        }
    }
}
