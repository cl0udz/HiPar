import path from 'path';
import css from 'css';
import mime from 'mime';
import { InputContentPipe } from '../pipe';


const unbracketRx = /.*\(['"]([^)]+)['"]\).*/;
const urlExtractRx =
    /url\( *(?:(?:(?!['"])([^)]+))|(?:(?=['"])(?:('|")((?:(?!\2).)+)\2))) *\)/g;


export default class ExtPipe extends InputContentPipe {
    constructor() {
        super(...arguments);

        this.defaultConfig({
            pattern: '**/*.{css,eot,svg,ttf,woff,woff2}',
            main: 'main.css',
            filename: 'main-built.css'
        });

        this.fromdir = path.dirname(this.config.main);
        this.dir = path.dirname(this.config.filename);
    }

    static schema() {
        return {
            description: 'Bundle CSS, fonts and images into one css file.',
            properties: {
                main: {
                    description: 'Entry point module of the bundle ' +
                                 '(default: "main.js")',
                    type: 'string'
                },
                filename: {
                    description: 'Filename of the bundle ' +
                                 '(default: "main-built.css")',
                    type: 'string'
                }
            },
            required: ['main', 'filename']
        };
    }

    rebase(decl, from, to) {
        decl.value = decl.value.replace(urlExtractRx, (_0, _1, _2, _3) => {
            const quote = _2 || '';
            let url = _1 || _3;
            if (!/^data:/.test(url)) {
                url = path.relative(to, path.normalize(path.join(from, url)));
            }
            return `url(${quote}${url}${quote})`;
        });
    }

    rebaseUrl(rules, from, to) {
        for (let rule of rules) {
            if (rule.rules) {
                this.rebaseUrl(rule.rules, from, to);
            }
            if (rule.declarations) {
                rule.declarations
                    .filter(decl => /url/.test(decl.value))
                    .forEach(decl => this.rebase(decl, from, to));
            }
        }
    }

    async loadRecursively(pathname) {
        const dir = path.dirname(pathname);
        const source = (await this.remoteFile(pathname).content()).toString();
        const ast = css.parse(source || '');
        const rules = ast.stylesheet.rules;
        const skip = [];

        for (;;) {
            let impRule = null;
            for (let rule of rules) {
                if (rule.type === 'import' && !~skip.indexOf(rule['import'])) {
                    impRule = rule;
                }
            }
            if (!impRule) {
                break;
            }

            let impName;
            if (/^('|")/.test(impRule['import'])) {
                impName = JSON.parse(impRule['import']);
            } else {
                impName = impRule['import'].replace(unbracketRx, '$1');
            }

            let impFilename = null;
            for (let name in this.state.remoteFiles) {
                if (path.relative(dir, name) === impName) {
                    impFilename = name;
                    break;
                }
            }

            if (impFilename) {
                const recfile = await this.loadRecursively(impFilename);
                const impRules = recfile.stylesheet.rules;
                this.rebaseUrl(impRules, path.dirname(impFilename), dir);
                impRules.unshift(rules.indexOf(impRule), 1);
                rules.splice.apply(rules, impRules);
            } else {
                skip.push(impRule['import']);
            }
        }

        if (skip.length) {
            this.log('error', 'Could not embed ' + skip);
        }

        for (let rule of rules) {
            if (!rule.declarations) {
                continue;
            }
            const decls = rule.declarations.filter(d => d.property === 'src');

            for (let decl of decls) {
                const urls = [];
                decl.value
                    .replace(/\n/g, '')
                    .replace(urlExtractRx, (_0, _1, _2, _3) => {
                        urls.push(_1 || _3);
                    });

                for (let url of urls) {
                    let filename = url.replace(/(#|\?).*$/, '');
                    filename = path.normalize(path.join(dir, filename));
                    if (this.state.remoteFiles[filename]) {
                        const mimetype = mime.lookup(filename);
                        const data =
                            (await this.remoteFile(filename).content())
                            .toString('base64');

                        decl.value = decl.value.replace(
                            url, `data:${mimetype};base64,${data}`
                        );
                    }
                }
            }
        }
        return ast;
    }

    async generate(file) {
        if (this.config.debug) {
            this.log('debug', '#C# ' + this.config.filename);
        }

        const ast = await this.loadRecursively(this.config.main);
        this.rebaseUrl(ast.stylesheet.rules, this.fromdir, this.dir);
        this.log('verbose', `Bundling ${file.name}`);
        const code = css.stringify(ast);
        return code;
    }
}
