import path from 'path';
import { BasePipe } from '../pipe';
import { readFile, dedent } from '../utils';

const polydir = path.dirname(path.dirname(require.resolve('babel-polyfill')));
const polyfile = path.join(polydir, 'dist', 'polyfill.js');


const loader = dedent`
var define, require;
(function() {
    function currentScript() {
        return document.currentScript || (function() {
            var scripts = document.getElementsByTagName('script');
            return scripts[scripts.length - 1];
        })();
    }

    function dirname(entry) {
        return entry.replace(/\\/[^\\/]+$/, '');
    }

    function join(left, right) {
        if (right[0] !== '.') {
            var pkg = require._pkgs
                .filter(function(p) { return p.name === right; })[0];
            return pkg.location + '/' + pkg.main;
        } else {
            var lefts = left.split('/');
            var rights = right.split('/');

            lefts.pop();
            if (rights[0] === '.') {
                rights.shift();
            }

            while(rights[0] === '..') {
                lefts.pop();
                rights.shift();
            }
            return lefts.concat(rights).join('/');
        }
    }

    function download(url) {
        if (!define.promises[url]) {
            var promise = new Promise(function(resolve/*, reject*/) {
                var script = document.createElement('script');
                script.setAttribute('src', url);
                script.setAttribute('type', 'text/javascript');

                _resolve = resolve;
                script.onload = script.onreadystatechange = function() {
                    if (!this.readyState ||
                            this.readyState === 'loaded' ||
                            this.readyState === 'complete') {

                        // TODO: check if leaking;
                        if (document.head && script.parentNode) {
                            document.head.removeChild(script);
                        }
                    }
                };
                document.head.appendChild(script);
                define.promises[url] = { resolve: resolve };
            });
            define.promises[url].promise = promise;
        }
        return define.promises[url];
    }

    define = function(deps, func) {
        var name = currentScript().src;
        name = name.substring(prefix.length, name.length-3);

        var promises = deps.filter(function(dep) {
            return !~[ 'exports', 'module' ].indexOf(dep);
        }).map(function(dep) {
            return download(prefix + join(name, dep) + '.js').promise;
        });

        _uAMD_m[name] = [ deps, func ];
        Promise.all(promises).then(function() {
            define.promises[prefix + name +'.js'].resolve();
        });
    };

    define.uamd = true;
    define.promises = {};

    require = function(name) {
        if (!_uAMD_m[name]) {
            throw new Error('Module "' + name + '" required, but does not exist.');
        }
        if (!_uAMD_r[name]) {
            _uAMD_r[name] = { exports: {} };
            var ref, i, len, d, deps=[];
            for (i=0, ref=_uAMD_m[name][0], len=ref.length; i<len; i++) {
                deps[i] =
                    ((d=ref[i])==='module') ?
                    _uAMD_r[name] : ((d=ref[i])==='exports') ?
                                    _uAMD_r[name].exports :
                                    require(join(name, d));
            }
            _uAMD_m[name][1].apply(this.global||this, deps);
        }
        return _uAMD_r[name].exports;
    };

    require.pkgs = function(_pkgs) {
        this._pkgs = _pkgs;
    };

    var _uAMD_m = {}
    var _uAMD_r = {};
    var prefix = document.baseURI ||
                 dirname(document.location.href.split('#')[0]);

    var entryPoint = currentScript().dataset.main.replace('.js', '');
    download(prefix + entryPoint + '.js').promise.then(function() {
        require(entryPoint);
    });
})();
`;

export default class ExtPipe extends BasePipe {
    constructor() {
        super(...arguments);

        this.defaultState({
            pkgs: []
        });
    }

    static schema() {
        return {
            description: 'Loader for AMD compliant sources.',
            properties: {
                polyfill: {
                    description:
                        'Add babel polyfill before loader (default: false)',
                    type: 'boolean'
                }
            }
        };
    }

    async start() {
        if (!this.state.polyfill) {
            this.state.polyfill = await readFile(polyfile);
        }
        if (!this.exists('loader-amd.js')) {
            await this.fileAdd('loader-amd.js');
            await this.fileChange('loader-amd.js', Date.now());
        }
        return super.start();
    }

    async generate(/*file*/) {
        return (this.config.polyfill ? this.state.polyfill : '') +
            loader + `require.pkgs(${JSON.stringify(this.state.pkgs)});`;
    }

    async broadcast(req) {
        if (req.type === 'bower_config') {
            this.log('verbose', 'Got bower config');
            this.state.pkgs = req.config;
        }
    }
}
