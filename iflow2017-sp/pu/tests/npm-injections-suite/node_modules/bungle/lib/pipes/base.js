import minimatch from 'minimatch';

import { File } from '../file';


export class BasePipe {
    constructor(config, state, pipeline) {
        this.config = config;
        this.state = state;
        this.pipeline = pipeline;

        this.outputs = [];
        this.started = false;

        this.defaultState({
            localFiles: {},
            remoteFiles: {}
        });

        for (let [name, meta] of Object.entries(this.state.localFiles)) {
            this.state.localFiles[name] = File.fromJSON(this, meta);
        }

        this.log('debug', 'Pipe created');
    }

    schema() {
        return {};
    }

    init() {
        return 'pipe::init';
    }

    start() {
        this.started = true;
        return 'pipe::start';
    }

    stop() {
        return 'pipe::stop';
    }

    newFile(meta) {
        meta.origin = this.config.id;
        return new File(this, meta);
    }

    sibling(id) {
        return this.pipeline.pipes[id];
    }

    remoteFile(name) {
        const pipe = this.state.remoteFiles[name];
        if (pipe) {
            return this.sibling(pipe).state.localFiles[name];
        } else {
            return null;
        }
    }

    mtime(/*file*/) {
        return '' + Date.now();
    }

    async generate(file) {
        try {
            return await file.source.content();
        } catch (err) {
            this.log('error', err);
            this.log('error', err.stack);
        }
    }

    exists(name) {
        return !!this.state.localFiles[name];
    }

    fileAdd(name) {
        let file = this.state.localFiles[name];
        if (file) {
            if (file.deleting) {
                file.deleting = false;
            } else {
                this.log('warn', `Tried to add existing file ${name}`);
                return;
            }
        } else {
            file = this.state.localFiles[name] = this.newFile({name:name});
        }

        return file.promise = file.promise.then(() => {
            if (this.config.debug) {
                this.log('debug', `LA ${name}`);
            }

            return this
            .send('remoteAdd', file)
            .then(() => file)
            .catch(err => {
                this.log('error', `Adding ${name} ${err}`);
                this.log('error', err.stack);
            });
        });
    }

    fileChange(name, mtime=null) {
        const file = this.state.localFiles[name];

        if (mtime === null) {
            mtime = '' + this.mtime(file);
        }


        if (!file) {
            this.log('warn', `Tried to change ${name}, but it was not added`);
            return;
        }

        if (file.deleting) {
            this.log('warn', `Tried to change ${name} while it is being removed`);
            return;
        }

        if (file.mtime === mtime) {
            this.log('info', `No change on file ${name} ${mtime}`);
            return Promise.resolve();
        }
        file.mtime = mtime;

        return file.promise = file.promise.then(() => {
            if (file.mtime !== mtime) {
                this.log('info', `Double change on file ${name}`);
                return;
            }

            if (this.config.debug) {
                this.log('debug', `LC ${name} ${mtime}`);
            }

            return this
                .send('remoteChange', file)
                .catch(err => {
                    this.log('error', `Changing ${name} ${err}`);
                    this.log('error', err.stack);
                });
        });
    }

    fileUnlink(name) {
        const file = this.state.localFiles[name];

        if (!file) {
            this.log('warn', `Tried to unlink ${name} while it was not added`);
            return;
        }

        if (file.deleting) {
            this.log('warn', `Tried to unlink ${name} while it is being removed`);
            return;
        }

        file.deleting = true;
        file.mtime = 0;

        return file.promise = file.promise.then(() => {
            if (this.config.debug) {
                this.log('debug', `LU ${name}`);
            }

            return this
            .send('remoteUnlink', file)
            .then(() => {
                if (file.addCount !== 0) {
                    this.log(
                        'warn',
                        `Removing ${file.name} addCount ${file.addCount} !== 0`
                    );
                }
                if (file.deleting) {
                    delete this.state.localFiles[name];
                }
            })
            .catch(err => {
                this.log('error', `Unlinking ${name} ${err}`);
                this.log('error', err.stack);
            });
        });
    }

    async remoteAdd(file) {
        try {
            if (this.rename) {
                throw new Error('remoteAdd, rename cannot be set');
            } else {
                return this.send('remoteAdd', file);
            }
        } catch (err) {
            this.log('error', err);
            this.log('error', err.stack);
        }
    }

    async remoteChange(file) {
        try {
            if (this.rename) {
                throw new Error('remoteChg, rename cannot be set');
            } else {
                return this.send('remoteChange', file);
            }
        } catch (err) {
            this.log('error', err);
            this.log('error', err.stack);
        }
    }

    async remoteUnlink(file) {
        try {
            if (this.rename) {
                throw new Error('remoteUnl, rename cannot be set');
            } else {
                return this.send('remoteUnlink', file);
            }
        } catch (err) {
            this.log('error', err);
            this.log('error', err.stack);
        }
    }

    recv(action, file) {
        if (!this.config.pattern || minimatch(file.name, this.config.pattern)) {
            if (action === 'remoteAdd') {
                this.state.remoteFiles[file.name] = file.origin;
            }
            if (action === 'remoteUnlink') {
                delete this.state.remoteFiles[file.name];
            }
            if (this.config.debug) {
                this.log('debug', `${action[6].toUpperCase()} ${file.name}`);
            }
            return this[action](file);
        } else if (this.config.passthrough) {
            return this.send(action, file);
        } else {
            return;
        }
    }

    send(action, file) {
        if (this.outputs.length) {
            const p = Promise.resolve(file);
            return Promise.all(this.outputs.map(o =>
                p.then(arg => o.recv(action, arg))
            ));
        } else {
            return Promise.resolve();
        }
    }

    broadcast() {
    }

    log(level, ...args) {
        if (level === 'debug' && !this.config.debug) {
            return;
        }
        return this.pipeline.logger.log(
            level, `${this.config.type}(${this.config.id})`, ...args
        );
    }

    defaultState(state) {
        for (let [k, v] of Object.entries(state)) {
            if (this.state[k] === undefined) {
                this.state[k] = v;
            }
        }
    }

    defaultConfig(config) {
        for (let [k, v] of Object.entries(config)) {
            if (this.config[k] === undefined) {
                this.config[k] = v;
            }
        }
    }
}
