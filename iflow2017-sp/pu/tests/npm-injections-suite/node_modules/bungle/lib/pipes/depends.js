import crypto from 'crypto';

import { BasePipe } from './base';
import { mergeArrays } from '../utils';


export class DependsPipe extends BasePipe {
    constructor() {
        super(...arguments);

        this.defaultState({
            depsOf: {},
            mtimes: {},
            alldeps: []
        });
    }

    depsOf(name, added=[]) {
        let deps = [];
        for (let dep of (this.state.depsOf[name]||[])) {
            if (!~added.indexOf(dep)) {
                deps.push(dep);
                deps = deps.concat(this.depsOf(dep, deps));
            }
        }
        return deps;
    }

    mtime(file) {
        const mtime = crypto.createHmac('md5', '');
        for (let name of file.sources.sort()) {
            if (this.remoteFile(name)) {
                mtime.update(name);
                mtime.update('' + this.remoteFile(name).mtime);
            }
        }
        return mtime.digest('hex');
    }

    rename(name) {
        return name;
    }

    async sanitize() {
        const alldeps = this.state.alldeps;
        for (let name of Object.keys(this.state.remoteFiles)) {
            const oname = this.rename(name);

            if (~alldeps.indexOf(name)) {
                if (this.exists(oname)) {
                    await this.fileUnlink(oname);
                }
            } else {
                if (!this.exists(oname)) {
                    await this.fileAdd(oname);
                    this.state.localFiles[oname].sources = this.depsOf(name);
                }
                const file = this.state.localFiles[oname];
                const mtime = this.mtime(file);
                if (mtime !== file.mtime) {
                    await this.fileChange(oname, mtime);
                }
            }
        }

    }

    async start() {
        for (let name of Object.keys(this.state.remoteFiles)) {
            const file = this.remoteFile(name);
            if (this.state.mtimes[name] != file.mtime) {
                this.state.depsOf[name] = await this.dependencies(name);
                this.state.mtimes[name] = file.mtime;
            }
        }
        this.state.alldeps = mergeArrays(Object.values(this.state.depsOf));
        await this.sanitize();
        return super.start();
    }

    async remoteAdd(file) {
        file.addCount++;
        this.state.depsOf[file.name] = [];
        this.state.mtimes[file.name] = null;

        if (this.started) {
            if (!~this.state.alldeps.indexOf(file.name)) {
                await this.fileAdd(this.rename(file.name));
            }
        }

        return file;
    }

    async notifyParents(file, reason) {
        for (let name of Object.keys(this.state.remoteFiles)) {
            const oname = this.rename(name);
            if (this.exists(oname) &&
                ~this.state.localFiles[oname].sources.indexOf(file.name)) {

                this.log('debug', `${reason} ${file.name} -> change ${oname}`);
                this.state.localFiles[oname].sources = this.depsOf(name);
                await this.fileChange(oname);
            }
        }
    }

    async remoteChange(file) {
        if (this.started) {
            this.state.depsOf[file.name] = await this.dependencies(file.name);
            this.state.mtimes[file.name] = this.remoteFile(file.name).mtime;
            this.state.alldeps = mergeArrays(Object.values(this.state.depsOf));

            if (this.exists(this.rename(file.name))) {
                const oname = this.rename(file.name);
                this.log('debug', `change ${file.name} -> change ${oname}`);
                this.state.localFiles[oname].sources = this.depsOf(file.name);
                await this.fileChange(oname);
            } else {
                this.notifyParents(file, 'change');
            }

            await this.sanitize();
        }

        return file;
    }

    async remoteUnlink(file) {
        file.addCount--;
        delete this.state.depsOf[file.name];
        delete this.state.mtimes[file.name];

        if (this.started) {
            this.state.alldeps = mergeArrays(Object.values(this.state.depsOf));

            if (this.exists(this.rename(file.name))) {
                const oname = this.rename(file.name);
                this.log('debug', `unlink ${file.name} -> unlink ${oname}`);
                await this.fileUnlink(oname);
            } else {
                this.notifyParents(file, 'unlink');
            }

            await this.sanitize();
        }

        return file;
    }
}
