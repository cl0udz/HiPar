/*
watcher.js 2.5.3- app watcher
Built on 2015-10-20
*/
"use strict";var _=require("underscore"),s=require("underscore.string"),Validate=require("validate-arguments"),logger=require("./logger"),constants=require("./constants"),socketConnectorType=constants.connectorType.socket,httpConnectorType=constants.connectorType.http,serverValidationSpec={port:"natural",host:"string",interval:"natural",routeExts:{isa:"Array",optional:!0},nfOpts:{sender:{isa:"string",optional:!0},recipients:{isa:"Array",optional:!0},isa:"Object",optional:!0},resolutionStrategies:{isa:"Array",optional:!0}},endpointValidationSpec={id:"string",type:"string",desc:{isa:"string",optional:!0},host:{isa:"string",optional:!0},port:{isa:"natural",optional:!0},url:{isa:"string",optional:!0},timeout:{isa:"natural",optional:!0},active:{isa:"boolean",optional:!0},notify:{isa:"boolean",optional:!0},resolutionStrategy:{isa:"object",optional:!0}};module.exports={validateServerConfig:function(a){var b=[],c=a.resolutionStrategies||[],d=_.pluck(c,"id");_.size(_.uniq(d))!==_.size(d)&&b.push("duplicate resolution strategies ids");var e=["resolveOnConnection","resolveOnConversation","resolveNow","reset"];_.each(c,function(a){_.each(e,function(c){var d=a.implementation;_.isFunction(d[c])||b.push("strategy, '"+d+"', function implementation missing '"+c+"'")})}),_.isUndefined(a.interval)||(a.interval=parseInt(a.interval));var f=Validate.named(a,serverValidationSpec);return f.isValid()||b.push(f.errorString()),b},validateEndpointConfig:function(a,b,c){var d,e=a.type,f=[];_.each(a,function(a,b,c){s.isBlank(a)&&(c[b]=void 0)}),b.push(a.id),_.size(_.uniq(b))!==_.size(b)&&f.push("duplicate endpoint ids");var g=a.resolutionStrategy;if(g&&!_.isFunction(g))if(g=_.find(c,function(a){return g===a.id})){var h=g.id;a.resolutionStrategy=g.implementation,a.resolutionStrategy.id=h}else f.push("Unable to apply a no existing strategy '"+g+"' to the endpoint '"+a.id+"' ");if(_.isUndefined(a.timeout)||(a.timeout=parseInt(a.timeout)),e){switch(e){case socketConnectorType:_.isUndefined(a.port)||(a.port=parseInt(a.port)),d=Validate.named(a,endpointValidationSpec);break;case httpConnectorType:var i=a.url;i&&(s.startsWith(i,"http")||s.startsWith(i,"https")||f.push("Only http/https protocol supported.")),d=Validate.named(a,endpointValidationSpec);break;default:f.push("Can not prepare options for type: "+e)}d.isValid()||f.push(d.errorString())}else f.push("Endpoint type is not defined");return f}};