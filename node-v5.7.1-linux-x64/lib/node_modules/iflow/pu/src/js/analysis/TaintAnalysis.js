/*
 *  A very simple hello world program
 *  demonstrating some simple operation
 *  interception using Jalangi
 */

J$.analysis = {};

(function(sandbox) {
    function TaintAnalysis() {
	var attr_finder = require('/home/hjw/Goldie/taintable/attr_finder/main.js');
        var iidToLocation = sandbox.iidToLocation;

        var currentFile;
        var currentFunc;
        var valueID = 0;

        var tainted_values = {}; // {file: {function: {id: loc}}}
        var taint_trace = {};

        var smemory = sandbox.smemory;

	function convertString(val){
	    return new String(val);
	}

        this.scriptEnter = function(iid, fileName) {

        };

        this.scriptExit = function(iid) {

        };

        this.functionEnter = function(iid, fun, dis, args) {

        };

        this.functionExit = function(iid) {

        };

        this.literal = function(iid, val) {
            //console.log('creating literal operation intercepted: ' + val);
            return val;
        };

        this.invokeFunPre = function(iid, f, base, args, isConstructor) {
            //console.log('function call intercepted before invoking');
	    if(f)
		console.log("Calling: " + f.name);

        };

        this.functionEnter = function(iid, fun, dis /* this */ , args) {

        };

        this.invokeFun = function(iid, f, base, args, val, isConstructor) {
            //console.log('function call intercepted after invoking');

            //val.id = valueID++;
            if (f.name === "source") {
                //tainted_values[val.id] = iidToLocation(val.id);
		if(typeof(args[0]) == "string"){
		    //args[0] = convertString(args[0]);
		}
		//args[0].tainted = true;

		if(typeof(val) == "string"){
		    //val = convertString(val);
		}
		//val.tainted = true;
            }

	    //console.log("Tainted something. args[0]: " + args[0]);

            currentFunc = f.name;
            return val;
        };

        this.getField = function(iid, base, offset, val) {
            //console.log('get field operation intercepted: ' + offset);
            return val;
        }

        this.read = function(iid, name, val, isGlobal) {
            //console.log('reading variable operation intercepted: ' + name);
	    if(val && val.hasOwnProperty('tainted') && val.tainted == true){
		console.log("Tainted varaible. name: " + name + ", val: " + val);
		var vlocation = iidToLocation(iid);
		console.log("Location: " + vlocation);
		if(/.*:\d*:\d*:\d*:\d*/.test(vlocation)){
		    var content = vlocaton.split(":");
		    var loc = {};
		    loc['file_loc'] = content[0];
		    loc['var_loc'] = {};
		    loc['var_loc']['start']['line'] = parseInt(content[1], 10);
		    loc['var_loc']['start']['column'] = parseInt(content[2], 10);
		    loc['var_loc']['end']['line'] = parseInt(content[3], 10);
		    loc['var_loc']['end']['column'] = parseInt(content[4], 10);

		    console.log(JSON.stringify(loc));
		}
	    }
            return val;
        };

        this.write = function(iid, name, val, oldValue) {
            //console.log('writing variable operation intercept: ' + name);
	    if(val && val.hasOwnProperty("tainted") && val.tainted == true)
		console.log("write to name: " + name);
            if (val && tainted_values.hasOwnProperty(val.id) != -1) {
                tainted_values[iid] = iidToLocation(iid);
            }
            // TODO: Clean the value in the future
            return val;
        };

        this.binary = function(iid, op, left, right, result_c) {
            //console.log('binary operation intercepted: ' + op);

	    if(left && left.hasOwnProperty("tainted") && left.tainted == true){
		    
	    }
            return result_c;
        };
    }

    sandbox.analysis = new TaintAnalysis();
})(J$);
