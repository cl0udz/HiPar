import { Inotify } from '../build/Release/inotify';
import { EventEmitter } from 'events';
import fs from 'fs';
import minimatch from 'minimatch';


export default class Watcher extends EventEmitter {
    constructor(base, {globs, entries}) {
        super();

        this.base = base;
        this.matchers = globs.map(glob => {
            return new minimatch.Minimatch(glob, { nonegate: true });
        });

        this.notifier = new Inotify();
        this.entries = entries;
    }

    scan() {
        const entries = this.walk(this.base);
        const names = entries.map(entry => entry.name);

        for (let name in this.entries) {
            const entry = this.entries[name];
            if (!entry.isdir && !~names.indexOf(name)) {
                this.emit('unlink', entry);
                delete this.entries[name];
            }
        }

        for (let entry of entries) {
            if (!entry.isdir) {
                const prevEntry = this.entries[entry.name];
                if (!prevEntry) {
                    this.emit('add', entry);
                    this.emit('change', entry);
                } else if (prevEntry.mtime !== entry.mtime) {
                    this.emit('change', entry);
                }
            }

            this.watchEntry(entry, this);
            this.entries[entry.name] = entry;
        }
    }

    close() {
        this.notifier.close();
    }

    partialMatch(value) {
        const parts = value.split(/\/|\\/g).filter(Boolean);
        for (let matcher of this.matchers) {
            for (let entry of matcher.set) {
                if (matcher.matchOne(parts, entry, true)) {
                    return true;
                }
            }
        }
        return false;
    }

    match(path) {
        for (let matcher of this.matchers) {
            if (matcher.match(path)) {
                return true;
            }
        }
        return false;
    }

    makeEntry(name, stats) {
        return {
            name,
            mode: stats.mode,
            size: stats.size,
            mtime: +stats.mtime,
            isdir: stats.isDirectory()
        };
    }

    watchEntry(entry) {
        if (entry.isdir) {
            entry.wd = this.notifier.add({
                path: entry.name || '.',
                callback: evt => {
                    if (evt.mask & (Inotify.IN_CREATE|Inotify.IN_MOVED_TO)) {
                        if (evt.mask & Inotify.IN_ISDIR) {
                            this.addDir(`${entry.name}${evt.name}`);
                        } else {
                            this.add(`${entry.name}${evt.name}`);
                        }
                    }
                    if (evt.mask & (Inotify.IN_DELETE|Inotify.IN_MOVED_FROM)) {
                        if (evt.mask & Inotify.IN_ISDIR) {
                            this.unlinkDir(`${entry.name}${evt.name}`);
                        } else {
                            this.unlink(`${entry.name}${evt.name}`);
                        }
                    }
                }
            });
        } else {
            entry.wd = this.notifier.add({
                path: entry.name,
                callback: evt => {
                    if (evt.mask & Inotify.IN_MODIFY) {
                        entry.dirty = true;
                    }
                    if (evt.mask & Inotify.IN_CLOSE_WRITE && entry.dirty) {
                        entry.dirty = false;
                        this.change(entry.name);
                    }
                }
            });
        }
    }

    walk(baseDir, baseRel='') {
        let results = [];
        if (!this.partialMatch(baseRel)) {
            return [];
        }

        if (!baseRel) {
            const stats = fs.statSync(baseDir);
            results.push(this.makeEntry('', stats));
        }

        const entries = fs.readdirSync(`${baseDir}/${baseRel}`).sort();
        for (let entry of entries) {
            const pathRel = `${baseRel}${entry}`;

            if (!this.partialMatch(pathRel)) {
                continue;
            }

            const stats = fs.statSync(`${baseDir}/${pathRel}`);

            if (stats.isDirectory()) {
                results.push(this.makeEntry(`${pathRel}/`, stats));
                results = results.concat(this.walk(baseDir, `${pathRel}/`));
            } else {
                if (this.match(pathRel)) {
                    results.push(this.makeEntry(pathRel, stats));
                }
            }
        }
        return results;
    }

    addDir(name) {
        if (this.partialMatch(name)) {
            const stats = fs.statSync(name);
            const entry = this.makeEntry(`${name}/`, stats);
            this.watchEntry(entry);
            this.entries[name] = entry;
            const entries = this.walk(this.base, `${name}/`);
            for (let entry of entries) {
                this.watchEntry(entry);
                this.entries[entry.name] = entry;
                this.add(entry.name);
                this.change(entry.name);
            }
        }
    }

    unlinkDir(name) {
        if (this.partialMatch(name)) {
            delete this.entries[name];
            Object
                .keys(this.entries)
                .filter(k => k.startsWith(name))
                .sort()
                .forEach(k => {
                    const entry = this.entries[k];
                    try {
                        this.notifier.remove(entry.wd);
                    } catch (e) {
                        throw e;
                    }
                    if (entry.isdir) {
                        delete this.entries[k];
                    } else {
                        this.unlink(k);
                    }
                });
        }
    }

    add(name) {
        if (!this.match(name)) {
            return;
        }
        const stats = fs.statSync(name);
        const entry = this.makeEntry(name, stats);
        this.watchEntry(entry, this);
        this.entries[name] = entry;

        this.emit('add', this.entries[name]);
        this.emit('change', this.entries[name]);
    }

    change(name) {
        if (!this.match(name)) {
            return;
        }
        const stats = fs.statSync(name);
        const entry = this.entries[name];

        if (entry.mtime != +stats.mtime) {
            entry.mode = stats.mode;
            entry.size = stats.size;
            entry.mtime = +stats.mtime;

            this.emit('change', entry);
        }
    }

    unlink(name) {
        if (!this.match(name)) {
            return;
        }
        const entry = this.entries[name];
        delete this.entries[name];

        this.emit('unlink', entry);
    }
}
