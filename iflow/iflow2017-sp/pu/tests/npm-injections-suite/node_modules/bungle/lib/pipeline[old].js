import path from 'path';
import zlib from 'zlib';
import { EventEmitter } from 'events';
import { thenifyNode, readFile, writeFile, mkdirp, unlink } from './utils';

RegExp.prototype.toJSON = function() {
    return {
        type: 'RegExp',
        source: this.source,
        flags: [
            this.global ? 'g' : '',
            this.multiline ? 'm' : '',
            this.ignoreCase ? 'i' : ''
        ].join('')
    };
};

Buffer.prototype.toJSON = function() {
    return {
        type: 'Buffer',
        data: this.toString('hex')
    };
};

function parseExJSON(json) {
    function convert(data) {
        for (let [k, v] of Object.entries(data)) {
            if (v && v.type === 'RegExp') {
                data[k] = new RegExp(v.source, v.flags);
            } else if (v && v.type === 'Buffer') {
                data[k] = new Buffer(v.data, 'hex');
            } else if (v === null) {
                data[k] = v;
            } else if (typeof v === 'object') {
                convert(v);
            }
        }
        return data;
    }
    return convert(JSON.parse(json));
}


const gunzip = thenifyNode(zlib.gunzip);
const gzip = thenifyNode(zlib.gzip);


function setupSIGINT(log) {
    let shuttingDown = false;

    process.on('SIGINT', function() {
        if (shuttingDown) {
            log.log('info', 'process', 'Force exiting ...');
            log.log('debug', 'process', process._getActiveHandles());
            return process.exit();
        } else {
            shuttingDown = true;
            log.log('info', 'process', 'Shutting down gracefully ...');
            Promise.all(Pipeline.instances.map(pipeline => {
                return pipeline.cleanup();
            })).then(() => {
                log.log('info', 'process', 'Bye');
                //return process.exit();
            });
        }
    });
}

export class Pipeline extends EventEmitter {
    constructor(logger, cfg) {
        super();
        this.logger = logger;
        this.cfg = cfg;
        this.pipes = {};
        if (!this.constructor.sigintInstalled) {
            setupSIGINT(this.logger);
            this.constructor.sigintInstalled = true;
        }
        this.init();
    }

    async init() {
        try {
            await mkdirp('.bungle');
        } catch (err) {
            if (err.errno !== -17) {
                throw err;
            }
        }
        try {
            this.state = await this.loadState();
            await this.createPipes();
            await this.orderedPipes.reduce((p, i) => p.then(() => i.start()), Promise.resolve());

            const active = process._getActiveHandles().length > 2;
            if (active) {
                this.constructor.instances.push(this);
                this.log('info', 'Startup complete');
            } else {
                await this.cleanup();
                this.log('info', 'All done');
            }

        } catch(e) {
            this.log('error', `Pipeline constructor error ${e} ${e.stack}`);
            process.exit(1);
        }
    }

    loadState() {
        const filename = path.join('.bungle', 'state.' + this.cfg.config.hash);
        if (this.cfg.config.bungle.reset) {
            this.log('verbose', 'Discarding previous state');
            return unlink(filename)
                .catch(() => null)
                .then(() => ({
                    hash: this.cfg.config.hash
                }));
        } else {
            return readFile(filename)
                .then(compressed => gunzip(compressed))
                .then(data => parseExJSON(data))
                .catch(() => {
                    this.log('verbose', 'Starting with a fresh state');
                    return {
                        hash: this.cfg.config.hash
                    };
                });
        }
    }

    async createPipes() {
        for (let [id, pipeconfig] of Object.entries(this.cfg.config.pipes)) {
            const pipestate = this.state[id] || (this.state[id] = {});
            const PipeClass = this.cfg.pipes[pipeconfig.type];
            this.pipes[id] = new PipeClass(pipeconfig, pipestate, this);
        }

        let res = await Promise.all(Object.values(this.pipes).map(p => p.init()));

        if (res.some(r => r !== 'pipe::init')) {
            this.log('error', 'A pipe did not properly return super.init()');
        }

        for (let [id, pipeconfig] of Object.entries(this.cfg.config.pipes)) {
            for (let input of pipeconfig.inputs) {
                this.pipes[input].outputs.push(this.pipes[id]);
            }
        }

        let unsorted = Object.values(this.pipes);
        let sorted = [];
        while (unsorted.length) {
            let add = unsorted.filter(u => {
                return u.outputs.every(o => ~sorted.indexOf(o));
            });
            sorted = sorted.concat(add);
            unsorted = unsorted.filter(u => !~add.indexOf(u));
        }
        this.orderedPipes = sorted.reverse();
        return this.orderedPipes;
    }

    async cleanup() {
        this.log('info', 'Saving state');

        let res = await Promise.all(Object.values(this.pipes).map(pipe => pipe.stop()));
        if (res.some(r => r !== 'pipe::stop')) {
            this.log('error', 'A pipe did not properly return super.stop()');
        }

        const filename = path.join('.bungle', 'state.' + this.cfg.config.hash);
        const jsonz = await gzip(JSON.stringify(this.state));

        try {
            await writeFile(filename, jsonz);
        } catch (err) {
            this.log('error', `Could not dump state cache ${err}`);
        }
        this.log('info', 'Pipeline shutdown complete');
    }

    broadcast(req) {
        return Promise.all(Object.values(this.pipes).map(p => {
            return p.broadcast(req);
        }));
    }

    log(level, ...args) {
        const applyargs = [level, 'pipeline'].concat(args);
        return this.logger.log.apply(this.logger, applyargs);
    }
}

Pipeline.sigintInstalled = false;
Pipeline.instances = [];
