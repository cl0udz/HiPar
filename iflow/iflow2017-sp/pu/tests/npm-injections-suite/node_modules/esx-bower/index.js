/* eslint no-console:0 */

import fs from 'fs';
import path from 'path';

import { EventEmitter } from 'events';

import bower from 'bower';
import request from 'request';
import {parse} from 'babylon';
import generate from 'babel-generator';
import semver from 'semver';


function thenifyEmitter(fn) {
    return function() {
        let args = Array.prototype.slice.call(arguments);
        return new Promise(function(resolve, reject) {
            fn.apply(this, args)
                .on('end', function(arg) { resolve(arg); })
                .on('error', function(err) { reject(err); });
        });
    };
}


function thenifyNode(fn) {
    return function() {
        let args = Array.prototype.slice.call(arguments);
        return new Promise(function(resolve, reject) {
            args.push((err, arg) => {
                if (err) {
                    //console.log(err);
                }
                return err ? reject(err) : resolve(arg);
            });

            fn.apply(this, args);
        });
    };
}


let bowerList = thenifyEmitter(bower.commands.list);
let bowerUpdate = thenifyEmitter(bower.commands.update);
let readFile = thenifyNode(fs.readFile);
let open = thenifyNode(fs.open);
let close = thenifyNode(fs.close);
let networkRequest = thenifyNode(request, ['res', 'body']);
let stat = thenifyNode(fs.stat);
let writeFile = thenifyNode(fs.writeFile);


function* zip() {
    let args = Array.prototype.slice.call(arguments);
    const length = Math.max.apply(null, args.map(arg => arg.length));
    for (let i = 0; i < length; i++) {
        yield args.map(arg => arg[i]);
    }
}


function* enumerate(arr) {
    for (let i in arr) {
        yield [i, arr[i]];
    }
}


function walkAst(node, fn) {
    const stack = [];

    function visit(node) {
        if (!node || typeof node.type !== 'string') {
            return;
        }

        fn(node, stack);

        for (let prop in node) {
            const child = node[prop];

            if (Array.isArray(child)) {
                for (let i = 0; i < child.length; i++) {
                    stack.push({
                        node: node,
                        prop: prop,
                        index: i
                    });
                    visit(child[i]);
                    stack.pop();
                }
            } else {
                stack.push({
                    node: node,
                    prop: prop
                });
                visit(child);
                stack.pop();
            }
        }
    }
    visit(node);
}

function withAst(source, fn) {
    const ast = parse(source);
    const oldLeading = ast.program.body[0].leadingComments;
    ast.program.body[0].leadingComments = null;
    fn(ast);
    if (oldLeading) {
        oldLeading.forEach(node => {
            if (!/^!/.test(node.value)) {
                if (/\(c\)|copyright/i.test(node.value)) {
                    node.value = `!${node.value}`;
                }
            }
        });
        const newLeading = ast.program.body[0].leadingComments;
        if (newLeading) {
            if (newLeading[0].value !== oldLeading[0].value) {
                newLeading.unshift.apply(newLeading, oldLeading);
            }
        } else {
            ast.program.body[0].leadingComments = oldLeading;
        }
    }
    return generate(ast, {}, '').code;
}

const hooks = {
    wrap(param, source) {
        let prepend = '';
        if (param.prepend) {
            if (Array.isArray(param.prepend)) {
                prepend = `${param.prepend.join('\n')}\n`;
            } else {
                prepend = `${param.prepend}\n`;
            }
        }
        let append = '';
        if (param.append) {
            if (Array.isArray(param.append)) {
                append = `\n${param.append.join('\n')}`;
            } else {
                append = `\n${param.append}`;
            }
        }
        return `${prepend}${source}${append}`;
    },

    umd(param, source) {
        return withAst(source, ast => {
            let i = 0;
            while(i < ast.program.body.length && ast.program.body[i].type === 'EmptyStatement') {
                i++;
            }
            if (ast.program.body[i].type !== 'ExpressionStatement' ||
                (ast.program.body[i].expression.type !== 'CallExpression' &&
                ast.program.body[i].expression.type !== 'UnaryExpression')
            ) {
                throw new Error('Could not find UMD loader.');
            }

            const callee = ast.program.body[i].expression.callee ||
                ast.program.body[i].expression.argument.callee;
            const args = ast.program.body[i].expression.arguments ||
                ast.program.body[i].expression.argument.arguments;
            let factory;
            for (let [i, param] of enumerate(callee.params)) {
                if (param.name === 'factory') {
                    factory = args[i];
                }
            }

            if (!factory && args[0].type === 'FunctionExpression') {
                factory = args[0];
            }

            if (!factory) {
                throw new Error('Could not find factory passed to UMD loader.');
            }

            const exportdecl = [
                {
                    type: 'VariableDeclaration',
                    declarations: [{
                        type: 'VariableDeclarator',
                        id: {
                            type: 'Identifier',
                            name: '__export'
                        },
                        init: {
                            type: 'CallExpression',
                            callee: factory,
                            arguments: []
                        }
                    }],
                    kind: 'var'
                },
                {
                    type: 'ExportDefaultDeclaration',
                    declaration: {
                        type: 'Identifier',
                        name: '__export'
                    }
                }
            ];

            for (let [, param] of enumerate(factory.params)) {
                if (param.name === 'window') {
                    exportdecl[0].declarations[0].init.arguments.push({
                        type: 'Identifier',
                        name: 'window'
                    });
                } else if (param.name === 'global') {
                    exportdecl[0].declarations[0].init.arguments.push({
                        type: 'ThisExpression'
                    });
                } else if (param.name === 'noGlobal') {
                    exportdecl[0].declarations[0].init.arguments.push({
                        type: 'BooleanLiteral',
                        value: true,
                        raw: true
                    });
                } else {
                    exportdecl[0].declarations[0].init.arguments.push({
                        type: 'Identifier',
                        name: param.name
                    });
                }
            }

            ast.program.body = exportdecl;
        });
    },

    killLoader(params, source) {
        return withAst(source, ast => {
            const matchTypes = [
                'ConditionalExpression',
                'IfStatement'
            ];

            walkAst(ast, (node, stack) => {
                if (node.type === 'Identifier' &&
                    (node.name === 'module' || node.name === 'define') &&
                    stack[stack.length-1].node.operator === 'typeof'
                ) {
                    for (let i = stack.length-1; i>=1; i--) {
                        if (~matchTypes.indexOf(stack[i].node.type)) {
                            let pnode = stack[i-1];
                            if (pnode.index) {
                                pnode.node[pnode.prop][pnode.index].type =
                                    'EmptyStatement';
                            } else {
                                pnode.node[pnode.prop].type = 'EmptyStatement';
                            }
                        }
                    }
                }
            });
        });
    },

    extractFunction(params, source) {
        return withAst(source, ast => {
            let found = false;

            walkAst(ast, (node, stack) => {
                if (found) {
                    return;
                }

                if (node.type === 'FunctionExpression') {
                    if (node.body && node.body.body) {
                        for (let i = stack.length-1; i >= 0; i--) {
                            if (stack[i].node.type === 'Program') {
                                Array.prototype.splice.apply(
                                    stack[i].node.body,
                                    [stack[i].index, 1].concat(node.body.body)
                                );
                                found = true;
                                return;
                            }
                        }
                    }
                }
            });
        });
    },

    jqueryPlugin(params, source) {
        return `
            import $ from 'jquery';
            var jQuery = $, jquery = $;
            ${source}
            export default null;`;
    },

    replace(params, src) {
        return src.replace(new RegExp(params.regex), params.replace);
    }
};

export class Bower extends EventEmitter {
    constructor(options) {
        super();
        this.profile = options.profile || 'development';
        this.offline = options.offline || false;
        this.patches = options.patches ||
        'https://raw.githubusercontent.com/durko/esx-legacy/master/patches-0.1.0.json';
        this.cachedir = options.cachedir || '.';

        this.state = options.state || {};
        this.state.mtimes = this.state.mtimes || {};
        this.state.pkgs = this.state.pkgs || {};
    }

    init() {
        return Promise.resolve()
            .then(() => this.loadBowerRc())
            .then(() => this.loadPatchSource())
            .then(() => this.check());
    }

    loadBowerRc() {
        return readFile('.bowerrc')
        .catch(() => '{}')
        .then(json => {
            let bowerrc = JSON.parse(json);

            this.state.bowerrc = bowerrc;
            bowerrc.directory = bowerrc.directory || 'bower_components';
        });
    }

    loadPatchSource() {
        let action;
        if (/^http/.test(this.patches)) {
            const cache = path.join(this.cachedir, 'esxbower.json');
            const exists = fs.existsSync(cache);
            if (exists) {
                action = readFile(cache);
            } else {
                action = networkRequest(this.patches)
                .then(r => {
                    if (r.statusCode < 300) {
                        return writeFile(cache, r.body).then(() => r.body);
                    } else {
                        throw Error('Could not download legacy patches from ' +
                            r.request.href);
                    }
                });
            }
        } else {
            action = readFile(this.patches);
        }

        return action
        .then(json => this.patches = JSON.parse(json))
        .catch(err => {
            console.log('ES6T loading failed');
            console.log(err);
            throw err;
        });
    }

    mtimes(files) {
        return Promise.all(files.map(file => {
            return stat(file)
                .then(attrs => +attrs.mtime)
                .catch(() => -1);
        }));
    }

    dependencyFiles(name) {
        const dir = this.state.bowerrc.directory;

        return Object.keys(this.state.pkgs).map(dep => {
            return path.join(dir, dep, name);
        });
    }

    metaFor(name, pkg) {
        function sanitizePaths(paths) {
            if (!paths) {
                return [];
            }

            if (!Array.isArray(paths)) {
                paths = [ paths ];
            }

            return paths.map(function(filename) {
                return filename.replace(/^\.\//, '');
            });
        }

        if (pkg.missing || pkg.incompatible) {
            return {
                version: null
            };
        } else {
            const version = pkg.pkgMeta.version || '0.0.0';
            const pkgspec = this.patches[name] || {};
            const bestVersion = this.selectVersion(version, Object.keys(pkgspec));

            return {
                version: version,
                files: sanitizePaths(pkg.pkgMeta.main),
                patches: pkgspec[bestVersion] || []
            };
        }
    }

    gatherMeta(pkgs) {
        const meta = {};

        let metaFor = this.metaFor.bind(this);

        function extract(desc) {
            Object.entries(desc.dependencies || {}).forEach(([name, pkg]) => {
                meta[name] = metaFor(name, pkg);
                extract(pkg);
            });
        }

        extract(pkgs);
        return meta;
    }

    selectVersion(version, versions) {
        let ret = '0.0.0';

        for (let [, ver] of Object.entries(versions)) {
            if (semver.gt(ver, version)) {
                continue;
            }

            if (semver.gt(ver, ret)) {
                ret = ver;
            }
        }
        return ret;
    }

    check() {
        const sMtimes = this.state.mtimes;

        function checkMtime([file, mtime]) {
            return sMtimes[file] === mtime;
        }

        function saveMtime([file, mtime]) {
            sMtimes[file] = mtime;
        }

        let files;

        files = this.dependencyFiles('.bower.json').concat(['bower.json']);

        return this.mtimes(files).then(mtimes => {
            const filesTimes = Array.from(zip(files, mtimes));
            if (filesTimes.every(checkMtime)) {
                return filesTimes;
            } else {
                return this.runBower().then(() => {
                    files = this
                        .dependencyFiles('.bower.json')
                        .concat(['bower.json']);

                    return this.mtimes(files);
                }).then(times => {
                    Array.from(zip(files, times)).forEach(ft => saveMtime(ft));
                });
            }
        }).then(() => {
            files = this.dependencyFiles('.esx-bower');
            return this.mtimes(files).then(mtimes => {
                if (mtimes.some(mtime => mtime == -1)) {
                    return this.runEsx();
                }
            });
        }).then(() => {
            this.pkgfiles = {};
            for (let [name, meta] of Object.entries(this.state.pkgs)) {
                const main = meta.patches.files || {};
                const files = Array.from(meta.files);
                const profiles = meta.patches.profiles || {};
                const removes = Object.values(main).map(p => p.source);
                const adds = Object.keys(main);

                for (let profileName of ['*', this.profile]) {
                    const profile = profiles[profileName] || {};
                    if (profile.remove) {
                        profile.remove.forEach(remove => removes.push(remove));
                    }
                    if (profile.add) {
                        profile.add.forEach(add => adds.push(add));
                    }
                }

                for (let add of adds) {
                    if (~files.indexOf(add)) {
                        throw new Error(
                            'Patches should not overwrite exiting files'
                        );
                    }
                    files.unshift(add);
                }

                for (let remove of removes) {
                    if (~files.indexOf(remove)) {
                        files.splice(files.indexOf(remove), 1);
                    }
                }
                this.pkgfiles[name] = files;
            }
        }).then(() => {
            this.emit('All good');
        });
    }

    runBower() {
        return bowerList({options: false}, this.state.bowerrc)
        .then(pkgs => {
            this.state.pkgs = this.gatherMeta(pkgs);

            const miss = new Set(Object.entries(this.state.pkgs)
                .filter(([, pkg]) => pkg.version === null)
                .map(([name]) => name));

            if (miss.size) {
                var options = {
                    offline: this.offline
                };

                return bowerUpdate([], options, this.state.bowerrc)
                .then(updated => {
                    for (let [name, pkg] of Object.entries(updated)) {
                        this.state.pkgs[name] = this.metaFor(name, pkg);
                        this.emit('installed', {
                            name: name,
                            version: pkg.pkgMeta.version
                        });
                    }
                    return updated;
                });
            }
        });
    }

    runEsx() {
        const dir = this.state.bowerrc.directory;
        const deps = Object.keys(this.state.pkgs);
        const controlFiles = deps.map((dep) => {
            return path.join(dir, dep, '.esx-bower');
        });

        return this.mtimes(controlFiles).then(mtimes => {
            const pkgs = Array.from(zip(deps, controlFiles, mtimes))
                .filter(([, , mtime]) => mtime === -1)
                .map(([dep]) => dep);

            return Promise.all(pkgs.map(pkg => this.esxize(pkg)));
        });
    }

    esxize(pkgname) {
        const meta = this.state.pkgs[pkgname];
        const dir = this.state.bowerrc.directory;

        let p;
        if (meta.patches.files) {
            p = Promise.all(Object.entries(meta.patches.files).map(([filename, patch]) => {
                console.log('patching file', filename);

                const sname = path.join(dir, pkgname, patch.source);
                return readFile(sname, 'utf8').then(source => {
                    for (let op of patch.ops) {
                        console.log('   applying', op.type);

                        const hook = hooks[op.type];
                        if (!hook) {
                            throw new Error(`Package "${pkgname}" uses ` +
                                `unknown hook "${op.type}"`);
                        }

                        source = hooks[op.type].call(this,
                            op,
                            source
                        );
                    }
                    const tname = path.join(dir, pkgname, filename);
                    return writeFile(tname, source);
                });

            }));
        } else {
            p = Promise.resolve();
        }

        return p
            .then(() => open(path.join(dir, pkgname, '.esx-bower'), 'w'))
            .then(f => close(f));
    }

    pkgConfig() {
        function isExt(ext) {
            return function(f) {
                return new RegExp(`\.${ext}$`).test(f);
            };
        }

        const dir = this.state.bowerrc.directory;
        const pkgs = [];

        for (let [name, files] of Object.entries(this.pkgfiles)) {
            const js = files.filter(isExt('js'));
            if (!js.length) {
                continue;
            }

            const filename = path.join(dir, name, js[0].replace(/\.js$/, ''));

            const css = files.filter(isExt('css'));
            let style;
            if (css.length) {
                style = path.join(dir, name, css[0]);
            }

            pkgs.push({
                name,
                main: path.basename(filename),
                location: path.dirname(filename),
                style
            });
        }

        return pkgs;
    }

    filenames() {
        const dir = this.state.bowerrc.directory;

        return Object.entries(this.pkgfiles).reduce((l, [name, files]) => {
            return l.concat(files.map(file => path.join(dir, name, file)));
        }, []);
    }

    jsForPkg(pkg, names) {
        const dir = this.state.bowerrc.directory;
        const files = names.length ? names : this.pkgfiles[pkg];

        return files
            .filter(f => /\.js$/.test(f))
            .map(f => path.join(dir, pkg, f));
    }
}
