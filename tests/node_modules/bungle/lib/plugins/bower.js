import { Bower } from 'esx-bower';
import { BasePipe } from '../pipe';
import { dedent, readFile, stat } from '../utils';


const nameEML = 'es6-module-loader/dist/es6-module-loader-sans-promises.js';


export default class ExtPipe extends BasePipe {
    constructor() {
        super(...arguments);

        this.defaultConfig({
            offline: false,
            patches: '',
            profile: 'development'
        });

        this.defaultState({
            esxbower: {}
        });

        this.afterInit = [];
    }

    static schema() {
        return {
            description: dedent `
                Manage vendor resources with bower.
                Optionally convert resources to ES6 module syntax.
                Optionally manage requirejs config.
            `,
            properties: {
                offline: {
                    description: 'Do not use internet connection.' +
                                 '(default: false)',
                    type: 'boolean'
                },
                patches: {
                    description: 'Source for patching legacy modules to es6.' +
                                 '(default: \'\')',
                    type: 'string'
                },
                profile: {
                    description: 'Bower patch profile to use.' +
                                 '(default: \'development\')',
                    type: 'string'
                }
            }
        };
    }

    async init() {
        this.bower = new Bower({
            offline: this.config.offline,
            patches: this.config.patches,
            profile: this.config.profile,
            cachedir: '.bungle',
            state: this.state.esxbower
        });
        this.bower.on('installed', pkg => {
            this.log(
                'info',
                `Installed vendor package ${pkg.name}@${pkg.version}`
            );
        });

        await this.bower.init();

        this.pipeline.broadcast({
            type: 'bower_config',
            config: this.bower.pkgConfig()
        });

        return super.init();
    }

    async start() {
        this.state.directory = this.bower.state.bowerrc.directory;

        return this.bower.filenames().reduce((p, name) => {
            if (!this.exists(name)) {
                p = p.then(() => this.fileAdd(name));
            }
            return p
                .then(() => stat(name))
                .then(stat => {
                    const mtime = +stat.mtime;
                    if (mtime !== this.state.localFiles[name].mtime) {
                        return this.fileChange(name, mtime);
                    }
                });
        }, Promise.resolve()).then(() => super.start());
    }

    async generate(file) {
        const name = file.name;
        let content = await readFile(name);
        if (name === `${this.state.directory}/${nameEML}`) {
            const mods = this.bower.pkgConfig().map(p => {
                p.location = '../' + p.location;
                return 'System.paths[${p.name}] = ' +
                       `'${p.location}/${p.main}.js;'`;
            });
            content = new Buffer(`${content}\n${mods.join('\n')}`);
        }
        return content;
    }

    async broadcast(req) {
        if (req.type === 'getVendorVanillaPackages') {
            const res = {};
            for (let [pkg, names] of Object.entries(req.packages)) {
                res[pkg] = Promise.all(
                    this.bower.jsForPkg(pkg, names).map(file => readFile(file))
                );
            }

            return Promise.all(Object.values(res)).then(values => {
                Object.keys(res).forEach((key, i) => {
                    res[key] = values[i];
                });
                return res;
            });
        }
    }
}
