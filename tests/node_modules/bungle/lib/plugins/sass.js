import path from 'path';
import sass from 'node-sass';
import { DependsPipe } from '../pipe';
import { thenifyNode } from '../utils';


const render = thenifyNode(sass.render);

const urlExtractRx =
    /url\( *(?:(?:(?!['"])([^)]+))|(?:(?=['"])(?:('|")((?:(?!\2).)+)\2))) *\)/g;


export default class ExtPipe extends DependsPipe {
    constructor() {
        super(...arguments);

        this.defaultConfig({
            pattern: '**/*.{scss,css}'
        });

        this.defaultState({
            bower: {}
        });
    }

    static schema() {
        return {
            description: 'Compile .scss resources to css.'
        };
    }

    rename(name) {
        return name.replace(/scss$/, 'css');
    }

    async dependencies(name) {
        const content = (await this.remoteFile(name).content()).toString();
        const dirname = path.dirname(name);
        const imports = content.match(/@import '(.*)';/g);
        if (!imports) {
            return [];
        }
        return imports.reduce((p, s) => {
            const name = s
                .replace(/@import '(.*)';/, '$1');

            return p.concat([
                path.join(dirname, name),
                path.join(dirname, name + '.css'),
                path.join(dirname, name + '.scss')
            ]);
        }, []);
    }

    rebase(content, from, to) {
        return content.replace(urlExtractRx, (_0, _1, _2, _3) => {
            const quote = _2 || '';
            let url = _1 || _3;
            if (!/^data:/.test(url)) {
                url = path.relative(to, path.normalize(path.join(from, url)));
            }
            return `url(${quote}${url}${quote})`;
        });
    }

    async generate(file) {
        if (this.remoteFile(file.name)) {
            return this.remoteFile(file.name).content();
        }
        try {
            const name = file.name.replace(/css$/, 'scss');
            const content = await this.remoteFile(name).content();
            const ret = await render({
                data: content.toString(),
                file: name,
                outFile: file.name,
                outputStyle: 'nested',
                sourceMap: true,
                sourceMapEmbed: true,
                sourceMapContents: true,
                importer: (url, prev, done) => {
                    let rname = path.basename(url);
                    if (rname[0] === '@') {
                        rname = rname.substr(1);
                        if (this.state.bower[rname]) {
                            url = path.relative(
                                path.dirname(prev),
                                this.state.bower[rname].style
                            );
                        }
                    }
                    prev = path.relative(process.cwd(), prev);
                    const dirname = path.dirname(prev);
                    const impname = path.join(dirname, url);
                    const rfile =
                        this.remoteFile(impname) ||
                        this.remoteFile(impname + '.css') ||
                        this.remoteFile(impname + '.scss');
                    if (rfile) {
                        rfile.content().then(content => {
                            try {
                                content = this.rebase(
                                    content.toString(),
                                    path.dirname(rfile.name),
                                    path.dirname(file.name)
                                );
                            } catch(err) {
                                this.log('error', err);
                                this.log('error', err.stack);
                            }
                            done({
                                file: rfile.name,
                                contents: content.toString()
                            });
                        });
                    } else {
                        done({
                            file: impname,
                            contents: `/* ${impname} does not exist */`
                        });
                    }
                }
            });
            return ret.css.toString();
        } catch(err) {
            throw new Error(
                `${err.message}\nLine ${err.line} Column ${err.column}`
            );
        }
    }

    async broadcast(req) {
        if (req.type === 'bower_config') {
            this.log('verbose', 'Got bower config');
            this.state.bower = {};
            for (let pkg of req.config) {
                this.state.bower[pkg.name] = pkg;
            }
        }
    }
}
