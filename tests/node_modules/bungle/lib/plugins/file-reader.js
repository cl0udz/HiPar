import path from 'path';
import Watcher from '../watcher';
import { BasePipe } from '../pipe';
import { readFile, realpath } from '../utils';


export default class ExtPipe extends BasePipe {
    constructor() {
        super(...arguments);

        this.defaultConfig({
            basedir: '.',
            continuous: false
        });

        this.defaultState({
            hashes: {},
            adds: [],
            changes: [],
            unlinks: [],
            readnums: {},
            entries: {}
        });

    }

    static schema() {
        return {
            description: 'Read files from disk.',
            properties: {
                basedir: {
                    description: 'Source directory (default: \'.\')',
                    type: 'string'
                },
                continuous: {
                    description:
                        'Keep observing directory for changes (default: false)',
                    type: 'boolean'
                }
            }
        };
    }

    async init() {
        return realpath(this.config.basedir)
            .then(basedir => this.config.basedir = basedir)
            .catch(() => {
                this.log('error', 'Cannot read from ' + this.config.basedir);
                this.config.basedir = null;
            })
            .then(() => super.init());
    }

    async start() {
        if (!this.config.basedir) {
            return;
        }

        this.watcher = new Watcher(this.config.basedir, {
            globs: [this.config.pattern],
            entries: this.state.entries
        });

        this.watcher.on('add', entry => {
            this.state.readnums[entry.name] = 0;
            return this.fileAdd(entry.name);
        });

        this.watcher.on('change', entry => {
            return this.fileChange(entry.name, entry.mtime);
        });

        this.watcher.on('unlink', entry => {
            delete this.state.readnums[entry.name];
            return this.fileUnlink(entry.name);
        });

        this.watcher.scan();

        if (!this.config.continuous) {
            this.watcher.close();
        }

        return super.start();
    }

    async stop() {
        if (this.config.continuous) {
            this.watcher.close();
        }
        return super.stop();
    }

    async generate(file) {
        const counts = this.state.readnums;
        counts[file.name]++;
        this.log('debug', `Reading ${file.name} (${counts[file.name]})`);
        return readFile(path.join(this.config.basedir, file.name))
            .catch(() => {
                this.log('error', 'Could not read', file.name);
                return '';
            });
    }
}
