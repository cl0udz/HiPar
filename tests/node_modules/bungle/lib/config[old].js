import crypto from 'crypto';
import path from 'path';

import tv4 from 'tv4';


function serializeObject(obj) {
    function type(x) {
        const t = typeof x;
        if (t === 'object' && x instanceof Array) {
            return 'array';
        } else {
            return t;
        }
    }

    const encodeMap = {
        boolean(b) {
            return 'b' + (b ? 1 : 0);
        },

        string(s) {
            return s.length + ':' + s;
        },

        number(i) {
            return 'i' + i + 'e';
        },

        array(a) {
            const results = [];
            for (let e of a) {
                results.push(encode(e));
            }
            return 'a' + results.join('') + 'e';
        },

        object(o) {
            if (o === null) {
                return 'n';
            }
            const results = [];
            for (let key of Object.keys(o).sort()) {
                results.push(`${encode(key)}${encode(o[key])}`);
            }
            return 'o' + results.join('') + 'e';
        }
    };

    function encode(x) {
        return encodeMap[type(x)](x);
    }

    return encode(obj);
}

export class Config {
    constructor(config, logger, pipes) {
        this.config = config;
        this.logger = logger;
        this.pipes = pipes;

        for (let [name, meta] of Object.entries(this.config.pipes)) {
            if (meta.enabled === false) {
                this.config.pipes[name] = meta = {
                    type: 'noop'
                };
            }
            delete meta.enabled;
            meta.id = name;

            meta.inputs = meta.inputs || [];
            for (let input of Object.values(meta.inputs)) {
                if (!this.config.pipes[input]) {
                    this.log('error',
                        `Pipe ${name} references an unknown input pipe ${input}`
                    );
                    return {
                        ok: false
                    };
                }
            }
        }

        this.schema = {
            $schema: 'http://json-schema.org/draft-04/schema#',
            id: 'http://git.savensis.net/bungle-config-schema#',
            title: 'Bungle',
            description: 'Bungle pipeline configuration',
            type: 'object',
            properties: {
                bungle: {
                    description: 'Bungle configuration section',
                    type: 'object',
                    properties: {
                        logger: {
                            type: 'object',
                            properties: {
                                console: {
                                    type: 'string'
                                },
                                notify: {
                                    type: 'string'
                                }
                            },
                            additionalProperties: false
                        },
                        checkconfig: {
                            type: 'boolean'
                        },
                        reset: {
                            type: 'boolean'
                        }
                    },
                    additionalProperties: false
                },
                hash: {
                    description: 'Config file hash, added on the fly',
                    type: 'string'
                },
                profiles: {
                    description: 'Configuration profiles of the pipeline',
                    type: 'object',
                    patternProperties: {
                        '^.+$': {
                            description: 'Configuration profile instance',
                            type: 'object',
                            properties: {
                                description: {
                                    type: 'string',
                                    description: 'Profile description shown in help'
                                },
                                config: {
                                    type: 'object',
                                    description: 'Profile config'
                                }
                            },
                            required: ['description', 'config'],
                            additionalProperties: false
                        },
                        additionalProperties: false
                    },
                    additionalProperties: false
                },
                pipes: {
                    description: 'The pipe instances to create for this pipeline',
                    type: 'object',
                    patternProperties: {
                        '^.+$': {
                            description: 'Pipe instance config',
                            type: 'object',
                            oneOf: []
                        }
                    }
                }
            },
            required: ['bungle', 'pipes'],
            additionalProperties: false
        };

        this.defaultFragmentProperties = {
            description: {
                description: 'Description of the pipe\'s function in the pipeline',
                type: 'string'
            },
            pattern: {
                description: 'Input accept pattern',
                type: 'string'
            },
            passthrough: {
                description: 'Pass unaccepted inputs through pipe (default: true)',
                type: 'boolean'
            },
            enabled: {
                description: 'Enable this pipe (default: false)',
                type: 'boolean'
            },
            debug: {
                description: 'Verbose pipe operations (default: false)',
                type: 'boolean'
            },
            inputs: {
                description: 'Connect inputs to these pipes (default: [])',
                type: 'array',
                items: {
                    type: 'string',
                    minItems: 1,
                    uniqueItems: true
                }
            }
        };

        if (this.config.bungle.checkconfig) {
            if (!this.validate(this.pipes)) {
                return {
                    ok: false
                };
            }
        }

        this.ok = true;
        this.config.hash = crypto
            .createHash('sha1')
            .update(require(path.join(__dirname, '..', 'package.json')).version)
            .update(serializeObject(this.config.pipes))
            .digest('hex');
        this.log('verbose', 'Config hash ' + this.config.hash);


    }

    validate(pipes) {
        const fragments = this.schema.properties.pipes.patternProperties['^.+$'].oneOf;
        for (let [id, pipe] of Object.entries(pipes)) {
            const fragment = pipe.schema() || {};
            fragment.properties = fragment.properties || {};

            for (let [k, v] of Object.entries(this.defaultFragmentProperties)) {
                fragment.properties[k] = v;
            }
            fragment.properties.type = {
                description: id,
                'enum': [id]
            };
            fragment.properties.id = {
                type: 'string'
            };
            fragment.additionalProperties = false;
            fragment.required = fragment.required || [];
            fragment.required.push('type');
            fragments.push(fragment);
        }

        const config = this.config;
        const validationStatus = tv4.validate(config, this.schema);
        if (validationStatus === false) {
            if (tv4.error.code === 11) {
                const subErrors = tv4.error.subErrors.filter(e => e.code !== 1);
                if (subErrors.length > 1) {
                    const dataPath = tv4.error.dataPath;
                    const id = tv4.error.dataPath.replace(/.*\//, '');
                    const pipe = config.pipes[id];
                    let fragment = null;
                    for (let f of Object.values(fragments)) {
                        if (f.properties.type['enum'][0] === pipe.type) {
                            fragment = f;
                            break;
                        }
                    }
                    if (fragment) {
                        tv4.validate(pipe, fragment);
                        const dp = tv4.error.dataPath;
                        this.log('error', `Pipe validation: ${dataPath + dp}`);
                        this.log('error', tv4.error.message);
                        return false;
                    } else {
                        this.log('error', `Pipe type unknown: ${pipe.type}`);
                        this.log('error', 'Run "bungle -L" to list known types');
                        return false;
                    }
                } else if (subErrors.length > 0) {
                    this.log('error', 'validation: ' + subErrors[0].dataPath);
                    this.log('error', subErrors[0].message);
                    return false;
                } else {
                    this.log('error', 'validation: ' + tv4.error.dataPath);
                    this.log('error', tv4.error.message);
                    return false;
                }
            } else {
                this.log('error', `Top-level validation: ${tv4.error.dataPath}`);
                this.log('error', tv4.error.message);
                return false;
            }
        }
        this.log('verbose', 'Validation successful');
        return validationStatus;
    }

    log(level, ...args) {
        const applyargs = [level, 'config'].concat(args);
        return this.logger.log.apply(this.logger, applyargs);
    }
}
