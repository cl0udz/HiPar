#include <string.h>
#include <sys/inotify.h>
#include <unistd.h>

#include "inotify.h"


namespace inotify {


    v8::Persistent<v8::Function> Inotify::constructor;


    Inotify::Inotify() {
        fd = inotify_init();

        if (fd == -1) {
            return;
        }

        int flags = fcntl(fd, F_GETFL);
        if (flags == -1) {
            flags = 0;
        }
        fcntl(fd, F_SETFL, flags | O_NONBLOCK);

        poll_handle = new uv_poll_t;
        poll_handle->data = this;
        uv_poll_init(uv_default_loop(), poll_handle, fd);
        uv_poll_start(poll_handle, UV_READABLE, Inotify::PollCb);
    }


    Inotify::~Inotify() {
        Shutdown();
    }


    int Inotify::Shutdown() {
        int ret = 0;

        if (poll_handle) {
            uv_poll_stop(poll_handle);
            uv_close((uv_handle_t *) poll_handle, Inotify::CloseCb);
            poll_handle = NULL;
        }

        if (fd) {
            ret = close(fd);
            fd = 0;
        }

        return ret;
    }


    void Inotify::Init(v8::Local<v8::Object> exports) {
        v8::Isolate* isolate = exports->GetIsolate();

        v8::Local<v8::FunctionTemplate> tpl =
            v8::FunctionTemplate::New(isolate, New);
        tpl->SetClassName(v8::String::NewFromUtf8(isolate, "Inotify"));
        tpl->InstanceTemplate()->SetInternalFieldCount(1);

        NODE_SET_PROTOTYPE_METHOD(tpl, "add", Add);
        NODE_SET_PROTOTYPE_METHOD(tpl, "remove", Remove);
        NODE_SET_PROTOTYPE_METHOD(tpl, "close", Close);

        v8::Local<v8::Function> fn = tpl->GetFunction();
        NODE_DEFINE_CONSTANT(fn, IN_ACCESS);
        NODE_DEFINE_CONSTANT(fn, IN_ATTRIB);
        NODE_DEFINE_CONSTANT(fn, IN_CLOSE_WRITE);
        NODE_DEFINE_CONSTANT(fn, IN_CLOSE_NOWRITE);
        NODE_DEFINE_CONSTANT(fn, IN_CREATE);
        NODE_DEFINE_CONSTANT(fn, IN_DELETE);
        NODE_DEFINE_CONSTANT(fn, IN_DELETE_SELF);
        NODE_DEFINE_CONSTANT(fn, IN_MODIFY);
        NODE_DEFINE_CONSTANT(fn, IN_MOVE_SELF);
        NODE_DEFINE_CONSTANT(fn, IN_MOVED_FROM);
        NODE_DEFINE_CONSTANT(fn, IN_MOVED_TO);
        NODE_DEFINE_CONSTANT(fn, IN_OPEN);

        NODE_DEFINE_CONSTANT(fn, IN_MOVE);
        NODE_DEFINE_CONSTANT(fn, IN_CLOSE);

        NODE_DEFINE_CONSTANT(fn, IN_DONT_FOLLOW);
        NODE_DEFINE_CONSTANT(fn, IN_EXCL_UNLINK);
        NODE_DEFINE_CONSTANT(fn, IN_MASK_ADD);
        NODE_DEFINE_CONSTANT(fn, IN_ONESHOT);
        NODE_DEFINE_CONSTANT(fn, IN_ONLYDIR);

        NODE_DEFINE_CONSTANT(fn, IN_IGNORED);
        NODE_DEFINE_CONSTANT(fn, IN_ISDIR);
        NODE_DEFINE_CONSTANT(fn, IN_Q_OVERFLOW);
        NODE_DEFINE_CONSTANT(fn, IN_UNMOUNT);

        NODE_DEFINE_CONSTANT(fn, IN_ALL_EVENTS);

        constructor.Reset(isolate, fn);
        exports->Set(
            v8::String::NewFromUtf8(isolate, "Inotify"),
            tpl->GetFunction()
        );
    }


    void Inotify::New(const v8::FunctionCallbackInfo<v8::Value>& args) {
        v8::Isolate* isolate = args.GetIsolate();

        Inotify *obj = new Inotify();

        if (obj->fd == -1) {
            isolate->ThrowException(
                v8::String::NewFromUtf8(isolate, strerror(errno))
            );
            args.GetReturnValue().Set(v8::Null(isolate));
        }

        obj->Wrap(args.This());
        obj->Ref();
        args.GetReturnValue().Set(args.This());
    }


    void Inotify::Add(const v8::FunctionCallbackInfo<v8::Value>& args) {
        v8::Isolate* isolate = args.GetIsolate();

        if(args.Length() < 1 || !args[0]->IsObject()) {
            isolate->ThrowException(v8::Exception::TypeError(
                v8::String::NewFromUtf8(
                    isolate,
                    "First argument has to be an object"
                )
            ));
            return;
        }

        v8::Local<v8::Object> options = args[0]->ToObject();
        v8::Local<v8::String> sym;

        sym = v8::String::NewFromUtf8(isolate, "path");
        if (!options->Has(sym)) {
            isolate->ThrowException(v8::Exception::TypeError(
                v8::String::NewFromUtf8(
                    isolate,
                    "options.path has to be set"
                )
            ));
            return;
        }
        v8::String::Utf8Value path(options->Get(sym));

        sym = v8::String::NewFromUtf8(isolate, "mask");
        uint32_t mask = 0;
        if (!options->Has(sym)) {
            mask |= IN_ALL_EVENTS;
        } else {
            if (!options->Get(sym)->IsInt32()) {
                isolate->ThrowException(v8::Exception::TypeError(
                    v8::String::NewFromUtf8(
                        isolate,
                        "options.mask has to be a bitmask"
                    )
                ));
                return;
            }
            mask |= options->Get(sym)->Int32Value();
            if (mask == 0) {
                isolate->ThrowException(v8::Exception::TypeError(
                    v8::String::NewFromUtf8(
                        isolate,
                        "options.mask has no events"
                    )
                ));
                return;
            }
        }

        sym = v8::String::NewFromUtf8(isolate, "callback");
        if (!options->Has(sym) || !options->Get(sym)->IsFunction()) {
            isolate->ThrowException(v8::Exception::TypeError(
                v8::String::NewFromUtf8(
                    isolate,
                    "options.callback has to be set"
                )
            ));
            return;
        }

        Inotify* obj = ObjectWrap::Unwrap<Inotify>(args.Holder());
        int wd = inotify_add_watch(obj->fd, (const char *) *path, mask);
        v8::Local<v8::Integer> descriptor = v8::Integer::New(isolate, wd);
        obj->handle()->Set(descriptor, options->Get(sym));

        args.GetReturnValue().Set(descriptor);
    }


    void Inotify::Remove(const v8::FunctionCallbackInfo<v8::Value>& args) {
        v8::Isolate* isolate = args.GetIsolate();

        if (args.Length() == 0 || !args[0]->IsInt32()) {
            isolate->ThrowException(v8::Exception::TypeError(
                v8::String::NewFromUtf8(
                    isolate,
                    "Argument is not a valid descriptor"
                )
            ));
            return;
        }

        Inotify *obj = ObjectWrap::Unwrap<Inotify>(args.Holder());
        uint32_t watch = args[0]->Int32Value();
        int ret = inotify_rm_watch(obj->fd, watch);
        if (ret == -1) {
            isolate->ThrowException(
                v8::String::NewFromUtf8(isolate, strerror(errno))
            );
            args.GetReturnValue().Set(v8::False(isolate));
            return;
        }

        args.GetReturnValue().Set(v8::True(isolate));
    }


    void Inotify::CloseCb(uv_handle_t* handle) {
        assert(!uv_is_active(handle));
        delete handle;
    }


    void Inotify::Close(const v8::FunctionCallbackInfo<v8::Value>& args) {
        v8::Isolate* isolate = args.GetIsolate();

        Inotify *obj = ObjectWrap::Unwrap<Inotify>(args.Holder());
        int ret = obj->Shutdown();

        if (ret == -1) {
            isolate->ThrowException(
                v8::String::NewFromUtf8(isolate, strerror(errno))
            );
            args.GetReturnValue().Set(v8::False(isolate));
        }

        obj->Unref();

        args.GetReturnValue().Set(v8::True(isolate));
    }


    void Inotify::PollCb(uv_poll_t *watcher, int status, int revents) {
        v8::Isolate* isolate = v8::Isolate::GetCurrent();
        v8::HandleScope scope(isolate);

        Inotify *obj = static_cast<Inotify*>(watcher->data);

        v8::TryCatch try_catch;

        size_t size = sizeof(struct inotify_event);
        size_t buflen = 1024 * (size + 16);
        char buffer[buflen];
        int sz;
        while ((sz = read(obj->fd, buffer, buflen)) > 0) {
            struct inotify_event *event;
            for (unsigned int i = 0; i <= sz-size; i += size + event->len) {
                event = (struct inotify_event *) &buffer[i];

                v8::Local<v8::Object> evt = v8::Object::New(isolate);
                evt->Set(
                    v8::String::NewFromUtf8(isolate, "wd"),
                    v8::Integer::New(isolate, event->wd)
                );
                evt->Set(
                    v8::String::NewFromUtf8(isolate, "mask"),
                    v8::Integer::New(isolate, event->mask)
                );
                evt->Set(
                    v8::String::NewFromUtf8(isolate, "cookie"),
                    v8::Integer::New(isolate, event->cookie)
                );

                if (event->len) {
                    evt->Set(
                        v8::String::NewFromUtf8(isolate, "name"),
                        v8::String::NewFromUtf8(isolate, event->name)
                    );
                }

                int argc = 1;
                v8::Local<v8::Value> argv[argc];
                argv[0] = evt;

                auto handle = obj->handle();
                auto callback = v8::Local<v8::Function>::Cast(
                    handle->Get(v8::Integer::New(isolate, event->wd))
                );

                node::MakeCallback(
                    isolate,
                    isolate->GetCurrentContext()->Global(),
                    callback, argc, argv
                );

                if(event->mask & IN_IGNORED) {
                    handle->Delete(
                        v8::Integer::New(isolate, event->wd)->ToString()
                    );
                }

                if (try_catch.HasCaught()) {
                    node::FatalException(isolate, try_catch);
                }
            }
        }
    }


} //namespace Inotify
