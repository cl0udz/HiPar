'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof3 = function _typeof3(obj) { return typeof obj; }; } else { _typeof3 = function _typeof3(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof3(obj); }

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var Aspect = require('./operation').Aspect;

var defineAspects = require('./operation').defineAspects;

var handleCallback = require('../utils').handleCallback;

var CursorState = require('../core/cursor').CursorState;

var OperationBase = require('./operation').OperationBase;

var push = Array.prototype.push;

var ToArrayOperation =
/*#__PURE__*/
function (_OperationBase) {
  _inherits(ToArrayOperation, _OperationBase);

  function ToArrayOperation(cursor) {
    var _this;

    _classCallCheck(this, ToArrayOperation);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ToArrayOperation).call(this));
    _this.cursor = cursor;
    return _this;
  }

  _createClass(ToArrayOperation, [{
    key: "execute",
    value: function execute(callback) {
      var cursor = this.cursor;
      var items = []; // Reset cursor

      cursor.rewind();
      cursor.s.state = CursorState.INIT; // Fetch all the documents

      var fetchDocs = function fetchDocs() {
        cursor._next(function (err, doc) {
          if (err) {
            return cursor._endSession ? cursor._endSession(function () {
              return handleCallback(callback, err);
            }) : handleCallback(callback, err);
          }

          if (doc == null) {
            return cursor.close({
              skipKillCursors: true
            }, function () {
              return handleCallback(callback, null, items);
            });
          } // Add doc to items


          items.push(doc); // Get all buffered objects

          if (cursor.bufferedCount() > 0) {
            var docs = cursor.readBufferedDocuments(cursor.bufferedCount()); // Transform the doc if transform method added

            if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') {
              docs = docs.map(cursor.s.transforms.doc);
            }

            push.apply(items, docs);
          } // Attempt a fetch


          fetchDocs();
        });
      };

      fetchDocs();
    }
  }]);

  return ToArrayOperation;
}(OperationBase);

defineAspects(ToArrayOperation, Aspect.SKIP_SESSION);
module.exports = ToArrayOperation;