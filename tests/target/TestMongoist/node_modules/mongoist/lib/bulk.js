"use strict";

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var mongodb = require('mongodb');

var maxBulkSize = 1000;
var oid = mongodb.ObjectID.createPk;

var Bulk =
/*#__PURE__*/
function () {
  function Bulk(colName, ordered, connect, opts) {
    _classCallCheck(this, Bulk);

    this.colName = colName;
    this.ordered = ordered;
    this.connect = connect;
    opts = opts || {
      writeConcern: {
        w: 1
      }
    };
    this.writeConcern = opts.writeConcern || {
      w: 1
    };
    this.cmds = [];
    this.cmdKeys = {
      insert: 'nInserted',
      "delete": 'nRemoved',
      update: 'nUpserted'
    };
  }

  _createClass(Bulk, [{
    key: "ensureCommand",
    value: function ensureCommand(cmdName, bulkCollection) {
      if (this.currentCmd && (!this.currentCmd[cmdName] || this.currentCmd[bulkCollection].length === maxBulkSize)) {
        this.cmds.push(this.currentCmd);
        this.currentCmd = null;
      }

      if (!this.currentCmd) {
        var _this$currentCmd;

        this.currentCmd = (_this$currentCmd = {}, _defineProperty(_this$currentCmd, cmdName, this.colName), _defineProperty(_this$currentCmd, bulkCollection, []), _defineProperty(_this$currentCmd, "ordered", this.ordered), _defineProperty(_this$currentCmd, "writeConcern", this.writeConcern), _this$currentCmd);
      }

      return this.currentCmd;
    }
  }, {
    key: "find",
    value: function find(q) {
      var _this = this;

      var _upsert = false;

      var remove = function remove(limit) {
        var cmd = _this.ensureCommand('delete', 'deletes');

        cmd.deletes.push({
          q: q,
          limit: limit
        });
      };

      var update = function update(u, multi) {
        var cmd = _this.ensureCommand('update', 'updates');

        cmd.updates.push({
          q: q,
          u: u,
          multi: multi,
          upsert: _upsert
        });
      };

      return new FindSyntax({
        update: update,
        upsert: function upsert(upsertValue) {
          _upsert = upsertValue;
        },
        remove: remove
      });
    }
  }, {
    key: "insert",
    value: function insert(doc) {
      var cmd = this.ensureCommand('insert', 'documents');
      doc._id = doc._id || oid();
      cmd.documents.push(doc);
    }
  }, {
    key: "execute",
    value: function execute() {
      var _this2 = this;

      this.pushCurrentCmd();
      var result = {
        writeErrors: [],
        writeConcernErrors: [],
        nInserted: 0,
        nUpserted: 0,
        nMatched: 0,
        nModified: 0,
        nRemoved: 0,
        upserted: []
      };

      var setResult = function setResult(cmd, cmdResult) {
        var cmdKey = Object.keys(cmd)[0];
        result[_this2.cmdKeys[cmdKey]] += cmdResult.n;
      };

      return this.connect().then(function (connection) {
        return each(_this2.cmds, function (cmd) {
          return connection.command(cmd).then(function (cmdResult) {
            return setResult(cmd, cmdResult);
          });
        });
      }).then(function () {
        result.ok = 1;
        return result;
      });
    }
  }, {
    key: "pushCurrentCmd",
    value: function pushCurrentCmd() {
      if (this.currentCmd) {
        this.cmds.push(this.currentCmd);
      }
    }
  }, {
    key: "tojson",
    value: function tojson() {
      if (this.currentCmd) {
        this.cmds.push(this.currentCmd);
      }

      var obj = {
        nInsertOps: 0,
        nUpdateOps: 0,
        nRemoveOps: 0,
        nBatches: this.cmds.length
      };
      this.cmds.forEach(function (cmd) {
        if (cmd.update) {
          obj.nUpdateOps += cmd.updates.length;
        } else if (cmd.insert) {
          obj.nInsertOps += cmd.documents.length;
        } else if (cmd["delete"]) {
          obj.nRemoveOps += cmd.deletes.length;
        }
      });
      return obj;
    }
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify(this.tojson());
    }
  }]);

  return Bulk;
}();

var FindSyntax =
/*#__PURE__*/
function () {
  function FindSyntax(cmds) {
    _classCallCheck(this, FindSyntax);

    this.cmds = cmds;
  }

  _createClass(FindSyntax, [{
    key: "upsert",
    value: function upsert() {
      this.cmds.upsert(true);
      return this;
    }
  }, {
    key: "remove",
    value: function remove() {
      this.cmds.remove(0);
    }
  }, {
    key: "removeOne",
    value: function removeOne() {
      this.cmds.remove(1);
    }
  }, {
    key: "update",
    value: function update(updObj) {
      this.cmds.update(updObj, true);
    }
  }, {
    key: "updateOne",
    value: function updateOne(updObj) {
      this.cmds.update(updObj, false);
    }
  }, {
    key: "replaceOne",
    value: function replaceOne(updObj) {
      this.updateOne(updObj);
    }
  }]);

  return FindSyntax;
}(); // TODO: This implementation is a bit whacky recursive implementation. PR anyone?


function each(cmds, executeCmd, idx) {
  idx = idx || 0;

  if (idx < cmds.length) {
    return executeCmd(cmds[idx]).then(function () {
      return each(cmds, executeCmd, idx + 1);
    });
  }

  return Promise.resolve();
}

module.exports = Bulk;