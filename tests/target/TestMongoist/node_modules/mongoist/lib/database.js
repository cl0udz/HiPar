"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.string.starts-with");

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var mongodb = require('mongodb');

var urlParser = require('mongodb/lib/url_parser.js');

var Collection = require('./collection');

var debug = require('debug')('mongoist');

function normalizeCommandOpts(opts) {
  return typeof opts === 'string' ? _defineProperty({}, opts, 1) : opts;
}

function normalizeConnectionString(connectionString) {
  // Fix short cut connection URLs consisting only of a db name or db + host
  if (connectionString.indexOf('/') < 0) {
    connectionString = 'localhost:27017/' + connectionString;
  }

  if (connectionString.indexOf('mongodb://') < 0 && connectionString.indexOf('mongodb+srv://') < 0) {
    connectionString = 'mongodb://' + connectionString;
  }

  return connectionString;
}
/**
 * Check whether the given value has a then method. This check classifies whether the value is a
 * thenable per the Promises/A+ spec, which we use as a reasonable test for whether a given value
 * is a promise. This method is preferrable to `instanceof Promise` because there are many possible
 * implementations of the `Promise` prototype (such as `bluebird`, `Q` etc) that we can't
 * exhaustively test for. Given the context/documentation, we don't expect other objects that we 
 * could confuse for promises.
 *
 * @param {*} value The value to check.
 * @return {boolean} Whether the given value is thenable.
 */


function isThenable(value) {
  return !!value && _typeof(value) === 'object' && typeof value.then === 'function';
}

module.exports =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Database, _EventEmitter);

  function Database(connectionString, options) {
    var _this;

    _classCallCheck(this, Database);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Database).call(this));

    if (typeof connectionString === 'string') {
      connectionString = normalizeConnectionString(connectionString);
    } else if (isThenable(connectionString)) {
      connectionString = connectionString.then(function (connectionString) {
        return typeof connectionString === 'string' ? normalizeConnectionString(connectionString) : connectionString;
      });
    }

    _this.connectionString = connectionString;
    _this.options = options || {}; // Define the property to not confuse the proxy

    _this.connection = null;
    _this.features = null;
    _this.client = null;
    return _this;
  }

  _createClass(Database, [{
    key: "createCollection",
    value: function createCollection(name, opts) {
      var cmd = Object.assign({
        create: name
      }, opts);
      return this.runCommand(cmd);
    }
  }, {
    key: "getCollectionInfos",
    value: function getCollectionInfos() {
      return this.connect().then(function (connection) {
        return connection.listCollections().toArray();
      }).then(function (collectionInfos) {
        return collectionInfos.filter(function (ci) {
          return !ci.name.startsWith('system.');
        });
      });
    }
  }, {
    key: "listCollections",
    value: function listCollections() {
      return this.getCollectionInfos();
    }
  }, {
    key: "getCollectionNames",
    value: function getCollectionNames() {
      return this.listCollections().then(function (collections) {
        return collections.map(function (collection) {
          return collection.name;
        });
      });
    }
  }, {
    key: "adminCommand",
    value: function adminCommand(opts) {
      return this.connect().then(function (connection) {
        return connection.executeDbAdminCommand(normalizeCommandOpts(opts));
      });
    }
  }, {
    key: "runCommand",
    value: function runCommand(opts) {
      if (typeof opts === 'string') {
        opts = _defineProperty({}, opts, 1);
      }

      return this.connect().then(function (connection) {
        return connection.command(normalizeCommandOpts(opts));
      });
    }
  }, {
    key: "stats",
    value: function stats(scale) {
      return this.runCommand({
        dbStats: 1,
        scale: scale
      });
    }
  }, {
    key: "createUser",
    value: function createUser(usr) {
      var cmd = Object.assign({
        createUser: usr.user
      }, usr);
      delete cmd.user;
      return this.runCommand(cmd);
    }
  }, {
    key: "dropUser",
    value: function dropUser(username) {
      return this.runCommand({
        dropUser: username
      });
    }
  }, {
    key: "dropAllUsers",
    value: function dropAllUsers() {
      return this.runCommand({
        dropAllUsersFromDatabase: 1
      });
    }
  }, {
    key: "dropDatabase",
    value: function dropDatabase() {
      return this.runCommand('dropDatabase');
    }
  }, {
    key: "getLastErrorObj",
    value: function getLastErrorObj() {
      return this.runCommand('getLastError');
    }
  }, {
    key: "getLastError",
    value: function getLastError() {
      return this.runCommand('getLastError').then(function (res) {
        return res.err;
      });
    }
  }, {
    key: "connect",
    value: function connect() {
      var _this2 = this;

      if (this.connection) {
        return Promise.resolve(this.connection);
      }

      if (typeof this.connectionString == 'string') {
        return parseUrl(this.connectionString, this.options).then(function (parsedUrl) {
          return parsedUrl.dbName;
        }).then(function (dbName) {
          return mongodb.MongoClient.connect(_this2.connectionString, {
            useNewUrlParser: true,
            useUnifiedTopology: true
          }, _this2.options).then(function (client) {
            _this2.client = client;
            _this2.connection = client.db(dbName);
            _this2.features = {
              useLegacyProjections: false
            };

            _this2.emit('connect');

            return _this2.connection;
          })["catch"](function (e) {
            _this2.emit('error', e);

            throw e;
          });
        });
      } else if (typeof this.connectionString._getConnection === 'function') {
        // mongojs
        return new Promise(function (resolve, reject) {
          _this2.connectionString._getConnection(function (err, connection, conn) {
            if (err) {
              return reject(err);
            }

            _this2.connection = connection;
            _this2.features = {
              // Third argument conn is only sent in mongojs 3
              useLegacyProjections: !conn
            };

            _this2.emit('connect');

            resolve(_this2.connection);
          });
        });
      } else if (this.connectionString instanceof Database) {
        // mongoist
        return this.connectionString.connect().then(function (connection) {
          _this2.connection = connection;
          _this2.features = {
            useLegacyProjections: false
          };

          _this2.emit('connect');

          return _this2.connection;
        });
      } else if (isThenable(this.connectionString)) {
        return Promise.resolve(this.connectionString).then(function (connectionString) {
          _this2.connectionString = connectionString;
          return _this2.connect();
        });
      }
    }
  }, {
    key: "close",
    value: function close(force) {
      var _this3 = this;

      return this.connect().then(function (connection) {
        if (_this3.client) {
          return _this3.client.close(force)["catch"](function (e) {
            // Ignore this
            debug("Could not close the connection due to error \"".concat(e.message, "\" ").concat(e.stack));
          });
        }

        if (connection.close) {
          return _this3.connection.close(force)["catch"](function (e) {
            // Ignore this
            debug("Could not close the connection due to error \"".concat(e.message, "\" ").concat(e.stack));
          });
        }
      });
    }
  }, {
    key: "collection",
    value: function collection(_collection) {
      return new Collection(this, _collection);
    }
  }]);

  return Database;
}(EventEmitter);

function parseUrl(connectionString, options) {
  return new Promise(function (resolve, reject) {
    urlParser(connectionString, options, function (err, parsedUrl) {
      return err ? reject(err) : resolve(parsedUrl);
    });
  });
}