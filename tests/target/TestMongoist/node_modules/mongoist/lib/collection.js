"use strict";

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var mongodb = require('mongodb');

var Cursor = require('./cursor');

var Bulk = require('./bulk');

var oid = mongodb.ObjectID.createPk; // TODO: Make this configurable by users

var writeOpts = {
  writeConcern: {
    w: 1
  },
  ordered: true
};

module.exports =
/*#__PURE__*/
function () {
  function Collection(db, name) {
    _classCallCheck(this, Collection);

    this.db = db;
    this.name = name;
  }

  _createClass(Collection, [{
    key: "connect",
    value: function connect() {
      var _this = this;

      return this.db.connect().then(function (connection) {
        return connection.collection(_this.name);
      });
    }
  }, {
    key: "find",
    value: function find(query, projection, opts) {
      var _this2 = this;

      return this.connect().then(function (collection) {
        if (_this2.db.features.useLegacyProjections) {
          return collection.find(query, projection, opts).toArray();
        }

        var options = Object.assign({
          projection: projection
        }, opts);
        return collection.find(query, options).toArray();
      });
    }
  }, {
    key: "findAsCursor",
    value: function findAsCursor(query, projection, opts) {
      var _this3 = this;

      return new Cursor(function () {
        return _this3.connect().then(function (collection) {
          if (_this3.db.features.useLegacyProjections) {
            return collection.find(query, projection, opts);
          }

          var options = Object.assign({
            projection: projection
          }, opts);
          return collection.find(query, options);
        });
      });
    }
  }, {
    key: "findOne",
    value: function findOne(query, projection, opts) {
      return this.findAsCursor(query, projection, opts).next();
    }
  }, {
    key: "findAndModify",
    value: function findAndModify(opts) {
      return this.runCommand('findAndModify', opts).then(function (result) {
        return result.value;
      });
    }
  }, {
    key: "count",
    value: function count(query) {
      return this.findAsCursor(query).count();
    }
  }, {
    key: "distinct",
    value: function distinct(field, query) {
      return this.runCommand('distinct', {
        key: field,
        query: query
      }).then(function (result) {
        return result.values;
      });
    }
  }, {
    key: "insert",
    value: function insert(docOrDocs, opts) {
      return Array.isArray(docOrDocs) ? this.insertMany(docOrDocs, opts) : this.insertOne(docOrDocs, opts);
    }
  }, {
    key: "insertOne",
    value: function insertOne(doc, opts) {
      if (!doc._id) doc._id = oid();
      return this.connect().then(function (connection) {
        return connection.insertOne(doc, Object.assign({}, writeOpts, opts));
      }).then(function () {
        return doc;
      });
    }
  }, {
    key: "insertMany",
    value: function insertMany(docs, opts) {
      for (var i = 0; i < docs.length; i++) {
        if (!docs[i]._id) docs[i]._id = oid();
      }

      return this.connect().then(function (connection) {
        return connection.insertMany(docs, Object.assign({}, writeOpts, opts));
      }).then(function () {
        return docs;
      });
    }
  }, {
    key: "update",
    value: function update(query, _update, opts) {
      opts = opts || {};
      var isMulti = opts.multi;
      return this.connect().then(function (connection) {
        var updateFn = isMulti ? connection.updateMany.bind(connection) : connection.updateOne.bind(connection);
        return updateFn(query, _update, Object.assign({}, writeOpts, opts));
      }).then(function (result) {
        return result.result;
      });
    }
  }, {
    key: "replaceOne",
    value: function replaceOne(filter, replacement, opts) {
      opts = opts || {};
      return this.connect().then(function (connection) {
        return connection.replaceOne(filter, replacement, Object.assign({}, writeOpts, opts));
      });
    }
  }, {
    key: "save",
    value: function save(doc, opts) {
      opts = opts || {};

      if (doc._id) {
        return this.update({
          _id: doc._id
        }, {
          $set: doc
        }, Object.assign({
          upsert: true
        }, opts)).then(function () {
          return doc;
        });
      } else {
        return this.insert(doc, opts);
      }
    }
  }, {
    key: "remove",
    value: function remove(query, opts) {
      opts = opts || {
        justOne: false
      };

      if (typeof opts == 'boolean') {
        opts = {
          justOne: opts
        };
      }

      var deleteOperation = opts.justOne ? 'deleteOne' : 'deleteMany';
      return this.connect().then(function (connection) {
        return connection[deleteOperation](query, Object.assign({}, writeOpts, opts));
      }).then(function (commandResult) {
        commandResult.result.deletedCount = commandResult.deletedCount;
        return commandResult.result;
      });
    }
  }, {
    key: "rename",
    value: function rename(name, opts) {
      return this.connect().then(function (connection) {
        return connection.rename(name, opts);
      });
    }
  }, {
    key: "drop",
    value: function drop() {
      return this.runCommand('drop');
    }
  }, {
    key: "stats",
    value: function stats() {
      return this.runCommand('collStats');
    }
  }, {
    key: "mapReduce",
    value: function mapReduce(map, reduce, opts) {
      opts = opts || {};
      return this.connect().then(function (connection) {
        return connection.mapReduce(map, reduce, opts);
      });
    }
  }, {
    key: "runCommand",
    value: function runCommand(cmd, opts) {
      opts = opts || {};
      var cmdObject = Object.assign(_defineProperty({}, cmd, this.name), opts);
      return this.db.connect().then(function (connection) {
        return connection.command(cmdObject);
      });
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.name;
    }
  }, {
    key: "dropIndexes",
    value: function dropIndexes() {
      return this.runCommand('dropIndexes', {
        index: '*'
      });
    }
  }, {
    key: "dropIndex",
    value: function dropIndex(index) {
      return this.runCommand('dropIndexes', {
        index: index
      });
    }
  }, {
    key: "createIndex",
    value: function createIndex(index, opts) {
      opts = opts || {};
      return this.connect().then(function (connection) {
        return connection.createIndex(index, opts);
      });
    }
  }, {
    key: "ensureIndex",
    value: function ensureIndex(index, opts) {
      return this.createIndex(index, opts);
    }
  }, {
    key: "getIndexes",
    value: function getIndexes() {
      return this.connect().then(function (connection) {
        return connection.indexes();
      });
    }
  }, {
    key: "reIndex",
    value: function reIndex() {
      return this.runCommand('reIndex');
    }
  }, {
    key: "isCapped",
    value: function isCapped() {
      return this.connect().then(function (connection) {
        return connection.isCapped();
      }).then(function (isCapped) {
        return !!isCapped;
      });
    }
  }, {
    key: "group",
    value: function group(doc) {
      return this.connect().then(function (connection) {
        return connection.group(doc.key, doc.cond, doc.initial, doc.reduce, doc.finalize, false);
      });
    }
  }, {
    key: "aggregate",
    value: function aggregate(pipeline, opts) {
      return this.aggregateAsCursor(pipeline, opts).toArray();
    }
  }, {
    key: "aggregateAsCursor",
    value: function aggregateAsCursor(pipeline, opts) {
      var _this4 = this;

      opts = opts || {};
      return new Cursor(function () {
        return _this4.connect().then(function (collection) {
          return collection.aggregate(pipeline, opts);
        });
      });
    }
  }, {
    key: "initializeOrderedBulkOp",
    value: function initializeOrderedBulkOp(opts) {
      var _this5 = this;

      return new Bulk(this.name, true, function () {
        return _this5.db.connect();
      }, opts);
    }
  }, {
    key: "initializeUnorderedBulkOp",
    value: function initializeUnorderedBulkOp(opts) {
      var _this6 = this;

      return new Bulk(this.name, false, function () {
        return _this6.db.connect();
      }, opts);
    }
  }]);

  return Collection;
}();