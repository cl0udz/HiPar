"use strict";

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

var _require = require('chai'),
    expect = _require.expect;

var dropMongoDbCollections = require('drop-mongodb-collections');

var mongoist = require('../');

var mongojs = require('mongojs');

var connectionString = 'mongodb://localhost:27017/test';
describe('database', function () {
  this.timeout(10000);
  var db;
  beforeEach(dropMongoDbCollections(connectionString));
  beforeEach(function _callee() {
    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            db = mongoist(connectionString);
            _context.next = 3;
            return regeneratorRuntime.awrap(db.a.insert([{
              name: 'Squirtle',
              type: 'water',
              level: 10
            }, {
              name: 'Starmie',
              type: 'water',
              level: 8
            }, {
              name: 'Charmander',
              type: 'fire',
              level: 8
            }, {
              name: 'Lapras',
              type: 'water',
              level: 12
            }]));

          case 3:
          case "end":
            return _context.stop();
        }
      }
    });
  });
  afterEach(function () {
    return db.close();
  });
  it('should return a collection if accessing a property that is a valid collection name', function _callee2() {
    return regeneratorRuntime.async(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = expect;
            _context2.next = 3;
            return regeneratorRuntime.awrap(db.xyz.count());

          case 3:
            _context2.t1 = _context2.sent;
            (0, _context2.t0)(_context2.t1).to.equal(0);
            _context2.t2 = expect;
            _context2.next = 8;
            return regeneratorRuntime.awrap(db.features.count());

          case 8:
            _context2.t3 = _context2.sent;
            (0, _context2.t2)(_context2.t3).to.equal(0);
            _context2.t4 = expect;
            _context2.next = 13;
            return regeneratorRuntime.awrap(db.options.count());

          case 13:
            _context2.t5 = _context2.sent;
            (0, _context2.t4)(_context2.t5).to.equal(0);
            _context2.t6 = expect;
            _context2.next = 18;
            return regeneratorRuntime.awrap(db.client.count());

          case 18:
            _context2.t7 = _context2.sent;
            (0, _context2.t6)(_context2.t7).to.equal(0);
            _context2.t8 = expect;
            _context2.next = 23;
            return regeneratorRuntime.awrap(db.connection.count());

          case 23:
            _context2.t9 = _context2.sent;
            (0, _context2.t8)(_context2.t9).to.equal(0);
            _context2.t10 = expect;
            _context2.next = 28;
            return regeneratorRuntime.awrap(db.domain.count());

          case 28:
            _context2.t11 = _context2.sent;
            (0, _context2.t10)(_context2.t11).to.equal(0);

          case 30:
          case "end":
            return _context2.stop();
        }
      }
    });
  });
  it('should accept connection strings without mongodb:// protocol specified', function _callee3() {
    var dbShort, docs;
    return regeneratorRuntime.async(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            dbShort = mongoist('localhost:27017/test');
            _context3.next = 3;
            return regeneratorRuntime.awrap(dbShort.a.find());

          case 3:
            docs = _context3.sent;
            expect(docs).to.have.length(4);
            _context3.next = 7;
            return regeneratorRuntime.awrap(dbShort.close());

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    });
  });
  it('should accept connection strings with mongodb+srv:// protocol specified', function _callee4() {
    var dbFromSrvProtocol;
    return regeneratorRuntime.async(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            dbFromSrvProtocol = mongoist('mongodb+srv://server.example.com/'); // Work around access db through a collection

            expect(dbFromSrvProtocol.x.db.connectionString).to.equal('mongodb+srv://server.example.com/');

          case 2:
          case "end":
            return _context4.stop();
        }
      }
    });
  });
  it('should accept connection strings without host and mongodb:// protocol specified', function _callee5() {
    var dbShort, docs;
    return regeneratorRuntime.async(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            dbShort = mongoist('test');
            _context5.next = 3;
            return regeneratorRuntime.awrap(dbShort.a.find());

          case 3:
            docs = _context5.sent;
            expect(docs).to.have.length(4);
            _context5.next = 7;
            return regeneratorRuntime.awrap(dbShort.close());

          case 7:
          case "end":
            return _context5.stop();
        }
      }
    });
  });
  it('should create a collection', function _callee6() {
    var collection;
    return regeneratorRuntime.async(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return regeneratorRuntime.awrap(db.createCollection('test123'));

          case 2:
            collection = _context6.sent;
            expect(collection).to.exist;
            _context6.prev = 4;
            _context6.next = 7;
            return regeneratorRuntime.awrap(db.createCollection('test123'));

          case 7:
            _context6.next = 12;
            break;

          case 9:
            _context6.prev = 9;
            _context6.t0 = _context6["catch"](4);
            return _context6.abrupt("return");

          case 12:
            throw new Error('Collection with duplicate collection name created a second time and an error was expected!');

          case 13:
          case "end":
            return _context6.stop();
        }
      }
    }, null, null, [[4, 9]]);
  });
  it('should list collections', function _callee7() {
    var collections;
    return regeneratorRuntime.async(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return regeneratorRuntime.awrap(db.createCollection('test1'));

          case 2:
            _context7.next = 4;
            return regeneratorRuntime.awrap(db.createCollection('test2'));

          case 4:
            _context7.next = 6;
            return regeneratorRuntime.awrap(db.listCollections());

          case 6:
            collections = _context7.sent;
            expect(collections).to.have.length(3);

          case 8:
          case "end":
            return _context7.stop();
        }
      }
    });
  });
  it('should get collection names', function _callee8() {
    var collectionNames;
    return regeneratorRuntime.async(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return regeneratorRuntime.awrap(db.createCollection('test1'));

          case 2:
            _context8.next = 4;
            return regeneratorRuntime.awrap(db.createCollection('test2'));

          case 4:
            _context8.next = 6;
            return regeneratorRuntime.awrap(db.getCollectionNames());

          case 6:
            collectionNames = _context8.sent;
            expect(collectionNames).to.have.length(3);
            expect(collectionNames).to.include('test1');
            expect(collectionNames).to.include('test2');
            expect(collectionNames).to.include('a');

          case 11:
          case "end":
            return _context8.stop();
        }
      }
    });
  });
  it('should get db stats', function _callee9() {
    var stats;
    return regeneratorRuntime.async(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return regeneratorRuntime.awrap(db.stats());

          case 2:
            stats = _context9.sent;
            expect(stats.ok).to.equal(1);
            expect(stats.collections).to.exist;
            expect(stats.indexes).to.exist;

          case 6:
          case "end":
            return _context9.stop();
        }
      }
    });
  });
  it.skip('should emit an error event if a connection could not be established', function _callee10() {
    var cannotConnect, errorEvent;
    return regeneratorRuntime.async(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            cannotConnect = mongoist('mongodb://127.0.0.1:65535/testdb');
            errorEvent = null;
            cannotConnect.on('error', function (error) {
              errorEvent = error;
            });
            _context10.prev = 3;
            _context10.next = 6;
            return regeneratorRuntime.awrap(cannotConnect.xyz.find());

          case 6:
            _context10.next = 13;
            break;

          case 8:
            _context10.prev = 8;
            _context10.t0 = _context10["catch"](3);
            expect(errorEvent).to.exist;
            cannotConnect.close();
            return _context10.abrupt("return");

          case 13:
            throw new Error('Expected error to be thrown');

          case 14:
          case "end":
            return _context10.stop();
        }
      }
    }, null, null, [[3, 8]]);
  });
  it('should emit an event if database connection opened', function _callee11() {
    var db, events;
    return regeneratorRuntime.async(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            db = mongoist(connectionString);
            events = {};
            db.on('connect', function () {
              return events.connect = true;
            });
            _context11.next = 5;
            return regeneratorRuntime.awrap(db.xyz.find());

          case 5:
            expect(events).to.deep.equal({
              connect: true
            });
            _context11.next = 8;
            return regeneratorRuntime.awrap(db.close());

          case 8:
          case "end":
            return _context11.stop();
        }
      }
    });
  });
  describe('users', function () {
    beforeEach(function _callee12() {
      return regeneratorRuntime.async(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return regeneratorRuntime.awrap(db.dropAllUsers());

            case 2:
              return _context12.abrupt("return", _context12.sent);

            case 3:
            case "end":
              return _context12.stop();
          }
        }
      });
    });
    it('should create a user', function _callee13() {
      var user;
      return regeneratorRuntime.async(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return regeneratorRuntime.awrap(db.createUser({
                user: 'mongoist',
                pwd: 'topsecret',
                customData: {
                  department: 'area51'
                },
                roles: ['readWrite']
              }));

            case 2:
              user = _context13.sent;
              expect(user).to.exist;

            case 4:
            case "end":
              return _context13.stop();
          }
        }
      });
    });
    it('should not create duplicate users', function _callee14() {
      var user;
      return regeneratorRuntime.async(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return regeneratorRuntime.awrap(db.createUser({
                user: 'mongoist',
                pwd: 'topsecret',
                customData: {
                  department: 'area51'
                },
                roles: ['readWrite']
              }));

            case 2:
              user = _context14.sent;
              expect(user).to.exist;
              _context14.prev = 4;
              _context14.next = 7;
              return regeneratorRuntime.awrap(db.createUser({
                user: 'mongoist',
                pwd: 'topsecret',
                customData: {
                  department: 'area51'
                },
                roles: ['readWrite']
              }));

            case 7:
              _context14.next = 13;
              break;

            case 9:
              _context14.prev = 9;
              _context14.t0 = _context14["catch"](4);
              expect(_context14.t0.code).to.equal(11000);
              return _context14.abrupt("return");

            case 13:
              throw new Error('Duplicate users should not be created');

            case 14:
            case "end":
              return _context14.stop();
          }
        }
      }, null, null, [[4, 9]]);
    });
    it('should drop a user', function _callee15() {
      var user, result;
      return regeneratorRuntime.async(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return regeneratorRuntime.awrap(db.createUser({
                user: 'mongoist',
                pwd: 'topsecret',
                customData: {
                  department: 'area51'
                },
                roles: ['readWrite']
              }));

            case 2:
              user = _context15.sent;
              expect(user).to.exist;
              _context15.next = 6;
              return regeneratorRuntime.awrap(db.dropUser('mongoist'));

            case 6:
              result = _context15.sent;
              expect(result.ok).to.exist;

            case 8:
            case "end":
              return _context15.stop();
          }
        }
      });
    });
  });
  it('should get a non existing last error', function _callee16() {
    var lastError;
    return regeneratorRuntime.async(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            _context16.next = 2;
            return regeneratorRuntime.awrap(db.getLastError());

          case 2:
            lastError = _context16.sent;
            expect(lastError).to.not.exist;

          case 4:
          case "end":
            return _context16.stop();
        }
      }
    });
  });
  it('should get the last error obj with non existing error field', function _callee17() {
    var lastError;
    return regeneratorRuntime.async(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            _context17.next = 2;
            return regeneratorRuntime.awrap(db.getLastErrorObj());

          case 2:
            lastError = _context17.sent;
            expect(lastError).to.exist;
            expect(lastError.err).to.not.exist;

          case 5:
          case "end":
            return _context17.stop();
        }
      }
    });
  });
  it('should run a named command', function _callee18() {
    var stats;
    return regeneratorRuntime.async(function _callee18$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            _context18.next = 2;
            return regeneratorRuntime.awrap(db.runCommand('dbStats'));

          case 2:
            stats = _context18.sent;
            expect(stats.ok).to.equal(1);

          case 4:
          case "end":
            return _context18.stop();
        }
      }
    });
  });
  it('should allow passing in a Promise<string>', function _callee19() {
    var db, docs;
    return regeneratorRuntime.async(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            db = mongoist(Promise.resolve(connectionString));
            _context19.next = 3;
            return regeneratorRuntime.awrap(db.a.find({}));

          case 3:
            docs = _context19.sent;
            expect(docs).to.have.length(4);
            _context19.next = 7;
            return regeneratorRuntime.awrap(db.close());

          case 7:
          case "end":
            return _context19.stop();
        }
      }
    });
  });
  it('should normalize a Promise<string> connectionString', function _callee20() {
    var dbShort, docs;
    return regeneratorRuntime.async(function _callee20$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            dbShort = mongoist(Promise.resolve('localhost:27017/test'));
            _context20.next = 3;
            return regeneratorRuntime.awrap(dbShort.a.find());

          case 3:
            docs = _context20.sent;
            expect(docs).to.have.length(4);
            _context20.next = 7;
            return regeneratorRuntime.awrap(dbShort.close());

          case 7:
          case "end":
            return _context20.stop();
        }
      }
    });
  });
  it('should allow passing in a mongojs connection', function _callee21() {
    var mongojsDb, db, docs;
    return regeneratorRuntime.async(function _callee21$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            mongojsDb = mongojs(connectionString);
            db = mongoist(mongojsDb);
            _context21.next = 4;
            return regeneratorRuntime.awrap(db.a.find({}));

          case 4:
            docs = _context21.sent;
            expect(docs).to.have.length(4);
            _context21.next = 8;
            return regeneratorRuntime.awrap(mongojsDb.close());

          case 8:
            _context21.next = 10;
            return regeneratorRuntime.awrap(db.close());

          case 10:
          case "end":
            return _context21.stop();
        }
      }
    });
  });
  it('should allow passing in a Promise that resolves to a mongojs connection', function _callee22() {
    var mongojsDb, db, docs;
    return regeneratorRuntime.async(function _callee22$(_context22) {
      while (1) {
        switch (_context22.prev = _context22.next) {
          case 0:
            mongojsDb = mongojs(connectionString);
            db = mongoist(Promise.resolve(mongojsDb));
            _context22.next = 4;
            return regeneratorRuntime.awrap(db.a.find({}));

          case 4:
            docs = _context22.sent;
            expect(docs).to.have.length(4);
            _context22.next = 8;
            return regeneratorRuntime.awrap(mongojsDb.close());

          case 8:
            _context22.next = 10;
            return regeneratorRuntime.awrap(db.close());

          case 10:
          case "end":
            return _context22.stop();
        }
      }
    });
  });
  it('should pass projections to mongojs connections using mongodb 2.x driver', function _callee23() {
    var mongojsDb, db, docs, cursor, doc;
    return regeneratorRuntime.async(function _callee23$(_context23) {
      while (1) {
        switch (_context23.prev = _context23.next) {
          case 0:
            mongojsDb = mongojs(connectionString);
            db = mongoist(mongojsDb);
            _context23.next = 4;
            return regeneratorRuntime.awrap(db.a.find({}, {
              name: true,
              _id: false
            }));

          case 4:
            docs = _context23.sent;
            expect(docs).to.have.length(4);
            expect(docs).to.deep.contain({
              name: 'Squirtle'
            });
            expect(docs).to.deep.contain({
              name: 'Starmie'
            });
            expect(docs).to.deep.contain({
              name: 'Charmander'
            });
            expect(docs).to.deep.contain({
              name: 'Lapras'
            });
            _context23.next = 12;
            return regeneratorRuntime.awrap(db.a.findAsCursor({}, {
              name: true,
              _id: false
            }));

          case 12:
            cursor = _context23.sent;
            _context23.next = 15;
            return regeneratorRuntime.awrap(cursor.next());

          case 15:
            doc = _context23.sent;
            expect(doc).to.have.keys('name');
            _context23.next = 19;
            return regeneratorRuntime.awrap(mongojsDb.close());

          case 19:
            _context23.next = 21;
            return regeneratorRuntime.awrap(db.close());

          case 21:
          case "end":
            return _context23.stop();
        }
      }
    });
  });
  it('should allow passing in a mongoist connection', function _callee24() {
    var mongoistDb, db, docs;
    return regeneratorRuntime.async(function _callee24$(_context24) {
      while (1) {
        switch (_context24.prev = _context24.next) {
          case 0:
            mongoistDb = mongoist(connectionString);
            db = mongoist(mongoistDb);
            _context24.next = 4;
            return regeneratorRuntime.awrap(db.a.find({}));

          case 4:
            docs = _context24.sent;
            expect(docs).to.have.length(4);
            _context24.next = 8;
            return regeneratorRuntime.awrap(mongoistDb.close());

          case 8:
            _context24.next = 10;
            return regeneratorRuntime.awrap(db.close());

          case 10:
          case "end":
            return _context24.stop();
        }
      }
    });
  });
  it('should pass projections to mongoist connections passing in a mongoist connection', function _callee25() {
    var mongoistDb, db, docs, cursor, doc;
    return regeneratorRuntime.async(function _callee25$(_context25) {
      while (1) {
        switch (_context25.prev = _context25.next) {
          case 0:
            mongoistDb = mongoist(connectionString);
            db = mongoist(mongoistDb);
            _context25.next = 4;
            return regeneratorRuntime.awrap(db.a.find({}, {
              name: true,
              _id: false
            }));

          case 4:
            docs = _context25.sent;
            expect(docs).to.have.length(4);
            expect(docs).to.deep.contain({
              name: 'Squirtle'
            });
            expect(docs).to.deep.contain({
              name: 'Starmie'
            });
            expect(docs).to.deep.contain({
              name: 'Charmander'
            });
            expect(docs).to.deep.contain({
              name: 'Lapras'
            });
            _context25.next = 12;
            return regeneratorRuntime.awrap(db.a.findAsCursor({}, {
              name: true,
              _id: false
            }));

          case 12:
            cursor = _context25.sent;
            _context25.next = 15;
            return regeneratorRuntime.awrap(cursor.next());

          case 15:
            doc = _context25.sent;
            expect(doc).to.have.keys('name');
            _context25.next = 19;
            return regeneratorRuntime.awrap(mongoistDb.close());

          case 19:
            _context25.next = 21;
            return regeneratorRuntime.awrap(db.close());

          case 21:
          case "end":
            return _context25.stop();
        }
      }
    });
  });
  it('should drop a database', function _callee26() {
    var dbConnectionString, db, docs, db2, docs2;
    return regeneratorRuntime.async(function _callee26$(_context26) {
      while (1) {
        switch (_context26.prev = _context26.next) {
          case 0:
            dbConnectionString = 'mongodb://localhost:27017/test2';
            db = mongoist(dbConnectionString);
            _context26.next = 4;
            return regeneratorRuntime.awrap(db.b.insert({
              name: 'Squirtle',
              type: 'water',
              level: 10
            }));

          case 4:
            _context26.next = 6;
            return regeneratorRuntime.awrap(db.b.find({}));

          case 6:
            docs = _context26.sent;
            expect(docs).to.have.length(1);
            _context26.next = 10;
            return regeneratorRuntime.awrap(db.dropDatabase());

          case 10:
            db2 = mongoist(dbConnectionString);
            _context26.next = 13;
            return regeneratorRuntime.awrap(db2.b.find({}));

          case 13:
            docs2 = _context26.sent;
            expect(docs2).to.have.length(0);
            _context26.next = 17;
            return regeneratorRuntime.awrap(db.close());

          case 17:
            _context26.next = 19;
            return regeneratorRuntime.awrap(db2.close());

          case 19:
          case "end":
            return _context26.stop();
        }
      }
    });
  });
  it('should execute admin commands', function _callee27() {
    var dbStats;
    return regeneratorRuntime.async(function _callee27$(_context27) {
      while (1) {
        switch (_context27.prev = _context27.next) {
          case 0:
            _context27.next = 2;
            return regeneratorRuntime.awrap(db.adminCommand({
              dbStats: 1
            }));

          case 2:
            dbStats = _context27.sent;
            expect(dbStats.db).to.equal('admin');

          case 4:
          case "end":
            return _context27.stop();
        }
      }
    });
  });
});