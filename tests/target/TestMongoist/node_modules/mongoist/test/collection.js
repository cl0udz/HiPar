"use strict";

require("core-js/modules/es.array.sort");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

var _require = require('chai'),
    expect = _require.expect;

var dropMongoDbCollections = require('drop-mongodb-collections');

var mongoist = require('../');

var connectionString = 'mongodb://localhost:27017/test';
describe('collection', function () {
  this.timeout(10000);
  var db;
  beforeEach(dropMongoDbCollections(connectionString));
  beforeEach(function _callee() {
    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            db = mongoist(connectionString);
            _context.next = 3;
            return regeneratorRuntime.awrap(db.a.insert([{
              name: 'Squirtle',
              type: 'water',
              level: 10
            }, {
              name: 'Starmie',
              type: 'water',
              level: 8
            }, {
              name: 'Charmander',
              type: 'fire',
              level: 8
            }, {
              name: 'Lapras',
              type: 'water',
              level: 12
            }]));

          case 3:
          case "end":
            return _context.stop();
        }
      }
    });
  });
  afterEach(function () {
    return db.close();
  });
  it('should insert a single document', function _callee2() {
    var doc;
    return regeneratorRuntime.async(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return regeneratorRuntime.awrap(db.b.insert({
              foo: 'bar'
            }));

          case 2:
            doc = _context2.sent;
            expect(doc.foo).to.equal('bar');
            expect(doc._id).to.exist;

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    });
  });
  it('should insert document arrays', function _callee3() {
    var docs;
    return regeneratorRuntime.async(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return regeneratorRuntime.awrap(db.b.insert([{
              foo: 'bar'
            }, {
              foo: 'bar'
            }]));

          case 2:
            docs = _context3.sent;
            expect(docs).to.have.length(2);
            expect(docs[0].foo).to.equal('bar');
            expect(docs[1].foo).to.equal('bar');

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    });
  });
  it('should insert document with options', function _callee4() {
    var docs;
    return regeneratorRuntime.async(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return regeneratorRuntime.awrap(db.b.insert([{
              foo: 'bar'
            }, {
              foo: 'bar'
            }], {
              ordered: true
            }));

          case 2:
            docs = _context4.sent;
            expect(docs).to.have.length(2);
            expect(docs[0].foo).to.equal('bar');
            expect(docs[1].foo).to.equal('bar');

          case 6:
          case "end":
            return _context4.stop();
        }
      }
    });
  });
  it('should find documents', function _callee5() {
    var docs;
    return regeneratorRuntime.async(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return regeneratorRuntime.awrap(db.a.find({}));

          case 2:
            docs = _context5.sent;
            expect(docs).to.have.length(4);
            expect(docs[0].name).to.equal('Squirtle');
            expect(docs[0].type).to.equal('water');
            expect(docs[1].name).to.equal('Starmie');
            expect(docs[1].type).to.equal('water');
            expect(docs[2].name).to.equal('Charmander');
            expect(docs[2].type).to.equal('fire');
            expect(docs[3].name).to.equal('Lapras');
            expect(docs[3].type).to.equal('water');

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    });
  });
  it('should find documents with a projection', function _callee6() {
    var docs;
    return regeneratorRuntime.async(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return regeneratorRuntime.awrap(db.a.find({}, {
              name: 1
            }));

          case 2:
            docs = _context6.sent;
            expect(docs).to.have.length(4);
            expect(docs[0].name).to.equal('Squirtle');
            expect(docs[0].type).to.not.exist;

          case 6:
          case "end":
            return _context6.stop();
        }
      }
    });
  });
  it('should find using an awaitable cursor', function _callee7() {
    var docs;
    return regeneratorRuntime.async(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return regeneratorRuntime.awrap(db.a.findAsCursor({}).sort({
              name: 1
            }).limit(1).toArray());

          case 2:
            docs = _context7.sent;
            expect(docs).to.have.length(1);
            expect(docs[0].name).to.equal('Charmander');
            expect(docs[0].type).to.equal('fire');

          case 6:
          case "end":
            return _context7.stop();
        }
      }
    });
  });
  it('should find one document', function _callee8() {
    var squirtle;
    return regeneratorRuntime.async(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return regeneratorRuntime.awrap(db.a.findOne({
              name: 'Squirtle'
            }));

          case 2:
            squirtle = _context8.sent;
            expect(squirtle.name).to.equal('Squirtle');
            expect(squirtle.type).to.equal('water');

          case 5:
          case "end":
            return _context8.stop();
        }
      }
    });
  });
  it('should find one document with projection', function _callee9() {
    var squirtle;
    return regeneratorRuntime.async(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return regeneratorRuntime.awrap(db.a.findOne({
              name: 'Squirtle'
            }, {
              type: 1
            }));

          case 2:
            squirtle = _context9.sent;
            expect(squirtle.name).to.not.exist;
            expect(squirtle.type).to.equal('water');
            expect(squirtle._id).to.exist;

          case 6:
          case "end":
            return _context9.stop();
        }
      }
    });
  });
  it('should findAndModify a document and return the new document', function _callee10() {
    var result;
    return regeneratorRuntime.async(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return regeneratorRuntime.awrap(db.a.findAndModify({
              query: {
                name: 'Squirtle'
              },
              "new": true,
              update: {
                $set: {
                  name: 'Squirtle Brawl'
                }
              }
            }));

          case 2:
            result = _context10.sent;
            expect(result.name).to.equal('Squirtle Brawl');

          case 4:
          case "end":
            return _context10.stop();
        }
      }
    });
  });
  it('should findAndModify a document and return old value', function _callee11() {
    var result;
    return regeneratorRuntime.async(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return regeneratorRuntime.awrap(db.a.findAndModify({
              query: {
                name: 'Squirtle'
              },
              update: {
                $set: {
                  name: 'Squirtle Brawl'
                }
              }
            }));

          case 2:
            result = _context11.sent;
            expect(result.name).to.equal('Squirtle');

          case 4:
          case "end":
            return _context11.stop();
        }
      }
    });
  });
  it('should count queried documents', function _callee12() {
    var count;
    return regeneratorRuntime.async(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return regeneratorRuntime.awrap(db.a.count({
              type: 'water'
            }));

          case 2:
            count = _context12.sent;
            expect(count).to.equal(3);

          case 4:
          case "end":
            return _context12.stop();
        }
      }
    });
  });
  it('should query distinct documents', function _callee13() {
    var docs;
    return regeneratorRuntime.async(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            _context13.next = 2;
            return regeneratorRuntime.awrap(db.a.distinct('name', {
              type: 'water'
            }));

          case 2:
            docs = _context13.sent;
            expect(docs.length).to.equal(3);
            expect(docs).to.deep.equal(['Squirtle', 'Starmie', 'Lapras']);

          case 5:
          case "end":
            return _context13.stop();
        }
      }
    });
  });
  it('should update a document', function _callee14() {
    var lastErrorObject, updatedDocsCount, idleDocsCount;
    return regeneratorRuntime.async(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            _context14.next = 2;
            return regeneratorRuntime.awrap(db.a.update({
              type: 'water'
            }, {
              $set: {
                type: 'aqua'
              }
            }));

          case 2:
            lastErrorObject = _context14.sent;
            expect(lastErrorObject.n).to.equal(1);
            _context14.next = 6;
            return regeneratorRuntime.awrap(db.a.count({
              type: 'aqua'
            }));

          case 6:
            updatedDocsCount = _context14.sent;
            expect(updatedDocsCount).equal(1);
            _context14.next = 10;
            return regeneratorRuntime.awrap(db.a.count({
              type: 'water'
            }));

          case 10:
            idleDocsCount = _context14.sent;
            expect(idleDocsCount).equal(2);

          case 12:
          case "end":
            return _context14.stop();
        }
      }
    });
  });
  it('should update multiple documents', function _callee15() {
    var lastErrorObject, updatedDocsCount, idleDocsCount;
    return regeneratorRuntime.async(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            _context15.next = 2;
            return regeneratorRuntime.awrap(db.a.update({
              type: 'water'
            }, {
              $set: {
                type: 'aqua'
              }
            }, {
              multi: true
            }));

          case 2:
            lastErrorObject = _context15.sent;
            expect(lastErrorObject.n).to.equal(3);
            _context15.next = 6;
            return regeneratorRuntime.awrap(db.a.count({
              type: 'aqua'
            }));

          case 6:
            updatedDocsCount = _context15.sent;
            expect(updatedDocsCount).equal(3);
            _context15.next = 10;
            return regeneratorRuntime.awrap(db.a.count({
              type: 'water'
            }));

          case 10:
            idleDocsCount = _context15.sent;
            expect(idleDocsCount).equal(0);

          case 12:
          case "end":
            return _context15.stop();
        }
      }
    });
  });
  it('should replace a document', function _callee16() {
    var bulbasaurLevel9, bulbasaurLevel10, upsertedReplace, replaced;
    return regeneratorRuntime.async(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            bulbasaurLevel9 = {
              name: 'Bulbasaur',
              type: 'grass',
              level: 9
            };
            bulbasaurLevel10 = Object.assign({}, bulbasaurLevel9, {
              level: 10
            });
            _context16.next = 4;
            return regeneratorRuntime.awrap(db.a.replaceOne(bulbasaurLevel9, bulbasaurLevel10, {
              upsert: true
            }));

          case 4:
            upsertedReplace = _context16.sent;
            expect(upsertedReplace.matchedCount).to.equal(0);
            expect(upsertedReplace.modifiedCount).to.equal(0);
            expect(upsertedReplace.upsertedId).to.exist;
            _context16.next = 10;
            return regeneratorRuntime.awrap(db.a.replaceOne(bulbasaurLevel10, bulbasaurLevel10));

          case 10:
            replaced = _context16.sent;
            expect(replaced.matchedCount).equal(1);
            expect(replaced.modifiedCount).equal(1);
            expect(replaced.upsertedId).to.not.exist;

          case 14:
          case "end":
            return _context16.stop();
        }
      }
    });
  });
  it('should save a document', function _callee17() {
    var doc, updatedDoc;
    return regeneratorRuntime.async(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            _context17.next = 2;
            return regeneratorRuntime.awrap(db.a.save({
              name: 'Charizard',
              type: 'fire'
            }));

          case 2:
            doc = _context17.sent;
            expect(doc._id).to.exist;
            expect(doc.name).to.equal('Charizard');
            doc.type = 'flying';
            _context17.next = 8;
            return regeneratorRuntime.awrap(db.a.save(doc));

          case 8:
            updatedDoc = _context17.sent;
            expect(updatedDoc._id).to.exist;
            expect(updatedDoc.type).to.equal('flying');

          case 11:
          case "end":
            return _context17.stop();
        }
      }
    });
  });
  it('should remove one', function _callee18() {
    var lastErrorObject, remainingDocs;
    return regeneratorRuntime.async(function _callee18$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            _context18.next = 2;
            return regeneratorRuntime.awrap(db.a.remove({
              type: 'water'
            }, true));

          case 2:
            lastErrorObject = _context18.sent;
            expect(lastErrorObject.n).to.equal(1);
            _context18.next = 6;
            return regeneratorRuntime.awrap(db.a.count({
              type: 'water'
            }));

          case 6:
            remainingDocs = _context18.sent;
            expect(remainingDocs).to.equal(2);

          case 8:
          case "end":
            return _context18.stop();
        }
      }
    });
  });
  it('should remove many', function _callee19() {
    var lastErrorObject, remainingDocs;
    return regeneratorRuntime.async(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            _context19.next = 2;
            return regeneratorRuntime.awrap(db.a.remove({
              type: 'water'
            }));

          case 2:
            lastErrorObject = _context19.sent;
            expect(lastErrorObject.n).to.equal(3);
            _context19.next = 6;
            return regeneratorRuntime.awrap(db.a.count({
              type: 'water'
            }));

          case 6:
            remainingDocs = _context19.sent;
            expect(remainingDocs).to.equal(0);

          case 8:
          case "end":
            return _context19.stop();
        }
      }
    });
  });
  it('should rename a collection', function _callee20() {
    var bDocs;
    return regeneratorRuntime.async(function _callee20$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            _context20.next = 2;
            return regeneratorRuntime.awrap(db.a.rename('b'));

          case 2:
            _context20.next = 4;
            return regeneratorRuntime.awrap(db.b.count({}));

          case 4:
            bDocs = _context20.sent;
            expect(bDocs).to.equal(4);

          case 6:
          case "end":
            return _context20.stop();
        }
      }
    });
  });
  it('should drop a collection', function _callee21() {
    var docs;
    return regeneratorRuntime.async(function _callee21$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            _context21.next = 2;
            return regeneratorRuntime.awrap(db.a.drop());

          case 2:
            _context21.next = 4;
            return regeneratorRuntime.awrap(db.a.count({}));

          case 4:
            docs = _context21.sent;
            expect(docs).to.equal(0);

          case 6:
          case "end":
            return _context21.stop();
        }
      }
    });
  });
  it('should get stats of a collection', function _callee22() {
    var stats;
    return regeneratorRuntime.async(function _callee22$(_context22) {
      while (1) {
        switch (_context22.prev = _context22.next) {
          case 0:
            _context22.next = 2;
            return regeneratorRuntime.awrap(db.a.stats());

          case 2:
            stats = _context22.sent;
            expect(stats).to.exist;
            expect(stats.count).to.equal(4);

          case 5:
          case "end":
            return _context22.stop();
        }
      }
    });
  });
  it('should return a string representation when calling toString', function _callee23() {
    var collectionToString;
    return regeneratorRuntime.async(function _callee23$(_context23) {
      while (1) {
        switch (_context23.prev = _context23.next) {
          case 0:
            _context23.next = 2;
            return regeneratorRuntime.awrap(db.a.toString());

          case 2:
            collectionToString = _context23.sent;
            expect(collectionToString).to.equal('a');

          case 4:
          case "end":
            return _context23.stop();
        }
      }
    });
  });
  it('should run map reduce', function _callee24() {
    var map, reduce, levelSum;
    return regeneratorRuntime.async(function _callee24$(_context24) {
      while (1) {
        switch (_context24.prev = _context24.next) {
          case 0:
            reduce = function _ref2(key, values) {
              return Array.sum(values);
            };

            map = function _ref() {
              /* eslint-disable no-undef */
              emit(this.type, this.level);
              /* eslint-enable no-undef */
            };

            _context24.next = 4;
            return regeneratorRuntime.awrap(db.a.mapReduce(map, reduce, {
              query: {
                type: 'water'
              },
              out: 'levelSum'
            }));

          case 4:
            _context24.next = 6;
            return regeneratorRuntime.awrap(db.levelSum.findOne());

          case 6:
            levelSum = _context24.sent;
            expect(levelSum._id).to.equal('water');
            expect(levelSum.value).to.equal(30);

          case 9:
          case "end":
            return _context24.stop();
        }
      }
    });
  });
  it('should ensure, create list and drop indexes and reIndex for a collection', function _callee25() {
    var indexes, remainingIndexes, indexesAfterCreate, indexesAfterDropOne, indexesAfterReindex;
    return regeneratorRuntime.async(function _callee25$(_context25) {
      while (1) {
        switch (_context25.prev = _context25.next) {
          case 0:
            _context25.next = 2;
            return regeneratorRuntime.awrap(db.a.ensureIndex({
              type: 1
            }));

          case 2:
            _context25.next = 4;
            return regeneratorRuntime.awrap(db.a.getIndexes());

          case 4:
            indexes = _context25.sent;
            expect(indexes).to.have.length(2);
            _context25.next = 8;
            return regeneratorRuntime.awrap(db.a.dropIndexes());

          case 8:
            _context25.next = 10;
            return regeneratorRuntime.awrap(db.a.getIndexes());

          case 10:
            remainingIndexes = _context25.sent;
            expect(remainingIndexes).to.have.length(1);
            _context25.next = 14;
            return regeneratorRuntime.awrap(db.a.createIndex({
              type: 1
            }));

          case 14:
            _context25.next = 16;
            return regeneratorRuntime.awrap(db.a.getIndexes());

          case 16:
            indexesAfterCreate = _context25.sent;
            expect(indexesAfterCreate).to.have.length(2);
            _context25.next = 20;
            return regeneratorRuntime.awrap(db.a.dropIndex({
              type: 1
            }));

          case 20:
            _context25.next = 22;
            return regeneratorRuntime.awrap(db.a.getIndexes());

          case 22:
            indexesAfterDropOne = _context25.sent;
            expect(indexesAfterDropOne).to.have.length(1);
            _context25.next = 26;
            return regeneratorRuntime.awrap(db.a.reIndex());

          case 26:
            _context25.next = 28;
            return regeneratorRuntime.awrap(db.a.getIndexes());

          case 28:
            indexesAfterReindex = _context25.sent;
            expect(indexesAfterReindex).to.have.length(1);

          case 30:
          case "end":
            return _context25.stop();
        }
      }
    });
  });
  it('should isCapped for a collection', function _callee26() {
    var isCapped, isACapped;
    return regeneratorRuntime.async(function _callee26$(_context26) {
      while (1) {
        switch (_context26.prev = _context26.next) {
          case 0:
            _context26.next = 2;
            return regeneratorRuntime.awrap(db.createCollection('mycappedcol', {
              capped: true,
              size: 1024
            }));

          case 2:
            _context26.next = 4;
            return regeneratorRuntime.awrap(db.mycappedcol.isCapped());

          case 4:
            isCapped = _context26.sent;
            expect(isCapped).to.be["true"];
            _context26.next = 8;
            return regeneratorRuntime.awrap(db.a.isCapped());

          case 8:
            isACapped = _context26.sent;
            expect(isACapped).to.be["false"];

          case 10:
          case "end":
            return _context26.stop();
        }
      }
    });
  });
  it('should group documents', function _callee27() {
    var curOnline;
    return regeneratorRuntime.async(function _callee27$(_context27) {
      while (1) {
        switch (_context27.prev = _context27.next) {
          case 0:
            _context27.next = 2;
            return regeneratorRuntime.awrap(db.b.insert([{
              t: 242424,
              online: 1
            }, {
              t: 4244,
              online: 0
            }]));

          case 2:
            _context27.next = 4;
            return regeneratorRuntime.awrap(db.b.group({
              key: {},
              cond: {
                t: {
                  $gte: 86400
                }
              },
              initial: {
                count: 0,
                online: 0
              },
              reduce: function reduce(doc, out) {
                out.count++;
                out.online += doc.online;
              },
              finalize: function finalize(out) {
                out.avgOnline = out.online / out.count;
              }
            }));

          case 4:
            curOnline = _context27.sent;
            expect(curOnline[0].count).to.equal(1);
            expect(curOnline[0].online).to.equal(1);

          case 7:
          case "end":
            return _context27.stop();
        }
      }
    });
  });
  it('should aggregate documents', function _callee28() {
    var types;
    return regeneratorRuntime.async(function _callee28$(_context28) {
      while (1) {
        switch (_context28.prev = _context28.next) {
          case 0:
            _context28.next = 2;
            return regeneratorRuntime.awrap(db.a.aggregate([{
              $group: {
                _id: '$type'
              }
            }, {
              $project: {
                _id: 0,
                foo: '$_id'
              }
            }]));

          case 2:
            types = _context28.sent;
            expect(types.length).to.equal(2);
            expect(types).to.deep.include({
              foo: 'fire'
            });
            expect(types).to.deep.include({
              foo: 'water'
            });

          case 6:
          case "end":
            return _context28.stop();
        }
      }
    });
  });
  it('should not mutate write options', function _callee29() {
    var mockDb;
    return regeneratorRuntime.async(function _callee29$(_context31) {
      while (1) {
        switch (_context31.prev = _context31.next) {
          case 0:
            mockDb = mongoist(connectionString);
            mockDb.connection = {
              collection: function collection() {
                return regeneratorRuntime.async(function collection$(_context30) {
                  while (1) {
                    switch (_context30.prev = _context30.next) {
                      case 0:
                        return _context30.abrupt("return", {
                          insertOne: function insertOne(docs, options) {
                            return regeneratorRuntime.async(function insertOne$(_context29) {
                              while (1) {
                                switch (_context29.prev = _context29.next) {
                                  case 0:
                                    expect(options).to.deep.equal({
                                      writeConcern: {
                                        w: 1
                                      },
                                      ordered: true
                                    });
                                    options.foo = 'bar';

                                  case 2:
                                  case "end":
                                    return _context29.stop();
                                }
                              }
                            });
                          }
                        });

                      case 1:
                      case "end":
                        return _context30.stop();
                    }
                  }
                });
              }
            };
            _context31.next = 4;
            return regeneratorRuntime.awrap(mockDb.b.insert({
              foo: 'bar'
            }));

          case 4:
            _context31.next = 6;
            return regeneratorRuntime.awrap(mockDb.b.insert({
              foo: 'baz'
            }));

          case 6:
          case "end":
            return _context31.stop();
        }
      }
    });
  });
});