'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.match");

var internals = {
  operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],
  operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],
  operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],
  operatorsPrefix: ['!', 'n'],
  literals: {
    '"': '"',
    '`': '`',
    '\'': '\'',
    '[': ']'
  },
  numberRx: /^(?:[0-9]*\.?[0-9]*){1}$/,
  tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
  symbol: Symbol('formula'),
  settings: Symbol('settings')
};
exports = module.exports = internals.Formula = class {
  constructor(string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!options[internals.settings] && options.constants) {
      for (var constant in options.constants) {
        var value = options.constants[constant];

        if (value !== null && !['boolean', 'number', 'string'].includes(typeof value)) {
          throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
        }
      }
    }

    this.settings = options[internals.settings] ? options : Object.assign({
      [internals.settings]: true,
      constants: {},
      functions: {}
    }, options);
    this.single = null;
    this._parts = null;

    this._parse(string);
  }

  _parse(string) {
    var _this = this;

    var parts = [];
    var current = '';
    var parenthesis = 0;
    var literal = false;

    var flush = function flush(inner) {
      if (parenthesis) {
        throw new Error('Formula missing closing parenthesis');
      }

      var last = parts.length ? parts[parts.length - 1] : null;

      if (!literal && !current && !inner) {
        return;
      }

      if (last && last.type === 'reference' && inner === ')') {
        // Function
        last.type = 'function';
        last.value = _this._subFormula(current, last.value);
        current = '';
        return;
      }

      if (inner === ')') {
        // Segment
        var sub = new internals.Formula(current, _this.settings);
        parts.push({
          type: 'segment',
          value: sub
        });
      } else if (literal) {
        if (literal === ']') {
          // Reference
          parts.push({
            type: 'reference',
            value: current
          });
          current = '';
          return;
        }

        parts.push({
          type: 'literal',
          value: current
        }); // Literal
      } else if (internals.operatorCharacters.includes(current)) {
        // Operator
        if (last && last.type === 'operator' && internals.operators.includes(last.value + current)) {
          // 2 characters operator
          last.value += current;
        } else {
          parts.push({
            type: 'operator',
            value: current
          });
        }
      } else if (current.match(internals.numberRx)) {
        // Number
        parts.push({
          type: 'constant',
          value: parseFloat(current)
        });
      } else if (_this.settings.constants[current] !== undefined) {
        // Constant
        parts.push({
          type: 'constant',
          value: _this.settings.constants[current]
        });
      } else {
        // Reference
        if (!current.match(internals.tokenRx)) {
          throw new Error(`Formula contains invalid token: ${current}`);
        }

        parts.push({
          type: 'reference',
          value: current
        });
      }

      current = '';
    };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = string[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var c = _step.value;

        if (literal) {
          if (c === literal) {
            flush();
            literal = false;
          } else {
            current += c;
          }
        } else if (parenthesis) {
          if (c === '(') {
            current += c;
            ++parenthesis;
          } else if (c === ')') {
            --parenthesis;

            if (!parenthesis) {
              flush(c);
            } else {
              current += c;
            }
          } else {
            current += c;
          }
        } else if (c in internals.literals) {
          literal = internals.literals[c];
        } else if (c === '(') {
          flush();
          ++parenthesis;
        } else if (internals.operatorCharacters.includes(c)) {
          flush();
          current = c;
          flush();
        } else if (c !== ' ') {
          current += c;
        } else {
          flush();
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    flush(); // Replace prefix - to internal negative operator

    parts = parts.map(function (part, i) {
      if (part.type !== 'operator' || part.value !== '-' || i && parts[i - 1].type !== 'operator') {
        return part;
      }

      return {
        type: 'operator',
        value: 'n'
      };
    }); // Validate tokens order

    var operator = false;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = parts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var part = _step2.value;

        if (part.type === 'operator') {
          if (internals.operatorsPrefix.includes(part.value)) {
            continue;
          }

          if (!operator) {
            throw new Error('Formula contains an operator in invalid position');
          }

          if (!internals.operators.includes(part.value)) {
            throw new Error(`Formula contains an unknown operator ${part.value}`);
          }
        } else if (operator) {
          throw new Error('Formula missing expected operator');
        }

        operator = !operator;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    if (!operator) {
      throw new Error('Formula contains invalid trailing operator');
    } // Identify single part


    if (parts.length === 1 && ['reference', 'literal', 'constant'].includes(parts[0].type)) {
      this.single = {
        type: parts[0].type === 'reference' ? 'reference' : 'value',
        value: parts[0].value
      };
    } // Process parts


    this._parts = parts.map(function (part) {
      // Operators
      if (part.type === 'operator') {
        return internals.operatorsPrefix.includes(part.value) ? part : part.value;
      } // Literals, constants, segments


      if (part.type !== 'reference') {
        return part.value;
      } // References


      if (_this.settings.tokenRx && !_this.settings.tokenRx.test(part.value)) {
        throw new Error(`Formula contains invalid reference ${part.value}`);
      }

      if (_this.settings.reference) {
        return _this.settings.reference(part.value);
      }

      return internals.reference(part.value);
    });
  }

  _subFormula(string, name) {
    var _this2 = this;

    var method = this.settings.functions[name];

    if (typeof method !== 'function') {
      throw new Error(`Formula contains unknown function ${name}`);
    }

    var args = [];

    if (string) {
      var current = '';
      var parenthesis = 0;
      var literal = false;

      var flush = function flush() {
        if (!current) {
          throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
        }

        args.push(current);
        current = '';
      };

      for (var i = 0; i < string.length; ++i) {
        var c = string[i];

        if (literal) {
          current += c;

          if (c === literal) {
            literal = false;
          }
        } else if (c in internals.literals && !parenthesis) {
          current += c;
          literal = internals.literals[c];
        } else if (c === ',' && !parenthesis) {
          flush();
        } else {
          current += c;

          if (c === '(') {
            ++parenthesis;
          } else if (c === ')') {
            --parenthesis;
          }
        }
      }

      flush();
    }

    args = args.map(function (arg) {
      return new internals.Formula(arg, _this2.settings);
    });
    return function (context) {
      var innerValues = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var arg = _step3.value;
          innerValues.push(arg.evaluate(context));
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return method.call(context, ...innerValues);
    };
  }

  evaluate(context) {
    var parts = this._parts.slice(); // Prefix operators


    for (var i = parts.length - 2; i >= 0; --i) {
      var part = parts[i];

      if (part && part.type === 'operator') {
        var current = parts[i + 1];
        parts.splice(i + 1, 1);
        var value = internals.evaluate(current, context);
        parts[i] = internals.single(part.value, value);
      }
    } // Left-right operators


    internals.operatorsOrder.forEach(function (set) {
      for (var _i = 1; _i < parts.length - 1;) {
        if (set.includes(parts[_i])) {
          var operator = parts[_i];
          var left = internals.evaluate(parts[_i - 1], context);
          var right = internals.evaluate(parts[_i + 1], context);
          parts.splice(_i, 2);
          var result = internals.calculate(operator, left, right);
          parts[_i - 1] = result === 0 ? 0 : result; // Convert -0
        } else {
          _i += 2;
        }
      }
    });
    return internals.evaluate(parts[0], context);
  }

};
internals.Formula.prototype[internals.symbol] = true;

internals.reference = function (name) {
  return function (context) {
    return context && context[name] !== undefined ? context[name] : null;
  };
};

internals.evaluate = function (part, context) {
  if (part === null) {
    return null;
  }

  if (typeof part === 'function') {
    return part(context);
  }

  if (part[internals.symbol]) {
    return part.evaluate(context);
  }

  return part;
};

internals.single = function (operator, value) {
  if (operator === '!') {
    return value ? false : true;
  } // operator === 'n'


  var negative = -value;

  if (negative === 0) {
    // Override -0
    return 0;
  }

  return negative;
};

internals.calculate = function (operator, left, right) {
  if (operator === '??') {
    return internals.exists(left) ? left : right;
  }

  if (typeof left === 'string' || typeof right === 'string') {
    if (operator === '+') {
      left = internals.exists(left) ? left : '';
      right = internals.exists(right) ? right : '';
      return left + right;
    }
  } else {
    switch (operator) {
      case '^':
        return Math.pow(left, right);

      case '*':
        return left * right;

      case '/':
        return left / right;

      case '%':
        return left % right;

      case '+':
        return left + right;

      case '-':
        return left - right;
    }
  }

  switch (operator) {
    case '<':
      return left < right;

    case '<=':
      return left <= right;

    case '>':
      return left > right;

    case '>=':
      return left >= right;

    case '==':
      return left === right;

    case '!=':
      return left !== right;

    case '&&':
      return left && right;

    case '||':
      return left || right;
  }

  return null;
};

internals.exists = function (value) {
  return value !== null && value !== undefined;
};