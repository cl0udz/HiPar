'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var DeepEqual = require('@hapi/hoek/lib/deepEqual');

var Merge = require('@hapi/hoek/lib/merge');

var Cache = require('./cache');

var Common = require('./common');

var Compile = require('./compile');

var Errors = require('./errors');

var Extend = require('./extend');

var Manifest = require('./manifest');

var Messages = require('./messages');

var Modify = require('./modify');

var Ref = require('./ref');

var Trace = require('./trace');

var Validator = require('./validator');

var Values = require('./values');

var internals = {};

internals.Base =
/*#__PURE__*/
function () {
  function _class(type) {
    _classCallCheck(this, _class);

    // Naming: public, _private, $_extension, $_mutate{action}
    this.type = type;
    this.$_root = null;
    this._definition = {};
    this._ids = new Modify.Ids();
    this._preferences = null;
    this._refs = new Ref.Manager();
    this._cache = null;
    this._valids = null;
    this._invalids = null;
    this._flags = {};
    this._rules = [];
    this._singleRules = new Map(); // The rule options passed for non-multi rules

    this.$_terms = {}; // Hash of arrays of immutable objects (extended by other types)

    this.$_temp = {
      // Runtime state (not cloned)
      ruleset: null,
      // null: use last, false: error, number: start position
      whens: {} // Runtime cache of generated whens

    };
  } // Manifest


  _createClass(_class, [{
    key: "describe",
    value: function describe() {
      Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');
      return Manifest.describe(this);
    } // Rules

  }, {
    key: "allow",
    value: function allow() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      return this._values(values, '_valids');
    }
  }, {
    key: "alter",
    value: function alter(targets) {
      Assert(targets && _typeof(targets) === 'object' && !Array.isArray(targets), 'Invalid targets argument');
      Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');
      var obj = this.clone();
      obj.$_terms.alterations = obj.$_terms.alterations || [];

      for (var target in targets) {
        var adjuster = targets[target];
        Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');
        obj.$_terms.alterations.push({
          target: target,
          adjuster: adjuster
        });
      }

      obj.$_temp.ruleset = false;
      return obj;
    }
  }, {
    key: "cast",
    value: function cast(to) {
      Assert(to === false || typeof to === 'string', 'Invalid to value');
      Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);
      return this.$_setFlag('cast', to === false ? undefined : to);
    }
  }, {
    key: "default",
    value: function _default(value, options) {
      return this._default('default', value, options);
    }
  }, {
    key: "description",
    value: function description(desc) {
      Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');
      return this.$_setFlag('description', desc);
    }
  }, {
    key: "empty",
    value: function empty(schema) {
      var obj = this.clone();

      if (schema !== undefined) {
        schema = obj.$_compile(schema, {
          override: false
        });
      }

      return obj.$_setFlag('empty', schema, {
        clone: false
      });
    }
  }, {
    key: "error",
    value: function error(err) {
      Assert(err, 'Missing error');
      Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');
      return this.$_setFlag('error', err);
    }
  }, {
    key: "example",
    value: function example(_example) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Assert(_example !== undefined, 'Missing example');
      Common.assertOptions(options, ['override']);
      return this._inner('examples', _example, {
        single: true,
        override: options.override
      });
    }
  }, {
    key: "external",
    value: function external(method, description) {
      if (_typeof(method) === 'object') {
        Assert(!description, 'Cannot combine options with description');
        description = method.description;
        method = method.method;
      }

      Assert(typeof method === 'function', 'Method must be a function');
      Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');
      return this._inner('externals', {
        method: method,
        description: description
      }, {
        single: true
      });
    }
  }, {
    key: "failover",
    value: function failover(value, options) {
      return this._default('failover', value, options);
    }
  }, {
    key: "forbidden",
    value: function forbidden() {
      return this.presence('forbidden');
    }
  }, {
    key: "id",
    value: function id(_id) {
      if (!_id) {
        return this.$_setFlag('id', undefined);
      }

      Assert(typeof _id === 'string', 'id must be a non-empty string');
      Assert(/^[^\.]+$/.test(_id), 'id cannot contain period character');
      return this.$_setFlag('id', _id);
    }
  }, {
    key: "invalid",
    value: function invalid() {
      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        values[_key2] = arguments[_key2];
      }

      return this._values(values, '_invalids');
    }
  }, {
    key: "label",
    value: function label(name) {
      Assert(name && typeof name === 'string', 'Label name must be a non-empty string');
      return this.$_setFlag('label', name);
    }
  }, {
    key: "meta",
    value: function meta(_meta) {
      Assert(_meta !== undefined, 'Meta cannot be undefined');
      return this._inner('metas', _meta, {
        single: true
      });
    }
  }, {
    key: "note",
    value: function note() {
      for (var _len3 = arguments.length, notes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        notes[_key3] = arguments[_key3];
      }

      Assert(notes.length, 'Missing notes');

      for (var _i = 0, _notes = notes; _i < _notes.length; _i++) {
        var note = _notes[_i];
        Assert(note && typeof note === 'string', 'Notes must be non-empty strings');
      }

      return this._inner('notes', notes);
    }
  }, {
    key: "only",
    value: function only() {
      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      Assert(typeof mode === 'boolean', 'Invalid mode:', mode);
      return this.$_setFlag('only', mode);
    }
  }, {
    key: "optional",
    value: function optional() {
      return this.presence('optional');
    }
  }, {
    key: "prefs",
    value: function prefs(_prefs) {
      Assert(_prefs, 'Missing preferences');
      Assert(_prefs.context === undefined, 'Cannot override context');
      Assert(_prefs.externals === undefined, 'Cannot override externals');
      Assert(_prefs.warnings === undefined, 'Cannot override warnings');
      Assert(_prefs.debug === undefined, 'Cannot override debug');
      Common.checkPreferences(_prefs);
      var obj = this.clone();
      obj._preferences = Common.preferences(obj._preferences, _prefs);
      return obj;
    }
  }, {
    key: "presence",
    value: function presence(mode) {
      Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);
      return this.$_setFlag('presence', mode);
    }
  }, {
    key: "raw",
    value: function raw() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return this.$_setFlag('result', enabled ? 'raw' : undefined);
    }
  }, {
    key: "result",
    value: function result(mode) {
      Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);
      return this.$_setFlag('result', mode);
    }
  }, {
    key: "required",
    value: function required() {
      return this.presence('required');
    }
  }, {
    key: "strict",
    value: function strict(enabled) {
      var obj = this.clone();
      var convert = enabled === undefined ? false : !enabled;
      obj._preferences = Common.preferences(obj._preferences, {
        convert: convert
      });
      return obj;
    }
  }, {
    key: "strip",
    value: function strip() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return this.$_setFlag('result', enabled ? 'strip' : undefined);
    }
  }, {
    key: "tag",
    value: function tag() {
      for (var _len4 = arguments.length, tags = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        tags[_key4] = arguments[_key4];
      }

      Assert(tags.length, 'Missing tags');

      for (var _i2 = 0, _tags = tags; _i2 < _tags.length; _i2++) {
        var tag = _tags[_i2];
        Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');
      }

      return this._inner('tags', tags);
    }
  }, {
    key: "unit",
    value: function unit(name) {
      Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');
      return this.$_setFlag('unit', name);
    }
  }, {
    key: "valid",
    value: function valid() {
      var obj = this.allow.apply(this, arguments);
      obj.$_setFlag('only', !!obj._valids, {
        clone: false
      });
      return obj;
    }
  }, {
    key: "when",
    value: function when(condition, options) {
      var obj = this.clone();

      if (!obj.$_terms.whens) {
        obj.$_terms.whens = [];
      }

      var when = Compile.when(obj, condition, options);

      if (!['any', 'link'].includes(obj.type)) {
        var conditions = when.is ? [when] : when["switch"];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = conditions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;
            Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);
            Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      obj.$_terms.whens.push(when);
      return obj.$_mutateRebuild();
    } // Helpers

  }, {
    key: "cache",
    value: function cache(_cache) {
      Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');
      Assert(!this._cache, 'Cannot override schema cache');
      var obj = this.clone();
      obj._cache = _cache || Cache.provider.provision();
      obj.$_temp.ruleset = false;
      return obj;
    }
  }, {
    key: "clone",
    value: function clone() {
      var obj = Object.create(Object.getPrototypeOf(this));
      return this._assign(obj);
    }
  }, {
    key: "concat",
    value: function concat(source) {
      Assert(Common.isSchema(source), 'Invalid schema object');
      Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);
      Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');
      Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');
      var obj = this.clone();

      if (this.type === 'any' && source.type !== 'any') {
        // Change obj to match source type
        var tmpObj = source.clone();

        for (var _i3 = 0, _Object$keys = Object.keys(obj); _i3 < _Object$keys.length; _i3++) {
          var key = _Object$keys[_i3];

          if (key !== 'type') {
            tmpObj[key] = obj[key];
          }
        }

        obj = tmpObj;
      }

      obj._ids.concat(source._ids);

      obj._refs.register(source, Ref.toSibling);

      obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
      obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
      obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids); // Remove unique rules present in source

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        var _loop = function _loop() {
          var name = _step2.value;

          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter(function (target) {
              return target.keep || target.name !== name;
            });

            obj._singleRules["delete"](name);
          }
        };

        for (var _iterator2 = source._singleRules.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          _loop();
        } // Rules

      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = source._rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var test = _step3.value;

          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }

          obj._rules.push(test);
        } // Flags

      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (obj._flags.empty && source._flags.empty) {
        obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
        var flags = Object.assign({}, source._flags);
        delete flags.empty;
        Merge(obj._flags, flags);
      } else if (source._flags.empty) {
        obj._flags.empty = source._flags.empty;

        var _flags = Object.assign({}, source._flags);

        delete _flags.empty;
        Merge(obj._flags, _flags);
      } else {
        Merge(obj._flags, source._flags);
      } // Terms


      for (var _key5 in source.$_terms) {
        var terms = source.$_terms[_key5];

        if (!terms) {
          if (!obj.$_terms[_key5]) {
            obj.$_terms[_key5] = terms;
          }

          continue;
        }

        if (!obj.$_terms[_key5]) {
          obj.$_terms[_key5] = terms.slice();
          continue;
        }

        obj.$_terms[_key5] = obj.$_terms[_key5].concat(terms);
      } // Tracing


      if (this.$_root._tracer) {
        this.$_root._tracer._combine(obj, [this, source]);
      } // Rebuild


      return obj.$_mutateRebuild();
    }
  }, {
    key: "extend",
    value: function extend(options) {
      Assert(!options.base, 'Cannot extend type with another base');
      return Extend.type(this, options);
    }
  }, {
    key: "extract",
    value: function extract(path) {
      path = Array.isArray(path) ? path : path.split('.');
      return this._ids.reach(path);
    }
  }, {
    key: "fork",
    value: function fork(paths, adjuster) {
      Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');
      var obj = this; // eslint-disable-line consistent-this

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = [].concat(paths)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var path = _step4.value;
          path = Array.isArray(path) ? path : path.split('.');
          obj = obj._ids.fork(path, adjuster, obj);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      obj.$_temp.ruleset = false;
      return obj;
    }
  }, {
    key: "rule",
    value: function rule(options) {
      var def = this._definition;
      Common.assertOptions(options, Object.keys(def.modifiers));
      Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');
      var start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
      Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');
      var obj = this.clone();

      for (var i = start; i < obj._rules.length; ++i) {
        var original = obj._rules[i];
        var rule = Clone(original);

        for (var name in options) {
          def.modifiers[name](rule, options[name]);
          Assert(rule.name === original.name, 'Cannot change rule name');
        }

        obj._rules[i] = rule;

        if (obj._singleRules.get(rule.name) === original) {
          obj._singleRules.set(rule.name, rule);
        }
      }

      obj.$_temp.ruleset = false;
      return obj.$_mutateRebuild();
    }
  }, {
    key: "tailor",
    value: function tailor(targets) {
      targets = [].concat(targets);
      Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');
      var obj = this; // eslint-disable-line consistent-this

      if (this.$_terms.alterations) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = this.$_terms.alterations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _step5$value = _step5.value,
                target = _step5$value.target,
                adjuster = _step5$value.adjuster;

            if (targets.includes(target)) {
              obj = adjuster(obj);
              Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }

      obj = obj.$_modify({
        each: function each(item) {
          return item.tailor(targets);
        },
        ref: false
      });
      obj.$_temp.ruleset = false;
      return obj.$_mutateRebuild();
    }
  }, {
    key: "tracer",
    value: function tracer() {
      return Trace.location ? Trace.location(this) : this; // $lab:coverage:ignore$
    }
  }, {
    key: "validate",
    value: function validate(value, options) {
      return Validator.entry(value, this, options);
    }
  }, {
    key: "validateAsync",
    value: function validateAsync(value, options) {
      return Validator.entryAsync(value, this, options);
    } // Extensions

  }, {
    key: "$_addRule",
    value: function $_addRule(options) {
      // Normalize rule
      if (typeof options === 'string') {
        options = {
          name: options
        };
      }

      Assert(options && _typeof(options) === 'object', 'Invalid options');
      Assert(options.name && typeof options.name === 'string', 'Invalid rule name');

      for (var key in options) {
        Assert(key[0] !== '_', 'Cannot set private rule properties');
      }

      var rule = Object.assign({}, options); // Shallow cloned

      rule._resolve = [];
      rule.method = rule.method || rule.name;
      var definition = this._definition.rules[rule.method];
      var args = rule.args;
      Assert(definition, 'Unknown rule', rule.method); // Args

      var obj = this.clone();

      if (args) {
        Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);

        for (var _key6 in args) {
          var arg = args[_key6];

          if (arg === undefined) {
            delete args[_key6];
            continue;
          }

          if (definition.argsByName) {
            var resolver = definition.argsByName.get(_key6);

            if (resolver.ref && Common.isResolvable(arg)) {
              rule._resolve.push(_key6);

              obj.$_mutateRegister(arg);
            } else {
              if (resolver.normalize) {
                arg = resolver.normalize(arg);
                args[_key6] = arg;
              }

              if (resolver.assert) {
                var error = Common.validateArg(arg, _key6, resolver);
                Assert(!error, error, 'or reference');
              }
            }
          }

          args[_key6] = arg;
        }
      } // Unique rules


      if (!definition.multi) {
        obj._ruleRemove(rule.name, {
          clone: false
        });

        obj._singleRules.set(rule.name, rule);
      }

      if (obj.$_temp.ruleset === false) {
        obj.$_temp.ruleset = null;
      }

      if (definition.priority) {
        obj._rules.unshift(rule);
      } else {
        obj._rules.push(rule);
      }

      return obj;
    }
  }, {
    key: "$_compile",
    value: function $_compile(schema, options) {
      return Compile.schema(this.$_root, schema, options);
    }
  }, {
    key: "$_createError",
    value: function $_createError(code, value, local, state, prefs) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
      var flags = options.flags !== false ? this._flags : {};
      var messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
      return new Errors.Report(code, value, local, flags, messages, state, prefs);
    }
  }, {
    key: "$_getFlag",
    value: function $_getFlag(name) {
      return this._flags[name];
    }
  }, {
    key: "$_getRule",
    value: function $_getRule(name) {
      return this._singleRules.get(name);
    }
  }, {
    key: "$_mapLabels",
    value: function $_mapLabels(path) {
      path = Array.isArray(path) ? path : path.split('.');
      return this._ids.labels(path);
    }
  }, {
    key: "$_match",
    value: function $_match(value, state, prefs, overrides) {
      prefs = Object.assign({}, prefs); // Shallow cloned

      prefs.abortEarly = true;
      prefs._externals = false;
      state.snapshot();
      var result = !Validator.validate(value, this, state, prefs, overrides).errors;
      state.restore();
      return result;
    }
  }, {
    key: "$_modify",
    value: function $_modify(options) {
      Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);
      return Modify.schema(this, options) || this;
    }
  }, {
    key: "$_mutateRebuild",
    value: function $_mutateRebuild() {
      var _this = this;

      Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');

      this._refs.reset();

      this._ids.reset();

      var each = function each(item, _ref) {
        var source = _ref.source,
            name = _ref.name,
            path = _ref.path,
            key = _ref.key;
        var family = _this._definition[source][name] && _this._definition[source][name].register;

        if (family !== false) {
          _this.$_mutateRegister(item, {
            family: family,
            key: key
          });
        }
      };

      this.$_modify({
        each: each
      });

      if (this._definition.rebuild) {
        this._definition.rebuild(this);
      }

      this.$_temp.ruleset = false;
      return this;
    }
  }, {
    key: "$_mutateRegister",
    value: function $_mutateRegister(schema) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          family = _ref2.family,
          key = _ref2.key;

      this._refs.register(schema, family);

      this._ids.register(schema, {
        key: key
      });
    }
  }, {
    key: "$_property",
    value: function $_property(name) {
      return this._definition.properties[name];
    }
  }, {
    key: "$_reach",
    value: function $_reach(path) {
      return this._ids.reach(path);
    }
  }, {
    key: "$_rootReferences",
    value: function $_rootReferences() {
      return this._refs.roots();
    }
  }, {
    key: "$_setFlag",
    value: function $_setFlag(name, value) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');
      var flag = this._definition.flags[name] || {};

      if (DeepEqual(value, flag["default"])) {
        value = undefined;
      }

      if (DeepEqual(value, this._flags[name])) {
        return this;
      }

      var obj = options.clone !== false ? this.clone() : this;

      if (value !== undefined) {
        obj._flags[name] = value;
        obj.$_mutateRegister(value);
      } else {
        delete obj._flags[name];
      }

      if (name[0] !== '_') {
        obj.$_temp.ruleset = false;
      }

      return obj;
    }
  }, {
    key: "$_validate",
    value: function $_validate(value, state, prefs) {
      return Validator.validate(value, this, state, prefs);
    } // Internals

  }, {
    key: "_assign",
    value: function _assign(target) {
      target.type = this.type;
      target.$_root = this.$_root;
      target.$_temp = Object.assign({}, this.$_temp);
      target.$_temp.whens = {};
      target._ids = this._ids.clone();
      target._preferences = this._preferences;
      target._valids = this._valids && this._valids.clone();
      target._invalids = this._invalids && this._invalids.clone();
      target._rules = this._rules.slice();
      target._singleRules = Clone(this._singleRules, {
        shallow: true
      });
      target._refs = this._refs.clone();
      target._flags = Object.assign({}, this._flags);
      target._cache = null;
      target.$_terms = {};

      for (var key in this.$_terms) {
        target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
      }

      target.$_super = {};

      for (var override in this.$_super) {
        target.$_super[override] = this._super[override].bind(target);
      }

      return target;
    }
  }, {
    key: "_default",
    value: function _default(flag, value) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      Common.assertOptions(options, 'literal');
      Assert(value !== undefined, 'Missing', flag, 'value');
      Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');

      if (typeof value === 'function' && options.literal) {
        var _value;

        value = (_value = {}, _defineProperty(_value, Common.symbols.literal, true), _defineProperty(_value, "literal", value), _value);
      }

      var obj = this.$_setFlag(flag, value);
      return obj;
    }
  }, {
    key: "_generate",
    value: function _generate(value, state, prefs) {
      if (!this.$_terms.whens) {
        return {
          schema: this
        };
      } // Collect matching whens


      var whens = [];
      var ids = [];

      for (var i = 0; i < this.$_terms.whens.length; ++i) {
        var when = this.$_terms.whens[i];

        if (when.concat) {
          whens.push(when.concat);
          ids.push("".concat(i, ".concat"));
          continue;
        }

        var input = when.ref ? when.ref.resolve(value, state, prefs) : value;
        var tests = when.is ? [when] : when["switch"];
        var before = ids.length;

        for (var j = 0; j < tests.length; ++j) {
          var _tests$j = tests[j],
              is = _tests$j.is,
              then = _tests$j.then,
              otherwise = _tests$j.otherwise;
          var baseId = "".concat(i).concat(when["switch"] ? '.' + j : '');

          if (is.$_match(input, state.nest(is, "".concat(baseId, ".is")), prefs)) {
            if (then) {
              var localState = state.localize([].concat(_toConsumableArray(state.path), ["".concat(baseId, ".then")]), state.ancestors, state.schemas);

              var _then$_generate = then._generate(value, localState, prefs),
                  generated = _then$_generate.schema,
                  _id2 = _then$_generate.id;

              whens.push(generated);
              ids.push("".concat(baseId, ".then").concat(_id2 ? "(".concat(_id2, ")") : ''));
              break;
            }
          } else if (otherwise) {
            var _localState = state.localize([].concat(_toConsumableArray(state.path), ["".concat(baseId, ".otherwise")]), state.ancestors, state.schemas);

            var _otherwise$_generate = otherwise._generate(value, _localState, prefs),
                _generated = _otherwise$_generate.schema,
                _id3 = _otherwise$_generate.id;

            whens.push(_generated);
            ids.push("".concat(baseId, ".otherwise").concat(_id3 ? "(".concat(_id3, ")") : ''));
            break;
          }
        }

        if (when["break"] && ids.length > before) {
          // Something matched
          break;
        }
      } // Check cache


      var id = ids.join(', ');
      state.mainstay.tracer.debug(state, 'rule', 'when', id);

      if (!id) {
        return {
          schema: this
        };
      }

      if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
        return {
          schema: this.$_temp.whens[id],
          id: id
        };
      } // Generate dynamic schema


      var obj = this; // eslint-disable-line consistent-this

      if (this._definition.generate) {
        obj = this._definition.generate(this, value, state, prefs);
      } // Apply whens


      for (var _i4 = 0, _whens = whens; _i4 < _whens.length; _i4++) {
        var _when = _whens[_i4];
        obj = obj.concat(_when);
      } // Tracing


      if (this.$_root._tracer) {
        this.$_root._tracer._combine(obj, [this].concat(whens));
      } // Cache result


      this.$_temp.whens[id] = obj;
      return {
        schema: obj,
        id: id
      };
    }
  }, {
    key: "_inner",
    value: function _inner(type, values) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      Assert(!this._inRuleset(), "Cannot set ".concat(type, " inside a ruleset"));
      var obj = this.clone();

      if (!obj.$_terms[type] || options.override) {
        obj.$_terms[type] = [];
      }

      if (options.single) {
        obj.$_terms[type].push(values);
      } else {
        var _obj$$_terms$type;

        (_obj$$_terms$type = obj.$_terms[type]).push.apply(_obj$$_terms$type, _toConsumableArray(values));
      }

      obj.$_temp.ruleset = false;
      return obj;
    }
  }, {
    key: "_inRuleset",
    value: function _inRuleset() {
      return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
    }
  }, {
    key: "_ruleRemove",
    value: function _ruleRemove(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this._singleRules.has(name)) {
        return this;
      }

      var obj = options.clone !== false ? this.clone() : this;

      obj._singleRules["delete"](name);

      var filtered = [];

      for (var i = 0; i < obj._rules.length; ++i) {
        var test = obj._rules[i];

        if (test.name === name && !test.keep) {
          if (obj._inRuleset() && i < obj.$_temp.ruleset) {
            --obj.$_temp.ruleset;
          }

          continue;
        }

        filtered.push(test);
      }

      obj._rules = filtered;
      return obj;
    }
  }, {
    key: "_values",
    value: function _values(values, key) {
      Common.verifyFlat(values, key.slice(1, -1));
      var obj = this.clone();
      var override = values[0] === Common.symbols.override;

      if (override) {
        values = values.slice(1);
      }

      if (!obj[key] && values.length) {
        obj[key] = new Values();
      } else if (override) {
        obj[key] = values.length ? new Values() : null;
        obj.$_mutateRebuild();
      }

      if (!obj[key]) {
        return obj;
      }

      if (override) {
        obj[key].override();
      }

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = values[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var value = _step6.value;
          Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
          Assert(value !== Common.symbols.override, 'Override must be the first value');
          var other = key === '_invalids' ? '_valids' : '_invalids';

          if (obj[other]) {
            obj[other].remove(value);

            if (!obj[other].length) {
              Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');
              obj[other] = null;
            }
          }

          obj[key].add(value, obj._refs);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return obj;
    }
  }, {
    key: "ruleset",
    get: function get() {
      Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');
      var obj = this.clone();
      obj.$_temp.ruleset = obj._rules.length;
      return obj;
    }
  }, {
    key: "$",
    get: function get() {
      return this.ruleset;
    }
  }]);

  return _class;
}();

internals.Base.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects

internals.Base.prototype[Common.symbols.any] = {
  version: Common.version,
  compile: Compile.compile,
  root: '$_root'
}; // Aliases

internals.Base.prototype.deny = internals.Base.prototype.invalid;
internals.Base.prototype.disallow = internals.Base.prototype.invalid;
internals.Base.prototype.equal = internals.Base.prototype.valid;
internals.Base.prototype.exist = internals.Base.prototype.required;
internals.Base.prototype.not = internals.Base.prototype.invalid;
internals.Base.prototype.options = internals.Base.prototype.prefs;
internals.Base.prototype.preferences = internals.Base.prototype.prefs;
module.exports = new internals.Base();