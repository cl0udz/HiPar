'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.map");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.flags");

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.split");

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var DeepEqual = require('@hapi/hoek/lib/deepEqual');

var Merge = require('@hapi/hoek/lib/merge');

var Cache = require('./cache');

var Common = require('./common');

var Compile = require('./compile');

var Errors = require('./errors');

var Extend = require('./extend');

var Manifest = require('./manifest');

var Messages = require('./messages');

var Modify = require('./modify');

var Ref = require('./ref');

var Trace = require('./trace');

var Validator = require('./validator');

var Values = require('./values');

var internals = {};
internals.Base = class {
  constructor(type) {
    // Naming: public, _private, $_extension, $_mutate{action}
    this.type = type;
    this.$_root = null;
    this._definition = {};
    this._ids = new Modify.Ids();
    this._preferences = null;
    this._refs = new Ref.Manager();
    this._cache = null;
    this._valids = null;
    this._invalids = null;
    this._flags = {};
    this._rules = [];
    this._singleRules = new Map(); // The rule options passed for non-multi rules

    this.$_terms = {}; // Hash of arrays of immutable objects (extended by other types)

    this.$_temp = {
      // Runtime state (not cloned)
      ruleset: null,
      // null: use last, false: error, number: start position
      whens: {} // Runtime cache of generated whens

    };
  } // Manifest


  describe() {
    Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');
    return Manifest.describe(this);
  } // Rules


  allow() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return this._values(values, '_valids');
  }

  alter(targets) {
    Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');
    Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');
    var obj = this.clone();
    obj.$_terms.alterations = obj.$_terms.alterations || [];

    for (var target in targets) {
      var adjuster = targets[target];
      Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');
      obj.$_terms.alterations.push({
        target,
        adjuster
      });
    }

    obj.$_temp.ruleset = false;
    return obj;
  }

  cast(to) {
    Assert(to === false || typeof to === 'string', 'Invalid to value');
    Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);
    return this.$_setFlag('cast', to === false ? undefined : to);
  }

  default(value, options) {
    return this._default('default', value, options);
  }

  description(desc) {
    Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');
    return this.$_setFlag('description', desc);
  }

  empty(schema) {
    var obj = this.clone();

    if (schema !== undefined) {
      schema = obj.$_compile(schema, {
        override: false
      });
    }

    return obj.$_setFlag('empty', schema, {
      clone: false
    });
  }

  error(err) {
    Assert(err, 'Missing error');
    Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');
    return this.$_setFlag('error', err);
  }

  example(example) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Assert(example !== undefined, 'Missing example');
    Common.assertOptions(options, ['override']);
    return this._inner('examples', example, {
      single: true,
      override: options.override
    });
  }

  external(method, description) {
    if (typeof method === 'object') {
      Assert(!description, 'Cannot combine options with description');
      description = method.description;
      method = method.method;
    }

    Assert(typeof method === 'function', 'Method must be a function');
    Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');
    return this._inner('externals', {
      method,
      description
    }, {
      single: true
    });
  }

  failover(value, options) {
    return this._default('failover', value, options);
  }

  forbidden() {
    return this.presence('forbidden');
  }

  id(id) {
    if (!id) {
      return this.$_setFlag('id', undefined);
    }

    Assert(typeof id === 'string', 'id must be a non-empty string');
    Assert(/^[^\.]+$/.test(id), 'id cannot contain period character');
    return this.$_setFlag('id', id);
  }

  invalid() {
    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      values[_key2] = arguments[_key2];
    }

    return this._values(values, '_invalids');
  }

  label(name) {
    Assert(name && typeof name === 'string', 'Label name must be a non-empty string');
    return this.$_setFlag('label', name);
  }

  meta(meta) {
    Assert(meta !== undefined, 'Meta cannot be undefined');
    return this._inner('metas', meta, {
      single: true
    });
  }

  note() {
    for (var _len3 = arguments.length, notes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      notes[_key3] = arguments[_key3];
    }

    Assert(notes.length, 'Missing notes');

    for (var _i = 0, _notes = notes; _i < _notes.length; _i++) {
      var note = _notes[_i];
      Assert(note && typeof note === 'string', 'Notes must be non-empty strings');
    }

    return this._inner('notes', notes);
  }

  only() {
    var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    Assert(typeof mode === 'boolean', 'Invalid mode:', mode);
    return this.$_setFlag('only', mode);
  }

  optional() {
    return this.presence('optional');
  }

  prefs(prefs) {
    Assert(prefs, 'Missing preferences');
    Assert(prefs.context === undefined, 'Cannot override context');
    Assert(prefs.externals === undefined, 'Cannot override externals');
    Assert(prefs.warnings === undefined, 'Cannot override warnings');
    Assert(prefs.debug === undefined, 'Cannot override debug');
    Common.checkPreferences(prefs);
    var obj = this.clone();
    obj._preferences = Common.preferences(obj._preferences, prefs);
    return obj;
  }

  presence(mode) {
    Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);
    return this.$_setFlag('presence', mode);
  }

  raw() {
    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return this.$_setFlag('result', enabled ? 'raw' : undefined);
  }

  result(mode) {
    Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);
    return this.$_setFlag('result', mode);
  }

  required() {
    return this.presence('required');
  }

  strict(enabled) {
    var obj = this.clone();
    var convert = enabled === undefined ? false : !enabled;
    obj._preferences = Common.preferences(obj._preferences, {
      convert
    });
    return obj;
  }

  strip() {
    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return this.$_setFlag('result', enabled ? 'strip' : undefined);
  }

  tag() {
    for (var _len4 = arguments.length, tags = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      tags[_key4] = arguments[_key4];
    }

    Assert(tags.length, 'Missing tags');

    for (var _i2 = 0, _tags = tags; _i2 < _tags.length; _i2++) {
      var tag = _tags[_i2];
      Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');
    }

    return this._inner('tags', tags);
  }

  unit(name) {
    Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');
    return this.$_setFlag('unit', name);
  }

  valid() {
    var obj = this.allow(...arguments);
    obj.$_setFlag('only', !!obj._valids, {
      clone: false
    });
    return obj;
  }

  when(condition, options) {
    var obj = this.clone();

    if (!obj.$_terms.whens) {
      obj.$_terms.whens = [];
    }

    var when = Compile.when(obj, condition, options);

    if (!['any', 'link'].includes(obj.type)) {
      var conditions = when.is ? [when] : when.switch;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = conditions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;
          Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);
          Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    obj.$_terms.whens.push(when);
    return obj.$_mutateRebuild();
  } // Helpers


  cache(cache) {
    Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');
    Assert(!this._cache, 'Cannot override schema cache');
    var obj = this.clone();
    obj._cache = cache || Cache.provider.provision();
    obj.$_temp.ruleset = false;
    return obj;
  }

  clone() {
    var obj = Object.create(Object.getPrototypeOf(this));
    return this._assign(obj);
  }

  concat(source) {
    Assert(Common.isSchema(source), 'Invalid schema object');
    Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);
    Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');
    Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');
    var obj = this.clone();

    if (this.type === 'any' && source.type !== 'any') {
      // Change obj to match source type
      var tmpObj = source.clone();

      for (var _i3 = 0, _Object$keys = Object.keys(obj); _i3 < _Object$keys.length; _i3++) {
        var key = _Object$keys[_i3];

        if (key !== 'type') {
          tmpObj[key] = obj[key];
        }
      }

      obj = tmpObj;
    }

    obj._ids.concat(source._ids);

    obj._refs.register(source, Ref.toSibling);

    obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
    obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
    obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids); // Remove unique rules present in source

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      var _loop = function _loop() {
        var name = _step2.value;

        if (obj._singleRules.has(name)) {
          obj._rules = obj._rules.filter(function (target) {
            return target.keep || target.name !== name;
          });

          obj._singleRules.delete(name);
        }
      };

      for (var _iterator2 = source._singleRules.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        _loop();
      } // Rules

    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = source._rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var test = _step3.value;

        if (!source._definition.rules[test.method].multi) {
          obj._singleRules.set(test.name, test);
        }

        obj._rules.push(test);
      } // Flags

    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    if (obj._flags.empty && source._flags.empty) {
      obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
      var flags = Object.assign({}, source._flags);
      delete flags.empty;
      Merge(obj._flags, flags);
    } else if (source._flags.empty) {
      obj._flags.empty = source._flags.empty;

      var _flags = Object.assign({}, source._flags);

      delete _flags.empty;
      Merge(obj._flags, _flags);
    } else {
      Merge(obj._flags, source._flags);
    } // Terms


    for (var _key5 in source.$_terms) {
      var terms = source.$_terms[_key5];

      if (!terms) {
        if (!obj.$_terms[_key5]) {
          obj.$_terms[_key5] = terms;
        }

        continue;
      }

      if (!obj.$_terms[_key5]) {
        obj.$_terms[_key5] = terms.slice();
        continue;
      }

      obj.$_terms[_key5] = obj.$_terms[_key5].concat(terms);
    } // Tracing


    if (this.$_root._tracer) {
      this.$_root._tracer._combine(obj, [this, source]);
    } // Rebuild


    return obj.$_mutateRebuild();
  }

  extend(options) {
    Assert(!options.base, 'Cannot extend type with another base');
    return Extend.type(this, options);
  }

  extract(path) {
    path = Array.isArray(path) ? path : path.split('.');
    return this._ids.reach(path);
  }

  fork(paths, adjuster) {
    Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');
    var obj = this; // eslint-disable-line consistent-this

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = [].concat(paths)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var path = _step4.value;
        path = Array.isArray(path) ? path : path.split('.');
        obj = obj._ids.fork(path, adjuster, obj);
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    obj.$_temp.ruleset = false;
    return obj;
  }

  rule(options) {
    var def = this._definition;
    Common.assertOptions(options, Object.keys(def.modifiers));
    Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');
    var start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
    Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');
    var obj = this.clone();

    for (var i = start; i < obj._rules.length; ++i) {
      var original = obj._rules[i];
      var rule = Clone(original);

      for (var name in options) {
        def.modifiers[name](rule, options[name]);
        Assert(rule.name === original.name, 'Cannot change rule name');
      }

      obj._rules[i] = rule;

      if (obj._singleRules.get(rule.name) === original) {
        obj._singleRules.set(rule.name, rule);
      }
    }

    obj.$_temp.ruleset = false;
    return obj.$_mutateRebuild();
  }

  get ruleset() {
    Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');
    var obj = this.clone();
    obj.$_temp.ruleset = obj._rules.length;
    return obj;
  }

  get $() {
    return this.ruleset;
  }

  tailor(targets) {
    targets = [].concat(targets);
    Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');
    var obj = this; // eslint-disable-line consistent-this

    if (this.$_terms.alterations) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.$_terms.alterations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _step5$value = _step5.value,
              target = _step5$value.target,
              adjuster = _step5$value.adjuster;

          if (targets.includes(target)) {
            obj = adjuster(obj);
            Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }

    obj = obj.$_modify({
      each: function each(item) {
        return item.tailor(targets);
      },
      ref: false
    });
    obj.$_temp.ruleset = false;
    return obj.$_mutateRebuild();
  }

  tracer() {
    return Trace.location ? Trace.location(this) : this; // $lab:coverage:ignore$
  }

  validate(value, options) {
    return Validator.entry(value, this, options);
  }

  validateAsync(value, options) {
    return Validator.entryAsync(value, this, options);
  } // Extensions


  $_addRule(options) {
    // Normalize rule
    if (typeof options === 'string') {
      options = {
        name: options
      };
    }

    Assert(options && typeof options === 'object', 'Invalid options');
    Assert(options.name && typeof options.name === 'string', 'Invalid rule name');

    for (var key in options) {
      Assert(key[0] !== '_', 'Cannot set private rule properties');
    }

    var rule = Object.assign({}, options); // Shallow cloned

    rule._resolve = [];
    rule.method = rule.method || rule.name;
    var definition = this._definition.rules[rule.method];
    var args = rule.args;
    Assert(definition, 'Unknown rule', rule.method); // Args

    var obj = this.clone();

    if (args) {
      Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);

      for (var _key6 in args) {
        var arg = args[_key6];

        if (arg === undefined) {
          delete args[_key6];
          continue;
        }

        if (definition.argsByName) {
          var resolver = definition.argsByName.get(_key6);

          if (resolver.ref && Common.isResolvable(arg)) {
            rule._resolve.push(_key6);

            obj.$_mutateRegister(arg);
          } else {
            if (resolver.normalize) {
              arg = resolver.normalize(arg);
              args[_key6] = arg;
            }

            if (resolver.assert) {
              var error = Common.validateArg(arg, _key6, resolver);
              Assert(!error, error, 'or reference');
            }
          }
        }

        args[_key6] = arg;
      }
    } // Unique rules


    if (!definition.multi) {
      obj._ruleRemove(rule.name, {
        clone: false
      });

      obj._singleRules.set(rule.name, rule);
    }

    if (obj.$_temp.ruleset === false) {
      obj.$_temp.ruleset = null;
    }

    if (definition.priority) {
      obj._rules.unshift(rule);
    } else {
      obj._rules.push(rule);
    }

    return obj;
  }

  $_compile(schema, options) {
    return Compile.schema(this.$_root, schema, options);
  }

  $_createError(code, value, local, state, prefs) {
    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
    var flags = options.flags !== false ? this._flags : {};
    var messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
    return new Errors.Report(code, value, local, flags, messages, state, prefs);
  }

  $_getFlag(name) {
    return this._flags[name];
  }

  $_getRule(name) {
    return this._singleRules.get(name);
  }

  $_mapLabels(path) {
    path = Array.isArray(path) ? path : path.split('.');
    return this._ids.labels(path);
  }

  $_match(value, state, prefs, overrides) {
    prefs = Object.assign({}, prefs); // Shallow cloned

    prefs.abortEarly = true;
    prefs._externals = false;
    state.snapshot();
    var result = !Validator.validate(value, this, state, prefs, overrides).errors;
    state.restore();
    return result;
  }

  $_modify(options) {
    Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);
    return Modify.schema(this, options) || this;
  }

  $_mutateRebuild() {
    var _this = this;

    Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');

    this._refs.reset();

    this._ids.reset();

    var each = function each(item, _ref) {
      var source = _ref.source,
          name = _ref.name,
          path = _ref.path,
          key = _ref.key;
      var family = _this._definition[source][name] && _this._definition[source][name].register;

      if (family !== false) {
        _this.$_mutateRegister(item, {
          family,
          key
        });
      }
    };

    this.$_modify({
      each
    });

    if (this._definition.rebuild) {
      this._definition.rebuild(this);
    }

    this.$_temp.ruleset = false;
    return this;
  }

  $_mutateRegister(schema) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        family = _ref2.family,
        key = _ref2.key;

    this._refs.register(schema, family);

    this._ids.register(schema, {
      key
    });
  }

  $_property(name) {
    return this._definition.properties[name];
  }

  $_reach(path) {
    return this._ids.reach(path);
  }

  $_rootReferences() {
    return this._refs.roots();
  }

  $_setFlag(name, value) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');
    var flag = this._definition.flags[name] || {};

    if (DeepEqual(value, flag.default)) {
      value = undefined;
    }

    if (DeepEqual(value, this._flags[name])) {
      return this;
    }

    var obj = options.clone !== false ? this.clone() : this;

    if (value !== undefined) {
      obj._flags[name] = value;
      obj.$_mutateRegister(value);
    } else {
      delete obj._flags[name];
    }

    if (name[0] !== '_') {
      obj.$_temp.ruleset = false;
    }

    return obj;
  }

  $_validate(value, state, prefs) {
    return Validator.validate(value, this, state, prefs);
  } // Internals


  _assign(target) {
    target.type = this.type;
    target.$_root = this.$_root;
    target.$_temp = Object.assign({}, this.$_temp);
    target.$_temp.whens = {};
    target._ids = this._ids.clone();
    target._preferences = this._preferences;
    target._valids = this._valids && this._valids.clone();
    target._invalids = this._invalids && this._invalids.clone();
    target._rules = this._rules.slice();
    target._singleRules = Clone(this._singleRules, {
      shallow: true
    });
    target._refs = this._refs.clone();
    target._flags = Object.assign({}, this._flags);
    target._cache = null;
    target.$_terms = {};

    for (var key in this.$_terms) {
      target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
    }

    target.$_super = {};

    for (var override in this.$_super) {
      target.$_super[override] = this._super[override].bind(target);
    }

    return target;
  }

  _default(flag, value) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Common.assertOptions(options, 'literal');
    Assert(value !== undefined, 'Missing', flag, 'value');
    Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');

    if (typeof value === 'function' && options.literal) {
      value = {
        [Common.symbols.literal]: true,
        literal: value
      };
    }

    var obj = this.$_setFlag(flag, value);
    return obj;
  }

  _generate(value, state, prefs) {
    if (!this.$_terms.whens) {
      return {
        schema: this
      };
    } // Collect matching whens


    var whens = [];
    var ids = [];

    for (var i = 0; i < this.$_terms.whens.length; ++i) {
      var when = this.$_terms.whens[i];

      if (when.concat) {
        whens.push(when.concat);
        ids.push(`${i}.concat`);
        continue;
      }

      var input = when.ref ? when.ref.resolve(value, state, prefs) : value;
      var tests = when.is ? [when] : when.switch;
      var before = ids.length;

      for (var j = 0; j < tests.length; ++j) {
        var _tests$j = tests[j],
            is = _tests$j.is,
            then = _tests$j.then,
            otherwise = _tests$j.otherwise;
        var baseId = `${i}${when.switch ? '.' + j : ''}`;

        if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
          if (then) {
            var localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);

            var _then$_generate = then._generate(value, localState, prefs),
                generated = _then$_generate.schema,
                _id = _then$_generate.id;

            whens.push(generated);
            ids.push(`${baseId}.then${_id ? `(${_id})` : ''}`);
            break;
          }
        } else if (otherwise) {
          var _localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);

          var _otherwise$_generate = otherwise._generate(value, _localState, prefs),
              _generated = _otherwise$_generate.schema,
              _id2 = _otherwise$_generate.id;

          whens.push(_generated);
          ids.push(`${baseId}.otherwise${_id2 ? `(${_id2})` : ''}`);
          break;
        }
      }

      if (when.break && ids.length > before) {
        // Something matched
        break;
      }
    } // Check cache


    var id = ids.join(', ');
    state.mainstay.tracer.debug(state, 'rule', 'when', id);

    if (!id) {
      return {
        schema: this
      };
    }

    if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
      return {
        schema: this.$_temp.whens[id],
        id
      };
    } // Generate dynamic schema


    var obj = this; // eslint-disable-line consistent-this

    if (this._definition.generate) {
      obj = this._definition.generate(this, value, state, prefs);
    } // Apply whens


    for (var _i4 = 0, _whens = whens; _i4 < _whens.length; _i4++) {
      var _when = _whens[_i4];
      obj = obj.concat(_when);
    } // Tracing


    if (this.$_root._tracer) {
      this.$_root._tracer._combine(obj, [this, ...whens]);
    } // Cache result


    this.$_temp.whens[id] = obj;
    return {
      schema: obj,
      id
    };
  }

  _inner(type, values) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);
    var obj = this.clone();

    if (!obj.$_terms[type] || options.override) {
      obj.$_terms[type] = [];
    }

    if (options.single) {
      obj.$_terms[type].push(values);
    } else {
      obj.$_terms[type].push(...values);
    }

    obj.$_temp.ruleset = false;
    return obj;
  }

  _inRuleset() {
    return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
  }

  _ruleRemove(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!this._singleRules.has(name)) {
      return this;
    }

    var obj = options.clone !== false ? this.clone() : this;

    obj._singleRules.delete(name);

    var filtered = [];

    for (var i = 0; i < obj._rules.length; ++i) {
      var test = obj._rules[i];

      if (test.name === name && !test.keep) {
        if (obj._inRuleset() && i < obj.$_temp.ruleset) {
          --obj.$_temp.ruleset;
        }

        continue;
      }

      filtered.push(test);
    }

    obj._rules = filtered;
    return obj;
  }

  _values(values, key) {
    Common.verifyFlat(values, key.slice(1, -1));
    var obj = this.clone();
    var override = values[0] === Common.symbols.override;

    if (override) {
      values = values.slice(1);
    }

    if (!obj[key] && values.length) {
      obj[key] = new Values();
    } else if (override) {
      obj[key] = values.length ? new Values() : null;
      obj.$_mutateRebuild();
    }

    if (!obj[key]) {
      return obj;
    }

    if (override) {
      obj[key].override();
    }

    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
      for (var _iterator6 = values[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        var value = _step6.value;
        Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
        Assert(value !== Common.symbols.override, 'Override must be the first value');
        var other = key === '_invalids' ? '_valids' : '_invalids';

        if (obj[other]) {
          obj[other].remove(value);

          if (!obj[other].length) {
            Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');
            obj[other] = null;
          }
        }

        obj[key].add(value, obj._refs);
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
          _iterator6.return();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }

    return obj;
  }

};
internals.Base.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects

internals.Base.prototype[Common.symbols.any] = {
  version: Common.version,
  compile: Compile.compile,
  root: '$_root'
}; // Aliases

internals.Base.prototype.deny = internals.Base.prototype.invalid;
internals.Base.prototype.disallow = internals.Base.prototype.invalid;
internals.Base.prototype.equal = internals.Base.prototype.valid;
internals.Base.prototype.exist = internals.Base.prototype.required;
internals.Base.prototype.not = internals.Base.prototype.invalid;
internals.Base.prototype.options = internals.Base.prototype.prefs;
internals.Base.prototype.preferences = internals.Base.prototype.prefs;
module.exports = new internals.Base();