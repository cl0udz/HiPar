'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Common = require('./common');

var Messages = require('./messages');

var Ref = require('./ref');

var Template = require('./template');

var Schemas;
var internals = {};

exports.describe = function (schema) {
  var def = schema._definition; // Type

  var desc = {
    type: schema.type,
    flags: {},
    rules: []
  }; // Flags

  for (var flag in schema._flags) {
    if (flag[0] !== '_') {
      desc.flags[flag] = internals.describe(schema._flags[flag]);
    }
  }

  if (!Object.keys(desc.flags).length) {
    delete desc.flags;
  } // Preferences


  if (schema._preferences) {
    desc.preferences = Clone(schema._preferences, {
      shallow: ['messages']
    });
    delete desc.preferences[Common.symbols.prefs];

    if (desc.preferences.messages) {
      desc.preferences.messages = Messages.decompile(desc.preferences.messages);
    }
  } // Allow / Invalid


  if (schema._valids) {
    desc.allow = schema._valids.describe();
  }

  if (schema._invalids) {
    desc.invalid = schema._invalids.describe();
  } // Rules


  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = schema._rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var rule = _step.value;
      var ruleDef = def.rules[rule.name];

      if (ruleDef.manifest === false) {
        // Defaults to true
        continue;
      }

      var _item2 = {
        name: rule.name
      };

      for (var custom in def.modifiers) {
        if (rule[custom] !== undefined) {
          _item2[custom] = internals.describe(rule[custom]);
        }
      }

      if (rule.args) {
        _item2.args = {};

        for (var key in rule.args) {
          var arg = rule.args[key];

          if (key === 'options' && !Object.keys(arg).length) {
            continue;
          }

          _item2.args[key] = internals.describe(arg, {
            assign: key
          });
        }

        if (!Object.keys(_item2.args).length) {
          delete _item2.args;
        }
      }

      desc.rules.push(_item2);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (!desc.rules.length) {
    delete desc.rules;
  } // Terms (must be last to verify no name conflicts)


  for (var term in schema.$_terms) {
    if (term[0] === '_') {
      continue;
    }

    Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);
    var items = schema.$_terms[term];

    if (!items) {
      continue;
    }

    if (items instanceof Map) {
      if (items.size) {
        desc[term] = _toConsumableArray(items.entries());
      }

      continue;
    }

    if (Common.isValues(items)) {
      desc[term] = items.describe();
      continue;
    }

    Assert(def.terms[term], 'Term', term, 'missing configuration');
    var manifest = def.terms[term].manifest;
    var mapped = _typeof(manifest) === 'object';

    if (!items.length && !mapped) {
      continue;
    }

    var normalized = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _item = _step2.value;
        normalized.push(internals.describe(_item));
      } // Mapped

    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    if (mapped) {
      var _manifest$mapped = manifest.mapped,
          from = _manifest$mapped.from,
          to = _manifest$mapped.to;
      desc[term] = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = normalized[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var item = _step3.value;
          desc[term][item[to]] = item[from];
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      continue;
    } // Single


    if (manifest === 'single') {
      Assert(normalized.length === 1, 'Term', term, 'contains more than one item');
      desc[term] = normalized[0];
      continue;
    } // Array


    desc[term] = normalized;
  }

  internals.validate(schema.$_root, desc);
  return desc;
};

internals.describe = function (item) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (Array.isArray(item)) {
    return item.map(internals.describe);
  }

  if (item === Common.symbols.deepDefault) {
    return {
      special: 'deep'
    };
  }

  if (_typeof(item) !== 'object') {
    return item;
  }

  if (options.assign === 'options') {
    return Clone(item);
  }

  if (Buffer && Buffer.isBuffer(item)) {
    // $lab:coverage:ignore$
    return {
      buffer: item.toString('binary')
    };
  }

  if (item instanceof Date) {
    return item.toISOString();
  }

  if (item instanceof Error) {
    return item;
  }

  if (item instanceof RegExp) {
    if (options.assign === 'regex') {
      return item.toString();
    }

    return {
      regex: item.toString()
    };
  }

  if (item[Common.symbols.literal]) {
    return {
      "function": item.literal
    };
  }

  if (typeof item.describe === 'function') {
    if (options.assign === 'ref') {
      return item.describe().ref;
    }

    return item.describe();
  }

  var normalized = {};

  for (var key in item) {
    var value = item[key];

    if (value === undefined) {
      continue;
    }

    normalized[key] = internals.describe(value, {
      assign: key
    });
  }

  return normalized;
};

exports.build = function (joi, desc) {
  var builder = new internals.Builder(joi);
  return builder.parse(desc);
};

internals.Builder =
/*#__PURE__*/
function () {
  function _class(joi) {
    _classCallCheck(this, _class);

    this.joi = joi;
  }

  _createClass(_class, [{
    key: "parse",
    value: function parse(desc) {
      var _this = this;

      internals.validate(this.joi, desc); // Type

      var schema = this.joi[desc.type]();
      var def = schema._definition; // Flags

      if (desc.flags) {
        for (var flag in desc.flags) {
          var setter = def.flags[flag] && def.flags[flag].setter || flag;
          Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);
          schema = schema[setter](this.build(desc.flags[flag]));
        }
      } // Preferences


      if (desc.preferences) {
        schema = schema.preferences(this.build(desc.preferences));
      } // Allow / Invalid


      if (desc.allow) {
        var _schema;

        schema = (_schema = schema).allow.apply(_schema, _toConsumableArray(this.build(desc.allow)));
      }

      if (desc.invalid) {
        var _schema2;

        schema = (_schema2 = schema).invalid.apply(_schema2, _toConsumableArray(this.build(desc.invalid)));
      } // Rules


      if (desc.rules) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = desc.rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _schema3;

            var rule = _step4.value;
            Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);
            var args = [];

            if (rule.args) {
              var built = {};

              for (var key in rule.args) {
                built[key] = this.build(rule.args[key], {
                  assign: key
                });
              }

              var keys = Object.keys(built);
              var definition = def.rules[rule.name].args;

              if (definition) {
                Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');
                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                  for (var _iterator5 = definition[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var name = _step5.value.name;
                    args.push(built[name]);
                  }
                } catch (err) {
                  _didIteratorError5 = true;
                  _iteratorError5 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                      _iterator5["return"]();
                    }
                  } finally {
                    if (_didIteratorError5) {
                      throw _iteratorError5;
                    }
                  }
                }
              } else {
                Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');
                args.push(built[keys[0]]);
              }
            } // Apply


            schema = (_schema3 = schema)[rule.name].apply(_schema3, args); // Ruleset

            var options = {};

            for (var custom in def.modifiers) {
              if (rule[custom] !== undefined) {
                options[custom] = this.build(rule[custom]);
              }
            }

            if (Object.keys(options).length) {
              schema = schema.rule(options);
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      } // Terms


      var terms = {};

      for (var _key in desc) {
        if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(_key)) {
          continue;
        }

        Assert(def.terms[_key], 'Term', _key, 'missing configuration');
        var manifest = def.terms[_key].manifest;

        if (manifest === 'schema') {
          terms[_key] = desc[_key].map(function (item) {
            return _this.parse(item);
          });
          continue;
        }

        if (manifest === 'values') {
          terms[_key] = desc[_key].map(function (item) {
            return _this.build(item);
          });
          continue;
        }

        if (manifest === 'single') {
          terms[_key] = this.build(desc[_key]);
          continue;
        }

        if (_typeof(manifest) === 'object') {
          terms[_key] = {};

          for (var _name in desc[_key]) {
            var value = desc[_key][_name];
            terms[_key][_name] = this.parse(value);
          }

          continue;
        }

        terms[_key] = this.build(desc[_key]);
      }

      if (desc.whens) {
        terms.whens = desc.whens.map(function (when) {
          return _this.build(when);
        });
      }

      schema = def.manifest.build(schema, terms);
      schema.$_temp.ruleset = false;
      return schema;
    }
  }, {
    key: "build",
    value: function build(desc) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (desc === null) {
        return null;
      }

      if (Array.isArray(desc)) {
        return desc.map(function (item) {
          return _this2.build(item);
        });
      }

      if (desc instanceof Error) {
        return desc;
      }

      if (options.assign === 'options') {
        return Clone(desc);
      }

      if (options.assign === 'regex') {
        return internals.regex(desc);
      }

      if (options.assign === 'ref') {
        return Ref.build(desc);
      }

      if (_typeof(desc) !== 'object') {
        return desc;
      }

      if (Object.keys(desc).length === 1) {
        if (desc.buffer) {
          Assert(Buffer, 'Buffers are not supported');
          return Buffer && Buffer.from(desc.buffer, 'binary'); // $lab:coverage:ignore$
        }

        if (desc["function"]) {
          var _ref;

          return _ref = {}, _defineProperty(_ref, Common.symbols.literal, true), _defineProperty(_ref, "literal", desc["function"]), _ref;
        }

        if (desc.override) {
          return Common.symbols.override;
        }

        if (desc.ref) {
          return Ref.build(desc.ref);
        }

        if (desc.regex) {
          return internals.regex(desc.regex);
        }

        if (desc.special) {
          Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);
          return Common.symbols.deepDefault;
        }

        if (desc.value) {
          return Clone(desc.value);
        }
      }

      if (desc.type) {
        return this.parse(desc);
      }

      if (desc.template) {
        return Template.build(desc);
      }

      var normalized = {};

      for (var key in desc) {
        normalized[key] = this.build(desc[key], {
          assign: key
        });
      }

      return normalized;
    }
  }]);

  return _class;
}();

internals.regex = function (string) {
  var end = string.lastIndexOf('/');
  var exp = string.slice(1, end);
  var flags = string.slice(end + 1);
  return new RegExp(exp, flags);
};

internals.validate = function (joi, desc) {
  Schemas = Schemas || require('./schemas');
  joi.assert(desc, Schemas.description);
};