'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Reach = require('@hapi/hoek/lib/reach');

var Common = require('./common');

var Template;
var internals = {
  symbol: Symbol('ref'),
  // Used to internally identify references (shared with other joi versions)
  defaults: {
    adjust: null,
    "in": false,
    iterables: null,
    map: null,
    separator: '.',
    type: 'value'
  }
};

exports.create = function (key) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  Assert(typeof key === 'string', 'Invalid reference key:', key);
  Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'separator']);
  Assert(!options.prefix || _typeof(options.prefix) === 'object', 'options.prefix must be of type object');
  var ref = Object.assign({}, internals.defaults, options);
  delete ref.prefix;
  var separator = ref.separator;
  var context = internals.context(key, separator, options.prefix);
  ref.type = context.type;
  key = context.key;

  if (ref.type === 'value') {
    if (context.root) {
      Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');
      ref.ancestor = 'root';

      if (!key) {
        key = null;
      }
    }

    if (separator && separator === key) {
      key = null;
      ref.ancestor = 0;
    } else {
      if (ref.ancestor !== undefined) {
        Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');
      } else {
        var _internals$ancestor = internals.ancestor(key, separator),
            _internals$ancestor2 = _slicedToArray(_internals$ancestor, 2),
            ancestor = _internals$ancestor2[0],
            slice = _internals$ancestor2[1];

        if (slice) {
          key = key.slice(slice);

          if (key === '') {
            key = null;
          }
        }

        ref.ancestor = ancestor;
      }
    }
  }

  ref.path = separator ? key === null ? [] : key.split(separator) : [key];
  return new internals.Ref(ref);
};

exports["in"] = function (key) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return exports.create(key, Object.assign({}, options, {
    "in": true
  }));
};

exports.isRef = function (ref) {
  return ref ? !!ref[Common.symbols.ref] : false;
};

internals.Ref =
/*#__PURE__*/
function () {
  function _class(options) {
    _classCallCheck(this, _class);

    Assert(_typeof(options) === 'object', 'Invalid reference construction');
    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'separator', 'type', // Copied
    'depth', 'key', 'root', 'display' // Overridden
    ]);
    Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');
    Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');
    Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');
    Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');
    Object.assign(this, internals.defaults, options);
    Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');

    if (Array.isArray(this.map)) {
      this.map = new Map(this.map);
    }

    this.depth = this.path.length;
    this.key = this.path.length ? this.path.join(this.separator) : null;
    this.root = this.path[0];
    this.updateDisplay();
  }

  _createClass(_class, [{
    key: "resolve",
    value: function resolve(value, state, prefs, local) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      Assert(!this["in"] || options["in"], 'Invalid in() reference usage');

      if (this.type === 'global') {
        return this._resolve(prefs.context, state, options);
      }

      if (this.type === 'local') {
        return this._resolve(local, state, options);
      }

      if (!this.ancestor) {
        return this._resolve(value, state, options);
      }

      if (this.ancestor === 'root') {
        return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
      }

      Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);
      return this._resolve(state.ancestors[this.ancestor - 1], state, options);
    }
  }, {
    key: "_resolve",
    value: function _resolve(target, state, options) {
      var resolved;

      if (this.type === 'value' && state.mainstay.shadow && options.shadow !== false) {
        resolved = state.mainstay.shadow.get(this.absolute(state));
      }

      if (resolved === undefined) {
        resolved = Reach(target, this.path, {
          iterables: this.iterables,
          functions: true
        });
      }

      if (this.adjust) {
        resolved = this.adjust(resolved);
      }

      if (this.map) {
        var mapped = this.map.get(resolved);

        if (mapped !== undefined) {
          resolved = mapped;
        }
      }

      if (state.mainstay) {
        state.mainstay.tracer.resolve(state, this, resolved);
      }

      return resolved;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.display;
    }
  }, {
    key: "absolute",
    value: function absolute(state) {
      return [].concat(_toConsumableArray(state.path.slice(0, -this.ancestor)), _toConsumableArray(this.path));
    }
  }, {
    key: "clone",
    value: function clone() {
      return new internals.Ref(this);
    }
  }, {
    key: "describe",
    value: function describe() {
      var ref = {
        path: this.path
      };

      if (this.type !== 'value') {
        ref.type = this.type;
      }

      if (this.separator !== '.') {
        ref.separator = this.separator;
      }

      if (this.type === 'value' && this.ancestor !== 1) {
        ref.ancestor = this.ancestor;
      }

      if (this.map) {
        ref.map = _toConsumableArray(this.map);
      }

      for (var _i2 = 0, _arr2 = ['adjust', 'iterables']; _i2 < _arr2.length; _i2++) {
        var key = _arr2[_i2];

        if (this[key] !== null) {
          ref[key] = this[key];
        }
      }

      if (this["in"] !== false) {
        ref["in"] = true;
      }

      return {
        ref: ref
      };
    }
  }, {
    key: "updateDisplay",
    value: function updateDisplay() {
      var key = this.key !== null ? this.key : '';

      if (this.type !== 'value') {
        this.display = "ref:".concat(this.type, ":").concat(key);
        return;
      }

      if (!this.separator) {
        this.display = "ref:".concat(key);
        return;
      }

      if (!this.ancestor) {
        this.display = "ref:".concat(this.separator).concat(key);
        return;
      }

      if (this.ancestor === 'root') {
        this.display = "ref:root:".concat(key);
        return;
      }

      if (this.ancestor === 1) {
        this.display = "ref:".concat(key || '..');
        return;
      }

      var lead = new Array(this.ancestor + 1).fill(this.separator).join('');
      this.display = "ref:".concat(lead).concat(key || '');
    }
  }]);

  return _class;
}();

internals.Ref.prototype[Common.symbols.ref] = true;

exports.build = function (desc) {
  desc = Object.assign({}, internals.defaults, desc);

  if (desc.type === 'value' && desc.ancestor === undefined) {
    desc.ancestor = 1;
  }

  return new internals.Ref(desc);
};

internals.context = function (key, separator) {
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  key = key.trim();
  var globalp = prefix.global === undefined ? '$' : prefix.global;

  if (globalp !== separator && key.startsWith(globalp)) {
    return {
      key: key.slice(globalp.length),
      type: 'global'
    };
  }

  var local = prefix.local === undefined ? '#' : prefix.local;

  if (local !== separator && key.startsWith(local)) {
    return {
      key: key.slice(local.length),
      type: 'local'
    };
  }

  var root = prefix.root === undefined ? '/' : prefix.root;

  if (root !== separator && key.startsWith(root)) {
    return {
      key: key.slice(root.length),
      type: 'value',
      root: true
    };
  }

  return {
    key: key,
    type: 'value'
  };
};

internals.ancestor = function (key, separator) {
  if (!separator) {
    return [1, 0]; // 'a_b' -> 1 (parent)
  }

  if (key[0] !== separator) {
    // 'a.b' -> 1 (parent)
    return [1, 0];
  }

  if (key[1] !== separator) {
    // '.a.b' -> 0 (self)
    return [0, 1];
  }

  var i = 2;

  while (key[i] === separator) {
    ++i;
  }

  return [i - 1, i]; // '...a.b.' -> 2 (grandparent)
};

exports.toSibling = 0;
exports.toParent = 1;

exports.Manager =
/*#__PURE__*/
function () {
  function _class2() {
    _classCallCheck(this, _class2);

    this.refs = []; // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...
  }

  _createClass(_class2, [{
    key: "register",
    value: function register(source, target) {
      if (!source) {
        return;
      }

      target = target === undefined ? exports.toParent : target; // Array

      if (Array.isArray(source)) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var ref = _step.value;
            this.register(ref, target);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return;
      } // Schema


      if (Common.isSchema(source)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = source._refs.refs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var item = _step2.value;

            if (item.ancestor - target >= 0) {
              this.refs.push({
                ancestor: item.ancestor - target,
                root: item.root
              });
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return;
      } // Reference


      if (exports.isRef(source) && source.type === 'value' && source.ancestor - target >= 0) {
        this.refs.push({
          ancestor: source.ancestor - target,
          root: source.root
        });
      } // Template


      Template = Template || require('./template');

      if (Template.isTemplate(source)) {
        this.register(source.refs(), target);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      var copy = new exports.Manager();
      copy.refs = Clone(this.refs);
      return copy;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.refs = [];
    }
  }, {
    key: "roots",
    value: function roots() {
      return this.refs.filter(function (ref) {
        return !ref.ancestor;
      }).map(function (ref) {
        return ref.root;
      });
    }
  }, {
    key: "length",
    get: function get() {
      return this.refs.length;
    }
  }]);

  return _class2;
}();