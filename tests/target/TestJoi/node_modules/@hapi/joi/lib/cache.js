'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Common = require('./common');

var internals = {
  max: 1000,
  supported: new Set(['undefined', 'boolean', 'number', 'string'])
};
exports.provider = {
  provision: function provision(options) {
    return new internals.Cache(options);
  }
}; // Least Recently Used (LRU) Cache

internals.Cache =
/*#__PURE__*/
function () {
  function _class() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, _class);

    Common.assertOptions(options, ['max']);
    Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');
    this._max = options.max || internals.max;
    this._map = new Map(); // Map of nodes by key

    this._list = new internals.List(); // List of nodes (most recently used in head)
  }

  _createClass(_class, [{
    key: "set",
    value: function set(key, value) {
      if (key !== null && !internals.supported.has(_typeof(key))) {
        return;
      }

      var node = this._map.get(key);

      if (node) {
        node.value = value;

        this._list.first(node);

        return;
      }

      node = this._list.unshift({
        key: key,
        value: value
      });

      this._map.set(key, node);

      this._compact();
    }
  }, {
    key: "get",
    value: function get(key) {
      var node = this._map.get(key);

      if (node) {
        this._list.first(node);

        return Clone(node.value);
      }
    }
  }, {
    key: "_compact",
    value: function _compact() {
      if (this._map.size > this._max) {
        var node = this._list.pop();

        this._map["delete"](node.key);
      }
    }
  }, {
    key: "length",
    get: function get() {
      return this._map.size;
    }
  }]);

  return _class;
}();

internals.List =
/*#__PURE__*/
function () {
  function _class2() {
    _classCallCheck(this, _class2);

    this.tail = null;
    this.head = null;
  }

  _createClass(_class2, [{
    key: "unshift",
    value: function unshift(node) {
      node.next = null;
      node.prev = this.head;

      if (this.head) {
        this.head.next = node;
      }

      this.head = node;

      if (!this.tail) {
        this.tail = node;
      }

      return node;
    }
  }, {
    key: "first",
    value: function first(node) {
      if (node === this.head) {
        return;
      }

      this._remove(node);

      this.unshift(node);
    }
  }, {
    key: "pop",
    value: function pop() {
      return this._remove(this.tail);
    }
  }, {
    key: "_remove",
    value: function _remove(node) {
      var next = node.next,
          prev = node.prev;
      next.prev = prev;

      if (prev) {
        prev.next = next;
      }

      if (node === this.tail) {
        this.tail = next;
      }

      node.prev = null;
      node.next = null;
      return node;
    }
  }]);

  return _class2;
}();