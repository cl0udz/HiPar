'use strict';

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.map");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.set");

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Common = require('./common');

var internals = {
  max: 1000,
  supported: new Set(['undefined', 'boolean', 'number', 'string'])
};
exports.provider = {
  provision(options) {
    return new internals.Cache(options);
  }

}; // Least Recently Used (LRU) Cache

internals.Cache = class {
  constructor() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    Common.assertOptions(options, ['max']);
    Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');
    this._max = options.max || internals.max;
    this._map = new Map(); // Map of nodes by key

    this._list = new internals.List(); // List of nodes (most recently used in head)
  }

  get length() {
    return this._map.size;
  }

  set(key, value) {
    if (key !== null && !internals.supported.has(typeof key)) {
      return;
    }

    var node = this._map.get(key);

    if (node) {
      node.value = value;

      this._list.first(node);

      return;
    }

    node = this._list.unshift({
      key,
      value
    });

    this._map.set(key, node);

    this._compact();
  }

  get(key) {
    var node = this._map.get(key);

    if (node) {
      this._list.first(node);

      return Clone(node.value);
    }
  }

  _compact() {
    if (this._map.size > this._max) {
      var node = this._list.pop();

      this._map.delete(node.key);
    }
  }

};
internals.List = class {
  constructor() {
    this.tail = null;
    this.head = null;
  }

  unshift(node) {
    node.next = null;
    node.prev = this.head;

    if (this.head) {
      this.head.next = node;
    }

    this.head = node;

    if (!this.tail) {
      this.tail = node;
    }

    return node;
  }

  first(node) {
    if (node === this.head) {
      return;
    }

    this._remove(node);

    this.unshift(node);
  }

  pop() {
    return this._remove(this.tail);
  }

  _remove(node) {
    var next = node.next,
        prev = node.prev;
    next.prev = prev;

    if (prev) {
      prev.next = next;
    }

    if (node === this.tail) {
      this.tail = next;
    }

    node.prev = null;
    node.next = null;
    return node;
  }

};