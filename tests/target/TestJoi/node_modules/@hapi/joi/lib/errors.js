'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.sort");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.flags");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.trim");

var Clone = require('@hapi/hoek/lib/clone');

var Common = require('./common');

var Template = require('./template');

var internals = {
  annotations: Symbol('annotations')
};
exports.Report = class {
  constructor(code, value, local, flags, messages, state, prefs) {
    this.code = code;
    this.flags = flags;
    this.messages = messages;
    this.path = state.path;
    this.prefs = prefs;
    this.state = state;
    this.value = value;
    this.message = null;
    this.template = null;
    this.local = local || {};
    this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);

    if (this.value !== undefined && !this.local.hasOwnProperty('value')) {
      this.local.value = this.value;
    }

    if (this.path.length) {
      var key = this.path[this.path.length - 1];

      if (typeof key !== 'object') {
        this.local.key = key;
      }
    }
  }

  _setTemplate(template) {
    this.template = template;

    if (!this.flags.label && this.path.length === 0) {
      var localized = this._template(this.template, 'root');

      if (localized) {
        this.local.label = localized;
      }
    }
  }

  toString() {
    if (this.message) {
      return this.message;
    }

    var code = this.code;

    if (!this.prefs.errors.render) {
      return this.code;
    }

    var template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);

    if (template === undefined) {
      return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
    } // Render and cache result


    this.message = template.render(this.value, this.state, this.prefs, this.local, {
      errors: this.prefs.errors,
      messages: [this.prefs.messages, this.messages]
    });

    if (!this.prefs.errors.label) {
      this.message = this.message.replace(/^"" /, '').trim();
    }

    return this.message;
  }

  _template(messages, code) {
    return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
  }

};

exports.path = function (path) {
  var label = '';
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var segment = _step.value;

      if (typeof segment === 'object') {
        // Exclude array single path segment
        continue;
      }

      if (typeof segment === 'string') {
        if (label) {
          label += '.';
        }

        label += segment;
      } else {
        label += `[${segment}]`;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return label;
};

exports.template = function (value, messages, code, state, prefs) {
  if (!messages) {
    return;
  }

  if (Template.isTemplate(messages)) {
    return code !== 'root' ? messages : null;
  }

  var lang = prefs.errors.language;

  if (Common.isResolvable(lang)) {
    lang = lang.resolve(value, state, prefs);
  }

  if (lang && messages[lang] && messages[lang][code] !== undefined) {
    return messages[lang][code];
  }

  return messages[code];
};

exports.label = function (flags, state, prefs, messages) {
  if (flags.label) {
    return flags.label;
  }

  if (!prefs.errors.label) {
    return '';
  }

  var path = state.path;

  if (prefs.errors.label === 'key' && state.path.length > 1) {
    path = state.path.slice(-1);
  }

  return exports.path(path) || exports.template(null, prefs.messages, 'root', state, prefs) || messages && exports.template(null, messages, 'root', state, prefs) || 'value';
};

exports.process = function (errors, original, prefs) {
  if (!errors) {
    return null;
  }

  var _exports$details = exports.details(errors),
      override = _exports$details.override,
      message = _exports$details.message,
      details = _exports$details.details;

  if (override) {
    return override;
  }

  if (prefs.errors.stack) {
    return new exports.ValidationError(message, details, original);
  }

  var limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  var validationError = new exports.ValidationError(message, details, original);
  Error.stackTraceLimit = limit;
  return validationError;
};

exports.details = function (errors) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var messages = [];
  var details = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var item = _step2.value;

      // Override
      if (item instanceof Error) {
        if (options.override !== false) {
          return {
            override: item
          };
        }

        var _message = item.toString();

        messages.push(_message);
        details.push({
          message: _message,
          type: 'override',
          context: {
            error: item
          }
        });
        continue;
      } // Report


      var message = item.toString();
      messages.push(message);
      details.push({
        message,
        path: item.path.filter(function (v) {
          return typeof v !== 'object';
        }),
        type: item.code,
        context: item.local
      });
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (messages.length > 1) {
    messages = [...new Set(messages)];
  }

  return {
    message: messages.join('. '),
    details
  };
};

exports.ValidationError = class extends Error {
  constructor(message, details, original) {
    super(message);
    this._original = original;
    this.details = details;
  }

  annotate(stripColorCodes) {
    if (!this._original || typeof this._original !== 'object') {
      return this.details[0].message;
    }

    var redFgEscape = stripColorCodes ? '' : '\u001b[31m';
    var redBgEscape = stripColorCodes ? '' : '\u001b[41m';
    var endColor = stripColorCodes ? '' : '\u001b[0m';
    var obj = Clone(this._original);

    for (var i = this.details.length - 1; i >= 0; --i) {
      // Reverse order to process deepest child first
      var pos = i + 1;
      var error = this.details[i];
      var path = error.path;
      var node = obj;

      for (var j = 0;; ++j) {
        var seg = path[j];

        if (Common.isSchema(node)) {
          node = node.clone(); // joi schemas are not cloned by hoek, we have to take this extra step
        }

        if (j + 1 < path.length && typeof node[seg] !== 'string') {
          node = node[seg];
        } else {
          var refAnnotations = node[internals.annotations] || {
            errors: {},
            missing: {}
          };
          node[internals.annotations] = refAnnotations;
          var cacheKey = seg || error.context.key;

          if (node[seg] !== undefined) {
            refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
            refAnnotations.errors[cacheKey].push(pos);
          } else {
            refAnnotations.missing[cacheKey] = pos;
          }

          break;
        }
      }
    }

    var replacers = {
      key: /_\$key\$_([, \d]+)_\$end\$_"/g,
      missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
      arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
      specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };
    var message = internals.safeStringify(obj, 2).replace(replacers.key, function ($0, $1) {
      return `" ${redFgEscape}[${$1}]${endColor}`;
    }).replace(replacers.missing, function ($0, $1, $2) {
      return `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`;
    }).replace(replacers.arrayIndex, function ($0, $1, $2) {
      return `\n${$2} ${redFgEscape}[${$1}]${endColor}`;
    }).replace(replacers.specials, function ($0, $1) {
      return $1;
    });
    message = `${message}\n${redFgEscape}`;

    for (var _i = 0; _i < this.details.length; ++_i) {
      var _pos = _i + 1;

      message = `${message}\n[${_pos}] ${this.details[_i].message}`;
    }

    message = message + endColor;
    return message;
  }

};
exports.ValidationError.prototype.isJoi = true;
exports.ValidationError.prototype.name = 'ValidationError'; // Inspired by json-stringify-safe

internals.safeStringify = function (obj, spaces) {
  return JSON.stringify(obj, internals.serializer(), spaces);
};

internals.serializer = function () {
  var keys = [];
  var stack = [];

  var cycleReplacer = function cycleReplacer(key, value) {
    if (stack[0] === value) {
      return '[Circular ~]';
    }

    return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
  };

  return function (key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this);

      if (~thisPos) {
        stack.length = thisPos + 1;
        keys.length = thisPos + 1;
        keys[thisPos] = key;
      } else {
        stack.push(this);
        keys.push(key);
      }

      if (~stack.indexOf(value)) {
        value = cycleReplacer.call(this, key, value);
      }
    } else {
      stack.push(value);
    }

    if (value) {
      var annotations = value[internals.annotations];

      if (annotations) {
        if (Array.isArray(value)) {
          var annotated = [];

          for (var i = 0; i < value.length; ++i) {
            if (annotations.errors[i]) {
              annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);
            }

            annotated.push(value[i]);
          }

          value = annotated;
        } else {
          for (var errorKey in annotations.errors) {
            value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];
            value[errorKey] = undefined;
          }

          for (var missingKey in annotations.missing) {
            value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';
          }
        }

        return value;
      }
    }

    if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === 'function' || typeof value === 'symbol') {
      return '[' + value.toString() + ']';
    }

    return value;
  };
};