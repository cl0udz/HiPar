'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Assert = require('@hapi/hoek/lib/assert');

var AssertError = require('@hapi/hoek/lib/error');

var Pkg = require('../package.json');

var Messages;
var Schemas;
var internals = {
  isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
};
exports.version = Pkg.version;
exports.defaults = {
  abortEarly: true,
  allowUnknown: false,
  cache: true,
  context: null,
  convert: true,
  dateFormat: 'iso',
  errors: {
    escapeHtml: false,
    label: 'path',
    language: null,
    render: true,
    stack: false,
    wrapArrays: true
  },
  externals: true,
  messages: {},
  nonEnumerables: false,
  noDefaults: false,
  presence: 'optional',
  skipFunctions: false,
  stripUnknown: false,
  warnings: false
};
exports.symbols = {
  any: Symbol["for"]('@hapi/joi/schema'),
  // Used to internally identify any-based types (shared with other joi versions)
  arraySingle: Symbol('arraySingle'),
  deepDefault: Symbol('deepDefault'),
  literal: Symbol('literal'),
  override: Symbol('override'),
  prefs: Symbol('prefs'),
  ref: Symbol('ref'),
  values: Symbol('values'),
  template: Symbol('template')
};

exports.assertOptions = function (options, keys) {
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Options';
  Assert(options && _typeof(options) === 'object' && !Array.isArray(options), 'Options must be of type object');
  var unknownKeys = Object.keys(options).filter(function (k) {
    return !keys.includes(k);
  });
  Assert(unknownKeys.length === 0, "".concat(name, " contain unknown keys: ").concat(unknownKeys));
};

exports.checkPreferences = function (prefs) {
  Schemas = Schemas || require('./schemas');
  var result = Schemas.preferences.validate(prefs);

  if (result.error) {
    throw new AssertError([result.error.details[0].message]);
  }
};

exports.compare = function (a, b, operator) {
  switch (operator) {
    case '=':
      return a === b;

    case '>':
      return a > b;

    case '<':
      return a < b;

    case '>=':
      return a >= b;

    case '<=':
      return a <= b;
  }
};

exports["default"] = function (value, defaultValue) {
  return value === undefined ? defaultValue : value;
};

exports.isIsoDate = function (date) {
  return internals.isoDate.test(date);
};

exports.isNumber = function (value) {
  return typeof value === 'number' && !isNaN(value);
};

exports.isResolvable = function (obj) {
  if (!obj) {
    return false;
  }

  return obj[exports.symbols.ref] || obj[exports.symbols.template];
};

exports.isSchema = function (schema) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var any = schema && schema[exports.symbols.any];

  if (!any) {
    return false;
  }

  Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');
  return true;
};

exports.isValues = function (obj) {
  return obj[exports.symbols.values];
};

exports.limit = function (value) {
  return Number.isSafeInteger(value) && value >= 0;
};

exports.preferences = function (target, source) {
  Messages = Messages || require('./messages');
  target = target || {};
  source = source || {};
  var merged = Object.assign({}, target, source);

  if (source.errors && target.errors) {
    merged.errors = Object.assign({}, target.errors, source.errors);
  }

  if (source.messages) {
    merged.messages = Messages.compile(source.messages, target.messages);
  }

  delete merged[exports.symbols.prefs];
  return merged;
};

exports.tryWithPath = function (fn, key) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  try {
    return fn();
  } catch (err) {
    if (err.path !== undefined) {
      err.path = key + '.' + err.path;
    } else {
      err.path = key;
    }

    if (options.append) {
      err.message = "".concat(err.message, " (").concat(err.path, ")");
    }

    throw err;
  }
};

exports.validateArg = function (value, label, _ref) {
  var assert = _ref.assert,
      message = _ref.message;

  if (exports.isSchema(assert)) {
    var result = assert.validate(value);

    if (!result.error) {
      return;
    }

    return result.error.message;
  } else if (!assert(value)) {
    return label ? "".concat(label, " ").concat(message) : message;
  }
};

exports.verifyFlat = function (args, method) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var arg = _step.value;
      Assert(!Array.isArray(arg), 'Method no longer accepts array arguments:', method);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};