'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Assert = require('@hapi/hoek/lib/assert');

var Common = require('./common');

var Ref = require('./ref');

var internals = {};

exports.schema = function (Joi, config) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Common.assertOptions(options, ['appendPath', 'override']);

  try {
    return internals.schema(Joi, config, options);
  } catch (err) {
    if (options.appendPath && err.path !== undefined) {
      err.message = "".concat(err.message, " (").concat(err.path, ")");
    }

    throw err;
  }
};

internals.schema = function (Joi, config, options) {
  Assert(config !== undefined, 'Invalid undefined schema');

  if (Array.isArray(config)) {
    Assert(config.length, 'Invalid empty array schema');

    if (config.length === 1) {
      config = config[0];
    }
  }

  var valid = function valid(base) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    if (options.override !== false) {
      return base.valid.apply(base, [Joi.override].concat(values));
    }

    return base.valid.apply(base, values);
  };

  if (internals.simple(config)) {
    return valid(Joi, config);
  }

  if (typeof config === 'function') {
    return Joi.custom(config);
  }

  Assert(_typeof(config) === 'object', 'Invalid schema content:', _typeof(config));

  if (Common.isResolvable(config)) {
    return valid(Joi, config);
  }

  if (Common.isSchema(config)) {
    return config;
  }

  if (Array.isArray(config)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = config[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;

        if (!internals.simple(item)) {
          var _Joi$alternatives;

          return (_Joi$alternatives = Joi.alternatives())["try"].apply(_Joi$alternatives, _toConsumableArray(config));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return valid.apply(void 0, [Joi].concat(_toConsumableArray(config)));
  }

  if (config instanceof RegExp) {
    return Joi.string().regex(config);
  }

  if (config instanceof Date) {
    return valid(Joi.date(), config);
  }

  Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');
  return Joi.object().keys(config);
};

exports.ref = function (id, options) {
  return Ref.isRef(id) ? id : Ref.create(id, options);
};

exports.compile = function (root, schema) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Common.assertOptions(options, ['legacy']); // Compiled by any supported version

  var any = schema && schema[Common.symbols.any];

  if (any) {
    Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas');
    return schema;
  } // Uncompiled root


  if (_typeof(schema) !== 'object' || !options.legacy) {
    return exports.schema(root, schema, {
      appendPath: true
    }); // Will error if schema contains other versions
  } // Scan schema for compiled parts


  var compiler = internals.walk(schema);

  if (!compiler) {
    return exports.schema(root, schema, {
      appendPath: true
    });
  }

  return compiler.compile(compiler.root, schema);
};

internals.walk = function (schema) {
  if (_typeof(schema) !== 'object') {
    return null;
  }

  if (Array.isArray(schema)) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = schema[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var item = _step2.value;
        var compiler = internals.walk(item);

        if (compiler) {
          return compiler;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return null;
  }

  var any = schema[Common.symbols.any];

  if (any) {
    return {
      root: schema[any.root],
      compile: any.compile
    };
  }

  Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');

  for (var key in schema) {
    var _compiler = internals.walk(schema[key]);

    if (_compiler) {
      return _compiler;
    }
  }

  return null;
};

internals.simple = function (value) {
  return value === null || ['boolean', 'string', 'number'].includes(_typeof(value));
};

exports.when = function (schema, condition, options) {
  if (options === undefined) {
    Assert(condition && _typeof(condition) === 'object', 'Missing options');
    options = condition;
    condition = Ref.create('.');
  }

  if (Array.isArray(options)) {
    options = {
      "switch": options
    };
  }

  Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']); // Schema condition

  if (Common.isSchema(condition)) {
    Assert(options.is === undefined, '"is" can not be used with a schema condition');
    Assert(options.not === undefined, '"not" can not be used with a schema condition');
    Assert(options["switch"] === undefined, '"switch" can not be used with a schema condition');
    return internals.condition(schema, {
      is: condition,
      then: options.then,
      otherwise: options.otherwise,
      "break": options["break"]
    });
  } // Single condition


  Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);
  Assert(options.not === undefined || options.is === undefined, 'Cannot combine "is" with "not"');

  if (options["switch"] === undefined) {
    var _rule = options;

    if (options.not !== undefined) {
      _rule = {
        is: options.not,
        then: options.otherwise,
        otherwise: options.then,
        "break": options["break"]
      };
    }

    var is = _rule.is !== undefined ? schema.$_compile(_rule.is) : schema.$_root.invalid(null, false, 0, '').required();
    Assert(_rule.then !== undefined || _rule.otherwise !== undefined, 'options must have at least one of "then", "otherwise", or "switch"');
    Assert(_rule["break"] === undefined || _rule.then === undefined || _rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');

    if (options.is !== undefined && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
      is = is.required(); // Only apply required if this wasn't already a schema or a ref
    }

    return internals.condition(schema, {
      ref: exports.ref(condition),
      is: is,
      then: _rule.then,
      otherwise: _rule.otherwise,
      "break": _rule["break"]
    });
  } // Switch statement


  Assert(Array.isArray(options["switch"]), '"switch" must be an array');
  Assert(options.is === undefined, 'Cannot combine "switch" with "is"');
  Assert(options.not === undefined, 'Cannot combine "switch" with "not"');
  Assert(options.then === undefined, 'Cannot combine "switch" with "then"');
  var rule = {
    ref: exports.ref(condition),
    "switch": [],
    "break": options["break"]
  };

  for (var i = 0; i < options["switch"].length; ++i) {
    var test = options["switch"][i];
    var last = i === options["switch"].length - 1;
    Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);
    Assert(test.is !== undefined, 'Switch statement missing "is"');
    Assert(test.then !== undefined, 'Switch statement missing "then"');
    var item = {
      is: schema.$_compile(test.is),
      then: schema.$_compile(test.then)
    };

    if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
      item.is = item.is.required(); // Only apply required if this wasn't already a schema or a ref
    }

    if (last) {
      Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify "otherwise" inside and outside a "switch"');
      var otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;

      if (otherwise !== undefined) {
        Assert(rule["break"] === undefined, 'Cannot specify both otherwise and break');
        item.otherwise = schema.$_compile(otherwise);
      }
    }

    rule["switch"].push(item);
  }

  return rule;
};

internals.condition = function (schema, condition) {
  for (var _i = 0, _arr = ['then', 'otherwise']; _i < _arr.length; _i++) {
    var key = _arr[_i];

    if (condition[key] === undefined) {
      delete condition[key];
    } else {
      condition[key] = schema.$_compile(condition[key]);
    }
  }

  return condition;
};