'use strict';

var Assert = require('@hapi/hoek/lib/assert');

var Any = require('./any');

var Common = require('../common');

var internals = {};
module.exports = Any.extend({
  type: 'binary',
  coerce: {
    from: 'string',
    method: function method(value, _ref) {
      var schema = _ref.schema;

      try {
        return {
          value: Buffer.from(value, schema._flags.encoding)
        };
      } catch (ignoreErr) {}
    }
  },
  validate: function validate(value, _ref2) {
    var error = _ref2.error;

    if (!Buffer.isBuffer(value)) {
      return {
        value: value,
        errors: error('binary.base')
      };
    }
  },
  rules: {
    encoding: {
      method: function method(encoding) {
        Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);
        return this.$_setFlag('encoding', encoding);
      }
    },
    length: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'length',
          method: 'length',
          args: {
            limit: limit
          },
          operator: '='
        });
      },
      validate: function validate(value, helpers, _ref3, _ref4) {
        var limit = _ref3.limit;
        var name = _ref4.name,
            operator = _ref4.operator,
            args = _ref4.args;

        if (Common.compare(value.length, limit, operator)) {
          return value;
        }

        return helpers.error('binary.' + name, {
          limit: args.limit,
          value: value
        });
      },
      args: [{
        name: 'limit',
        ref: true,
        assert: Common.limit,
        message: 'must be a positive integer'
      }]
    },
    max: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'max',
          method: 'length',
          args: {
            limit: limit
          },
          operator: '<='
        });
      }
    },
    min: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'min',
          method: 'length',
          args: {
            limit: limit
          },
          operator: '>='
        });
      }
    }
  },
  cast: {
    string: {
      from: function from(value) {
        return Buffer.isBuffer(value);
      },
      to: function to(value, helpers) {
        return value.toString();
      }
    }
  },
  messages: {
    'binary.base': '"{{#label}}" must be a buffer or a string',
    'binary.length': '"{{#label}}" must be {{#limit}} bytes',
    'binary.max': '"{{#label}}" must be less than or equal to {{#limit}} bytes',
    'binary.min': '"{{#label}}" must be at least {{#limit}} bytes'
  }
});