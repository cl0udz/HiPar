'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.map");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.flags");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.match");

var ApplyToDefaults = require('@hapi/hoek/lib/applyToDefaults');

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Topo = require('@hapi/topo');

var Any = require('./any');

var Common = require('../common');

var Compile = require('../compile');

var Errors = require('../errors');

var Ref = require('../ref');

var Template = require('../template');

var internals = {
  renameDefaults: {
    alias: false,
    // Keep old value in place
    multiple: false,
    // Allow renaming multiple keys into the same target
    override: false // Overrides an existing key

  }
};
module.exports = Any.extend({
  type: '_keys',
  properties: {
    typeof: 'object'
  },
  flags: {
    unknown: {
      default: false
    }
  },
  terms: {
    dependencies: {
      init: null
    },
    keys: {
      init: null,
      manifest: {
        mapped: {
          from: 'schema',
          to: 'key'
        }
      }
    },
    patterns: {
      init: null
    },
    renames: {
      init: null
    }
  },

  args(schema, keys) {
    return schema.keys(keys);
  },

  validate(value, _ref) {
    var schema = _ref.schema,
        error = _ref.error,
        state = _ref.state,
        prefs = _ref.prefs;

    if (!value || typeof value !== schema.$_property('typeof') || Array.isArray(value)) {
      return {
        value,
        errors: error('object.base', {
          type: schema.$_property('typeof')
        })
      };
    } // Skip if there are no other rules to test


    if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys
    !schema.$_terms.patterns && !schema.$_terms.externals) {
      return;
    } // Shallow clone value


    value = internals.clone(value, prefs);
    var errors = []; // Rename keys

    if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
      return {
        value,
        errors
      };
    } // Anything allowed


    if (!schema.$_terms.keys && // null allows any keys
    !schema.$_terms.patterns && !schema.$_terms.dependencies) {
      return {
        value,
        errors
      };
    } // Defined keys


    var unprocessed = new Set(Object.keys(value));

    if (schema.$_terms.keys) {
      var ancestors = [value, ...state.ancestors];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = schema.$_terms.keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          var key = child.key;
          var item = value[key];
          unprocessed.delete(key);
          var localState = state.localize([...state.path, key], ancestors, child);
          var result = child.schema.$_validate(item, localState, prefs);

          if (result.errors) {
            if (prefs.abortEarly) {
              return {
                value,
                errors: result.errors
              };
            }

            errors.push(...result.errors);
          } else if (child.schema._flags.result === 'strip' || result.value === undefined && item !== undefined) {
            delete value[key];
          } else if (result.value !== undefined) {
            value[key] = result.value;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } // Unknown keys


    if (unprocessed.size) {
      var early = internals.unknown(schema, value, unprocessed, errors, state, prefs);

      if (early) {
        return early;
      }
    } // Validate dependencies


    if (schema.$_terms.dependencies) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = schema.$_terms.dependencies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var dep = _step2.value;

          if (dep.key && dep.key.resolve(value, state, prefs, null, {
            shadow: false
          }) === undefined) {
            continue;
          }

          var failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);

          if (failed) {
            var report = schema.$_createError(failed.code, value, failed.context, state, prefs);

            if (prefs.abortEarly) {
              return {
                value,
                errors: report
              };
            }

            errors.push(report);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    return {
      value,
      errors
    };
  },

  rules: {
    and: {
      method()
      /*, [options] */
      {
        for (var _len = arguments.length, peers = new Array(_len), _key = 0; _key < _len; _key++) {
          peers[_key] = arguments[_key];
        }

        Common.verifyFlat(peers, 'and');
        return internals.dependency(this, 'and', null, peers);
      }

    },
    append: {
      method(schema) {
        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
          return this;
        }

        return this.keys(schema);
      }

    },
    assert: {
      method(subject, schema, message) {
        if (!Template.isTemplate(subject)) {
          subject = Compile.ref(subject);
        }

        Assert(message === undefined || typeof message === 'string', 'Message must be a string');
        schema = this.$_compile(schema, {
          appendPath: true
        });
        var obj = this.$_addRule({
          name: 'assert',
          args: {
            subject,
            schema,
            message
          }
        });
        obj.$_mutateRegister(subject);
        obj.$_mutateRegister(schema);
        return obj;
      },

      validate(value, _ref2, _ref3) {
        var error = _ref2.error,
            prefs = _ref2.prefs,
            state = _ref2.state;
        var subject = _ref3.subject,
            schema = _ref3.schema,
            message = _ref3.message;
        var about = subject.resolve(value, state, prefs);
        var path = Ref.isRef(subject) ? subject.absolute(state) : [];

        if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {
          return value;
        }

        return error('object.assert', {
          subject,
          message
        });
      },

      args: ['subject', 'schema', 'message'],
      multi: true
    },
    instance: {
      method(constructor, name) {
        Assert(typeof constructor === 'function', 'constructor must be a function');
        name = name || constructor.name;
        return this.$_addRule({
          name: 'instance',
          args: {
            constructor,
            name
          }
        });
      },

      validate(value, helpers, _ref4) {
        var constructor = _ref4.constructor,
            name = _ref4.name;

        if (value instanceof constructor) {
          return value;
        }

        return helpers.error('object.instance', {
          type: name,
          value
        });
      },

      args: ['constructor', 'name']
    },
    keys: {
      method(schema) {
        var _this = this;

        Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
        Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');
        var obj = this.clone();

        if (!schema) {
          // Allow all
          obj.$_terms.keys = null;
        } else if (!Object.keys(schema).length) {
          // Allow none
          obj.$_terms.keys = [];
        } else {
          obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter(function (child) {
            return !schema.hasOwnProperty(child.key);
          }) : [];

          var _loop = function _loop(key) {
            Common.tryWithPath(function () {
              return obj.$_terms.keys.push({
                key,
                schema: _this.$_compile(schema[key])
              });
            }, key);
          };

          for (var key in schema) {
            _loop(key);
          }
        }

        return obj.$_mutateRebuild();
      }

    },
    length: {
      method(limit) {
        return this.$_addRule({
          name: 'length',
          args: {
            limit
          },
          operator: '='
        });
      },

      validate(value, helpers, _ref5, _ref6) {
        var limit = _ref5.limit;
        var name = _ref6.name,
            operator = _ref6.operator,
            args = _ref6.args;

        if (Common.compare(Object.keys(value).length, limit, operator)) {
          return value;
        }

        return helpers.error('object.' + name, {
          limit: args.limit,
          value
        });
      },

      args: [{
        name: 'limit',
        ref: true,
        assert: Common.limit,
        message: 'must be a positive integer'
      }]
    },
    max: {
      method(limit) {
        return this.$_addRule({
          name: 'max',
          method: 'length',
          args: {
            limit
          },
          operator: '<='
        });
      }

    },
    min: {
      method(limit) {
        return this.$_addRule({
          name: 'min',
          method: 'length',
          args: {
            limit
          },
          operator: '>='
        });
      }

    },
    nand: {
      method()
      /*, [options] */
      {
        for (var _len2 = arguments.length, peers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          peers[_key2] = arguments[_key2];
        }

        Common.verifyFlat(peers, 'nand');
        return internals.dependency(this, 'nand', null, peers);
      }

    },
    or: {
      method()
      /*, [options] */
      {
        for (var _len3 = arguments.length, peers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          peers[_key3] = arguments[_key3];
        }

        Common.verifyFlat(peers, 'or');
        return internals.dependency(this, 'or', null, peers);
      }

    },
    oxor: {
      method()
      /*, [options] */
      {
        for (var _len4 = arguments.length, peers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          peers[_key4] = arguments[_key4];
        }

        return internals.dependency(this, 'oxor', null, peers);
      }

    },
    pattern: {
      method(pattern, schema) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isRegExp = pattern instanceof RegExp;

        if (!isRegExp) {
          pattern = this.$_compile(pattern, {
            appendPath: true
          });
        }

        Assert(schema !== undefined, 'Invalid rule');
        Common.assertOptions(options, ['fallthrough', 'matches']);

        if (isRegExp) {
          Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
        }

        schema = this.$_compile(schema, {
          appendPath: true
        });
        var obj = this.clone();
        obj.$_terms.patterns = obj.$_terms.patterns || [];
        var config = {
          [isRegExp ? 'regex' : 'schema']: pattern,
          rule: schema
        };

        if (options.matches) {
          config.matches = this.$_compile(options.matches);

          if (config.matches.type !== 'array') {
            config.matches = config.matches.$_root.array().items(config.matches);
          }

          obj.$_mutateRegister(config.matches);
        }

        if (options.fallthrough) {
          config.fallthrough = true;
        }

        obj.$_terms.patterns.push(config);
        obj.$_mutateRegister(schema);
        return obj;
      }

    },
    ref: {
      method() {
        return this.$_addRule('ref');
      },

      validate(value, helpers) {
        if (Ref.isRef(value)) {
          return value;
        }

        return helpers.error('object.refType', {
          value
        });
      }

    },
    rename: {
      method(from, to) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
        Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');
        Assert(to !== from, 'Cannot rename key to same name:', from);
        Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);
        var obj = this.clone();
        obj.$_terms.renames = obj.$_terms.renames || [];
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = obj.$_terms.renames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var rename = _step3.value;
            Assert(rename.from !== from, 'Cannot rename the same key multiple times');
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        if (to instanceof Template) {
          obj.$_mutateRegister(to);
        }

        obj.$_terms.renames.push({
          from,
          to,
          options: ApplyToDefaults(internals.renameDefaults, options)
        });
        return obj;
      }

    },
    schema: {
      method() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'any';
        return this.$_addRule({
          name: 'schema',
          args: {
            type
          }
        });
      },

      validate(value, helpers, _ref7) {
        var type = _ref7.type;

        if (Common.isSchema(value) && (type === 'any' || value.type === type)) {
          return value;
        }

        return helpers.error('object.schema', {
          type
        });
      }

    },
    unknown: {
      method(allow) {
        return this.$_setFlag('unknown', allow !== false);
      }

    },
    with: {
      method(key, peers) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return internals.dependency(this, 'with', key, peers, options);
      }

    },
    without: {
      method(key, peers) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return internals.dependency(this, 'without', key, peers, options);
      }

    },
    xor: {
      method()
      /*, [options] */
      {
        for (var _len5 = arguments.length, peers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          peers[_key5] = arguments[_key5];
        }

        Common.verifyFlat(peers, 'xor');
        return internals.dependency(this, 'xor', null, peers);
      }

    }
  },
  overrides: {
    default(value, options) {
      if (value === undefined) {
        value = Common.symbols.deepDefault;
      }

      return this.$_super.default(value, options);
    }

  },

  rebuild(schema) {
    if (schema.$_terms.keys) {
      (function () {
        var topo = new Topo();
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          var _loop2 = function _loop2() {
            var child = _step4.value;
            Common.tryWithPath(function () {
              return topo.add(child, {
                after: child.schema.$_rootReferences(),
                group: child.key
              });
            }, child.key);
          };

          for (var _iterator4 = schema.$_terms.keys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            _loop2();
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        schema.$_terms.keys = new internals.Keys(...topo.nodes);
      })();
    }
  },

  manifest: {
    build(obj, desc) {
      if (desc.keys) {
        obj = obj.keys(desc.keys);
      }

      if (desc.dependencies) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = desc.dependencies[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _step5$value = _step5.value,
                rel = _step5$value.rel,
                _step5$value$key = _step5$value.key,
                key = _step5$value$key === void 0 ? null : _step5$value$key,
                peers = _step5$value.peers,
                options = _step5$value.options;
            obj = internals.dependency(obj, rel, key, peers, options);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }

      if (desc.patterns) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = desc.patterns[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var _step6$value = _step6.value,
                regex = _step6$value.regex,
                schema = _step6$value.schema,
                rule = _step6$value.rule,
                fallthrough = _step6$value.fallthrough,
                matches = _step6$value.matches;
            obj = obj.pattern(regex || schema, rule, {
              fallthrough,
              matches
            });
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }

      if (desc.renames) {
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = desc.renames[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var _step7$value = _step7.value,
                from = _step7$value.from,
                to = _step7$value.to,
                _options = _step7$value.options;
            obj = obj.rename(from, to, _options);
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
              _iterator7.return();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }
      }

      return obj;
    }

  },
  messages: {
    'object.and': '"{{#label}}" contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',
    'object.assert': '"{{#label}}" is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
    'object.base': '"{{#label}}" must be of type {{#type}}',
    'object.instance': '"{{#label}}" must be an instance of "{{#type}}"',
    'object.length': '"{{#label}}" must have {{#limit}} key{if(#limit == 1, "", "s")}',
    'object.max': '"{{#label}}" must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
    'object.min': '"{{#label}}" must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
    'object.missing': '"{{#label}}" must contain at least one of {{#peersWithLabels}}',
    'object.nand': '"{{#mainWithLabel}}" must not exist simultaneously with {{#peersWithLabels}}',
    'object.oxor': '"{{#label}}" contains a conflict between optional exclusive peers {{#peersWithLabels}}',
    'object.pattern.match': '"{{#label}}" keys failed to match pattern requirements',
    'object.refType': '"{{#label}}" must be a Joi reference',
    'object.rename.multiple': '"{{#label}}" cannot rename "{{#from}}" because multiple renames are disabled and another key was already renamed to "{{#to}}"',
    'object.rename.override': '"{{#label}}" cannot rename "{{#from}}" because override is disabled and target "{{#to}}" exists',
    'object.schema': '"{{#label}}" must be a Joi schema of {{#type}} type',
    'object.unknown': '"{{#label}}" is not allowed',
    'object.with': '"{{#mainWithLabel}}" missing required peer "{{#peerWithLabel}}"',
    'object.without': '"{{#mainWithLabel}}" conflict with forbidden peer "{{#peerWithLabel}}"',
    'object.xor': '"{{#label}}" contains a conflict between exclusive peers {{#peersWithLabels}}'
  }
}); // Helpers

internals.clone = function (value, prefs) {
  // Object
  if (typeof value === 'object') {
    if (prefs.nonEnumerables) {
      return Clone(value, {
        shallow: true
      });
    }

    var _clone = Object.create(Object.getPrototypeOf(value));

    Object.assign(_clone, value);
    return _clone;
  } // Function


  var clone = function clone() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return value.apply(this, args);
  };

  clone.prototype = Clone(value.prototype);
  Object.defineProperty(clone, 'name', {
    value: value.name,
    writable: false
  });
  Object.defineProperty(clone, 'length', {
    value: value.length,
    writable: false
  });
  Object.assign(clone, value);
  return clone;
};

internals.dependency = function (schema, rel, key, peers, options) {
  Assert(key === null || typeof key === 'string', rel, 'key must be a strings'); // Extract options from peers array

  if (!options) {
    options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};
  }

  Common.assertOptions(options, ['separator']);
  peers = [].concat(peers); // Cast peer paths

  var separator = Common.default(options.separator, '.');
  var paths = [];
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = peers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var peer = _step8.value;
      Assert(typeof peer === 'string', rel, 'peers must be a string or a reference');
      paths.push(Compile.ref(peer, {
        separator,
        ancestor: 0
      }));
    } // Cast key

  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
        _iterator8.return();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  if (key !== null) {
    key = Compile.ref(key, {
      separator,
      ancestor: 0
    });
  } // Add rule


  var obj = schema.clone();
  obj.$_terms.dependencies = obj.$_terms.dependencies || [];
  obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
  return obj;
};

internals.dependencies = {
  and(schema, dep, value, state, prefs) {
    var missing = [];
    var present = [];
    var count = dep.peers.length;
    var _iteratorNormalCompletion9 = true;
    var _didIteratorError9 = false;
    var _iteratorError9 = undefined;

    try {
      for (var _iterator9 = dep.peers[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
        var peer = _step9.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) === undefined) {
          missing.push(peer.key);
        } else {
          present.push(peer.key);
        }
      }
    } catch (err) {
      _didIteratorError9 = true;
      _iteratorError9 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
          _iterator9.return();
        }
      } finally {
        if (_didIteratorError9) {
          throw _iteratorError9;
        }
      }
    }

    if (missing.length !== count && present.length !== count) {
      return {
        code: 'object.and',
        context: {
          present,
          presentWithLabels: internals.keysToLabels(schema, present),
          missing,
          missingWithLabels: internals.keysToLabels(schema, missing)
        }
      };
    }
  },

  nand(schema, dep, value, state, prefs) {
    var present = [];
    var _iteratorNormalCompletion10 = true;
    var _didIteratorError10 = false;
    var _iteratorError10 = undefined;

    try {
      for (var _iterator10 = dep.peers[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
        var peer = _step10.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          present.push(peer.key);
        }
      }
    } catch (err) {
      _didIteratorError10 = true;
      _iteratorError10 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
          _iterator10.return();
        }
      } finally {
        if (_didIteratorError10) {
          throw _iteratorError10;
        }
      }
    }

    if (present.length !== dep.peers.length) {
      return;
    }

    var main = dep.paths[0];
    var values = dep.paths.slice(1);
    return {
      code: 'object.nand',
      context: {
        main,
        mainWithLabel: internals.keysToLabels(schema, main),
        peers: values,
        peersWithLabels: internals.keysToLabels(schema, values)
      }
    };
  },

  or(schema, dep, value, state, prefs) {
    var _iteratorNormalCompletion11 = true;
    var _didIteratorError11 = false;
    var _iteratorError11 = undefined;

    try {
      for (var _iterator11 = dep.peers[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
        var peer = _step11.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          return;
        }
      }
    } catch (err) {
      _didIteratorError11 = true;
      _iteratorError11 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
          _iterator11.return();
        }
      } finally {
        if (_didIteratorError11) {
          throw _iteratorError11;
        }
      }
    }

    return {
      code: 'object.missing',
      context: {
        peers: dep.paths,
        peersWithLabels: internals.keysToLabels(schema, dep.paths)
      }
    };
  },

  oxor(schema, dep, value, state, prefs) {
    var present = [];
    var _iteratorNormalCompletion12 = true;
    var _didIteratorError12 = false;
    var _iteratorError12 = undefined;

    try {
      for (var _iterator12 = dep.peers[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
        var peer = _step12.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          present.push(peer.key);
        }
      }
    } catch (err) {
      _didIteratorError12 = true;
      _iteratorError12 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
          _iterator12.return();
        }
      } finally {
        if (_didIteratorError12) {
          throw _iteratorError12;
        }
      }
    }

    if (!present.length || present.length === 1) {
      return;
    }

    var context = {
      peers: dep.paths,
      peersWithLabels: internals.keysToLabels(schema, dep.paths)
    };
    context.present = present;
    context.presentWithLabels = internals.keysToLabels(schema, present);
    return {
      code: 'object.oxor',
      context
    };
  },

  with(schema, dep, value, state, prefs) {
    var _iteratorNormalCompletion13 = true;
    var _didIteratorError13 = false;
    var _iteratorError13 = undefined;

    try {
      for (var _iterator13 = dep.peers[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
        var peer = _step13.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) === undefined) {
          return {
            code: 'object.with',
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    } catch (err) {
      _didIteratorError13 = true;
      _iteratorError13 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
          _iterator13.return();
        }
      } finally {
        if (_didIteratorError13) {
          throw _iteratorError13;
        }
      }
    }
  },

  without(schema, dep, value, state, prefs) {
    var _iteratorNormalCompletion14 = true;
    var _didIteratorError14 = false;
    var _iteratorError14 = undefined;

    try {
      for (var _iterator14 = dep.peers[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
        var peer = _step14.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          return {
            code: 'object.without',
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    } catch (err) {
      _didIteratorError14 = true;
      _iteratorError14 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
          _iterator14.return();
        }
      } finally {
        if (_didIteratorError14) {
          throw _iteratorError14;
        }
      }
    }
  },

  xor(schema, dep, value, state, prefs) {
    var present = [];
    var _iteratorNormalCompletion15 = true;
    var _didIteratorError15 = false;
    var _iteratorError15 = undefined;

    try {
      for (var _iterator15 = dep.peers[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
        var peer = _step15.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          present.push(peer.key);
        }
      }
    } catch (err) {
      _didIteratorError15 = true;
      _iteratorError15 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
          _iterator15.return();
        }
      } finally {
        if (_didIteratorError15) {
          throw _iteratorError15;
        }
      }
    }

    if (present.length === 1) {
      return;
    }

    var context = {
      peers: dep.paths,
      peersWithLabels: internals.keysToLabels(schema, dep.paths)
    };

    if (present.length === 0) {
      return {
        code: 'object.missing',
        context
      };
    }

    context.present = present;
    context.presentWithLabels = internals.keysToLabels(schema, present);
    return {
      code: 'object.xor',
      context
    };
  }

};

internals.keysToLabels = function (schema, keys) {
  if (Array.isArray(keys)) {
    return keys.map(function (key) {
      return schema.$_mapLabels(key);
    });
  }

  return schema.$_mapLabels(keys);
};

internals.rename = function (schema, value, state, prefs, errors) {
  var renamed = {};
  var _iteratorNormalCompletion16 = true;
  var _didIteratorError16 = false;
  var _iteratorError16 = undefined;

  try {
    for (var _iterator16 = schema.$_terms.renames[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
      var rename = _step16.value;
      var matches = [];
      var pattern = typeof rename.from !== 'string';

      if (!pattern) {
        if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {
          matches.push(rename);
        }
      } else {
        for (var from in value) {
          if (value[from] === undefined && rename.options.ignoreUndefined) {
            continue;
          }

          if (from === rename.to) {
            continue;
          }

          var match = rename.from.exec(from);

          if (!match) {
            continue;
          }

          matches.push({
            from,
            to: rename.to,
            match
          });
        }
      }

      for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {
        var _match = _matches[_i];
        var _from = _match.from;
        var to = _match.to;

        if (to instanceof Template) {
          to = to.render(value, state, prefs, _match.match);
        }

        if (_from === to) {
          continue;
        }

        if (!rename.options.multiple && renamed[to]) {
          errors.push(schema.$_createError('object.rename.multiple', value, {
            from: _from,
            to,
            pattern
          }, state, prefs));

          if (prefs.abortEarly) {
            return false;
          }
        }

        if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
          errors.push(schema.$_createError('object.rename.override', value, {
            from: _from,
            to,
            pattern
          }, state, prefs));

          if (prefs.abortEarly) {
            return false;
          }
        }

        if (value[_from] === undefined) {
          delete value[to];
        } else {
          value[to] = value[_from];
        }

        renamed[to] = true;

        if (!rename.options.alias) {
          delete value[_from];
        }
      }
    }
  } catch (err) {
    _didIteratorError16 = true;
    _iteratorError16 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
        _iterator16.return();
      }
    } finally {
      if (_didIteratorError16) {
        throw _iteratorError16;
      }
    }
  }

  return true;
};

internals.unknown = function (schema, value, unprocessed, errors, state, prefs) {
  if (schema.$_terms.patterns) {
    var hasMatches = false;
    var matches = schema.$_terms.patterns.map(function (pattern) {
      if (pattern.matches) {
        hasMatches = true;
        return [];
      }
    });
    var ancestors = [value, ...state.ancestors];
    var _iteratorNormalCompletion17 = true;
    var _didIteratorError17 = false;
    var _iteratorError17 = undefined;

    try {
      for (var _iterator17 = unprocessed[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
        var key = _step17.value;
        var item = value[key];
        var path = [...state.path, key];

        for (var _i2 = 0; _i2 < schema.$_terms.patterns.length; ++_i2) {
          var pattern = schema.$_terms.patterns[_i2];

          if (pattern.regex) {
            var _match2 = pattern.regex.test(key);

            state.mainstay.tracer.debug(state, 'rule', `pattern.${_i2}`, _match2 ? 'pass' : 'error');

            if (!_match2) {
              continue;
            }
          } else {
            if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${_i2}`), prefs)) {
              continue;
            }
          }

          unprocessed.delete(key);

          var _localState = state.localize(path, ancestors, {
            schema: pattern.rule,
            key
          });

          var _result = pattern.rule.$_validate(item, _localState, prefs);

          if (_result.errors) {
            if (prefs.abortEarly) {
              return {
                value,
                errors: _result.errors
              };
            }

            errors.push(..._result.errors);
          }

          if (pattern.matches) {
            matches[_i2].push(key);
          }

          value[key] = _result.value;

          if (!pattern.fallthrough) {
            break;
          }
        }
      } // Validate pattern matches rules

    } catch (err) {
      _didIteratorError17 = true;
      _iteratorError17 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
          _iterator17.return();
        }
      } finally {
        if (_didIteratorError17) {
          throw _iteratorError17;
        }
      }
    }

    if (hasMatches) {
      for (var i = 0; i < matches.length; ++i) {
        var match = matches[i];

        if (!match) {
          continue;
        }

        var stpm = schema.$_terms.patterns[i].matches;
        var localState = state.localize(state.path, ancestors, stpm);
        var result = stpm.$_validate(match, localState, prefs);

        if (result.errors) {
          var details = Errors.details(result.errors, {
            override: false
          });
          details.matches = match;
          var report = schema.$_createError('object.pattern.match', value, details, state, prefs);

          if (prefs.abortEarly) {
            return {
              value,
              errors: report
            };
          }

          errors.push(report);
        }
      }
    }
  }

  if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
    // If no keys or patterns specified, unknown keys allowed
    return;
  }

  if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {
    var stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
    var _iteratorNormalCompletion18 = true;
    var _didIteratorError18 = false;
    var _iteratorError18 = undefined;

    try {
      for (var _iterator18 = unprocessed[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
        var _key7 = _step18.value;

        if (stripUnknown) {
          delete value[_key7];
          unprocessed.delete(_key7);
        } else if (typeof value[_key7] === 'function') {
          unprocessed.delete(_key7);
        }
      }
    } catch (err) {
      _didIteratorError18 = true;
      _iteratorError18 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
          _iterator18.return();
        }
      } finally {
        if (_didIteratorError18) {
          throw _iteratorError18;
        }
      }
    }
  }

  var forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);

  if (forbidUnknown) {
    var _iteratorNormalCompletion19 = true;
    var _didIteratorError19 = false;
    var _iteratorError19 = undefined;

    try {
      for (var _iterator19 = unprocessed[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
        var unprocessedKey = _step19.value;

        var _localState2 = state.localize([...state.path, unprocessedKey], []);

        var _report = schema.$_createError('object.unknown', value[unprocessedKey], {
          child: unprocessedKey
        }, _localState2, prefs, {
          flags: false
        });

        if (prefs.abortEarly) {
          return {
            value,
            errors: _report
          };
        }

        errors.push(_report);
      }
    } catch (err) {
      _didIteratorError19 = true;
      _iteratorError19 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
          _iterator19.return();
        }
      } finally {
        if (_didIteratorError19) {
          throw _iteratorError19;
        }
      }
    }
  }
};

internals.Dependency = class {
  constructor(rel, key, peers, paths) {
    this.rel = rel;
    this.key = key;
    this.peers = peers;
    this.paths = paths;
  }

  describe() {
    var desc = {
      rel: this.rel,
      peers: this.paths
    };

    if (this.key !== null) {
      desc.key = this.key.key;
    }

    if (this.peers[0].separator !== '.') {
      desc.options = {
        separator: this.peers[0].separator
      };
    }

    return desc;
  }

};
internals.Keys = class extends Array {
  concat(source) {
    var result = this.slice();
    var keys = new Map();

    for (var i = 0; i < result.length; ++i) {
      keys.set(result[i].key, i);
    }

    var _iteratorNormalCompletion20 = true;
    var _didIteratorError20 = false;
    var _iteratorError20 = undefined;

    try {
      for (var _iterator20 = source[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
        var item = _step20.value;
        var key = item.key;
        var pos = keys.get(key);

        if (pos !== undefined) {
          result[pos] = {
            key,
            schema: result[pos].schema.concat(item.schema)
          };
        } else {
          result.push(item);
        }
      }
    } catch (err) {
      _didIteratorError20 = true;
      _iteratorError20 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion20 && _iterator20.return != null) {
          _iterator20.return();
        }
      } finally {
        if (_didIteratorError20) {
          throw _iteratorError20;
        }
      }
    }

    return result;
  }

};