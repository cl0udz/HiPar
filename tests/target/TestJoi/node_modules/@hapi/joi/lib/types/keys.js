'use strict';

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ApplyToDefaults = require('@hapi/hoek/lib/applyToDefaults');

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Topo = require('@hapi/topo');

var Any = require('./any');

var Common = require('../common');

var Compile = require('../compile');

var Errors = require('../errors');

var Ref = require('../ref');

var Template = require('../template');

var internals = {
  renameDefaults: {
    alias: false,
    // Keep old value in place
    multiple: false,
    // Allow renaming multiple keys into the same target
    override: false // Overrides an existing key

  }
};
module.exports = Any.extend({
  type: '_keys',
  properties: {
    "typeof": 'object'
  },
  flags: {
    unknown: {
      "default": false
    }
  },
  terms: {
    dependencies: {
      init: null
    },
    keys: {
      init: null,
      manifest: {
        mapped: {
          from: 'schema',
          to: 'key'
        }
      }
    },
    patterns: {
      init: null
    },
    renames: {
      init: null
    }
  },
  args: function args(schema, keys) {
    return schema.keys(keys);
  },
  validate: function validate(value, _ref) {
    var schema = _ref.schema,
        error = _ref.error,
        state = _ref.state,
        prefs = _ref.prefs;

    if (!value || _typeof(value) !== schema.$_property('typeof') || Array.isArray(value)) {
      return {
        value: value,
        errors: error('object.base', {
          type: schema.$_property('typeof')
        })
      };
    } // Skip if there are no other rules to test


    if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys
    !schema.$_terms.patterns && !schema.$_terms.externals) {
      return;
    } // Shallow clone value


    value = internals.clone(value, prefs);
    var errors = []; // Rename keys

    if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
      return {
        value: value,
        errors: errors
      };
    } // Anything allowed


    if (!schema.$_terms.keys && // null allows any keys
    !schema.$_terms.patterns && !schema.$_terms.dependencies) {
      return {
        value: value,
        errors: errors
      };
    } // Defined keys


    var unprocessed = new Set(Object.keys(value));

    if (schema.$_terms.keys) {
      var ancestors = [value].concat(_toConsumableArray(state.ancestors));
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = schema.$_terms.keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          var key = child.key;
          var item = value[key];
          unprocessed["delete"](key);
          var localState = state.localize([].concat(_toConsumableArray(state.path), [key]), ancestors, child);
          var result = child.schema.$_validate(item, localState, prefs);

          if (result.errors) {
            if (prefs.abortEarly) {
              return {
                value: value,
                errors: result.errors
              };
            }

            errors.push.apply(errors, _toConsumableArray(result.errors));
          } else if (child.schema._flags.result === 'strip' || result.value === undefined && item !== undefined) {
            delete value[key];
          } else if (result.value !== undefined) {
            value[key] = result.value;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } // Unknown keys


    if (unprocessed.size) {
      var early = internals.unknown(schema, value, unprocessed, errors, state, prefs);

      if (early) {
        return early;
      }
    } // Validate dependencies


    if (schema.$_terms.dependencies) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = schema.$_terms.dependencies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var dep = _step2.value;

          if (dep.key && dep.key.resolve(value, state, prefs, null, {
            shadow: false
          }) === undefined) {
            continue;
          }

          var failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);

          if (failed) {
            var report = schema.$_createError(failed.code, value, failed.context, state, prefs);

            if (prefs.abortEarly) {
              return {
                value: value,
                errors: report
              };
            }

            errors.push(report);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    return {
      value: value,
      errors: errors
    };
  },
  rules: {
    and: {
      method: function method()
      /*, [options] */
      {
        for (var _len = arguments.length, peers = new Array(_len), _key = 0; _key < _len; _key++) {
          peers[_key] = arguments[_key];
        }

        Common.verifyFlat(peers, 'and');
        return internals.dependency(this, 'and', null, peers);
      }
    },
    append: {
      method: function method(schema) {
        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
          return this;
        }

        return this.keys(schema);
      }
    },
    assert: {
      method: function method(subject, schema, message) {
        if (!Template.isTemplate(subject)) {
          subject = Compile.ref(subject);
        }

        Assert(message === undefined || typeof message === 'string', 'Message must be a string');
        schema = this.$_compile(schema, {
          appendPath: true
        });
        var obj = this.$_addRule({
          name: 'assert',
          args: {
            subject: subject,
            schema: schema,
            message: message
          }
        });
        obj.$_mutateRegister(subject);
        obj.$_mutateRegister(schema);
        return obj;
      },
      validate: function validate(value, _ref2, _ref3) {
        var error = _ref2.error,
            prefs = _ref2.prefs,
            state = _ref2.state;
        var subject = _ref3.subject,
            schema = _ref3.schema,
            message = _ref3.message;
        var about = subject.resolve(value, state, prefs);
        var path = Ref.isRef(subject) ? subject.absolute(state) : [];

        if (schema.$_match(about, state.localize(path, [value].concat(_toConsumableArray(state.ancestors)), schema), prefs)) {
          return value;
        }

        return error('object.assert', {
          subject: subject,
          message: message
        });
      },
      args: ['subject', 'schema', 'message'],
      multi: true
    },
    instance: {
      method: function method(constructor, name) {
        Assert(typeof constructor === 'function', 'constructor must be a function');
        name = name || constructor.name;
        return this.$_addRule({
          name: 'instance',
          args: {
            constructor: constructor,
            name: name
          }
        });
      },
      validate: function validate(value, helpers, _ref4) {
        var constructor = _ref4.constructor,
            name = _ref4.name;

        if (value instanceof constructor) {
          return value;
        }

        return helpers.error('object.instance', {
          type: name,
          value: value
        });
      },
      args: ['constructor', 'name']
    },
    keys: {
      method: function method(schema) {
        var _this = this;

        Assert(schema === undefined || _typeof(schema) === 'object', 'Object schema must be a valid object');
        Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');
        var obj = this.clone();

        if (!schema) {
          // Allow all
          obj.$_terms.keys = null;
        } else if (!Object.keys(schema).length) {
          // Allow none
          obj.$_terms.keys = [];
        } else {
          obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter(function (child) {
            return !schema.hasOwnProperty(child.key);
          }) : [];

          var _loop = function _loop(key) {
            Common.tryWithPath(function () {
              return obj.$_terms.keys.push({
                key: key,
                schema: _this.$_compile(schema[key])
              });
            }, key);
          };

          for (var key in schema) {
            _loop(key);
          }
        }

        return obj.$_mutateRebuild();
      }
    },
    length: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'length',
          args: {
            limit: limit
          },
          operator: '='
        });
      },
      validate: function validate(value, helpers, _ref5, _ref6) {
        var limit = _ref5.limit;
        var name = _ref6.name,
            operator = _ref6.operator,
            args = _ref6.args;

        if (Common.compare(Object.keys(value).length, limit, operator)) {
          return value;
        }

        return helpers.error('object.' + name, {
          limit: args.limit,
          value: value
        });
      },
      args: [{
        name: 'limit',
        ref: true,
        assert: Common.limit,
        message: 'must be a positive integer'
      }]
    },
    max: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'max',
          method: 'length',
          args: {
            limit: limit
          },
          operator: '<='
        });
      }
    },
    min: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'min',
          method: 'length',
          args: {
            limit: limit
          },
          operator: '>='
        });
      }
    },
    nand: {
      method: function method()
      /*, [options] */
      {
        for (var _len2 = arguments.length, peers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          peers[_key2] = arguments[_key2];
        }

        Common.verifyFlat(peers, 'nand');
        return internals.dependency(this, 'nand', null, peers);
      }
    },
    or: {
      method: function method()
      /*, [options] */
      {
        for (var _len3 = arguments.length, peers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          peers[_key3] = arguments[_key3];
        }

        Common.verifyFlat(peers, 'or');
        return internals.dependency(this, 'or', null, peers);
      }
    },
    oxor: {
      method: function method()
      /*, [options] */
      {
        for (var _len4 = arguments.length, peers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          peers[_key4] = arguments[_key4];
        }

        return internals.dependency(this, 'oxor', null, peers);
      }
    },
    pattern: {
      method: function method(pattern, schema) {
        var _config;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isRegExp = pattern instanceof RegExp;

        if (!isRegExp) {
          pattern = this.$_compile(pattern, {
            appendPath: true
          });
        }

        Assert(schema !== undefined, 'Invalid rule');
        Common.assertOptions(options, ['fallthrough', 'matches']);

        if (isRegExp) {
          Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
        }

        schema = this.$_compile(schema, {
          appendPath: true
        });
        var obj = this.clone();
        obj.$_terms.patterns = obj.$_terms.patterns || [];
        var config = (_config = {}, _defineProperty(_config, isRegExp ? 'regex' : 'schema', pattern), _defineProperty(_config, "rule", schema), _config);

        if (options.matches) {
          config.matches = this.$_compile(options.matches);

          if (config.matches.type !== 'array') {
            config.matches = config.matches.$_root.array().items(config.matches);
          }

          obj.$_mutateRegister(config.matches);
        }

        if (options.fallthrough) {
          config.fallthrough = true;
        }

        obj.$_terms.patterns.push(config);
        obj.$_mutateRegister(schema);
        return obj;
      }
    },
    ref: {
      method: function method() {
        return this.$_addRule('ref');
      },
      validate: function validate(value, helpers) {
        if (Ref.isRef(value)) {
          return value;
        }

        return helpers.error('object.refType', {
          value: value
        });
      }
    },
    rename: {
      method: function method(from, to) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
        Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');
        Assert(to !== from, 'Cannot rename key to same name:', from);
        Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);
        var obj = this.clone();
        obj.$_terms.renames = obj.$_terms.renames || [];
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = obj.$_terms.renames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var rename = _step3.value;
            Assert(rename.from !== from, 'Cannot rename the same key multiple times');
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        if (to instanceof Template) {
          obj.$_mutateRegister(to);
        }

        obj.$_terms.renames.push({
          from: from,
          to: to,
          options: ApplyToDefaults(internals.renameDefaults, options)
        });
        return obj;
      }
    },
    schema: {
      method: function method() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'any';
        return this.$_addRule({
          name: 'schema',
          args: {
            type: type
          }
        });
      },
      validate: function validate(value, helpers, _ref7) {
        var type = _ref7.type;

        if (Common.isSchema(value) && (type === 'any' || value.type === type)) {
          return value;
        }

        return helpers.error('object.schema', {
          type: type
        });
      }
    },
    unknown: {
      method: function method(allow) {
        return this.$_setFlag('unknown', allow !== false);
      }
    },
    "with": {
      method: function method(key, peers) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return internals.dependency(this, 'with', key, peers, options);
      }
    },
    without: {
      method: function method(key, peers) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return internals.dependency(this, 'without', key, peers, options);
      }
    },
    xor: {
      method: function method()
      /*, [options] */
      {
        for (var _len5 = arguments.length, peers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          peers[_key5] = arguments[_key5];
        }

        Common.verifyFlat(peers, 'xor');
        return internals.dependency(this, 'xor', null, peers);
      }
    }
  },
  overrides: {
    "default": function _default(value, options) {
      if (value === undefined) {
        value = Common.symbols.deepDefault;
      }

      return this.$_super["default"](value, options);
    }
  },
  rebuild: function rebuild(schema) {
    if (schema.$_terms.keys) {
      (function () {
        var topo = new Topo();
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          var _loop2 = function _loop2() {
            var child = _step4.value;
            Common.tryWithPath(function () {
              return topo.add(child, {
                after: child.schema.$_rootReferences(),
                group: child.key
              });
            }, child.key);
          };

          for (var _iterator4 = schema.$_terms.keys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            _loop2();
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        schema.$_terms.keys = _construct(internals.Keys, _toConsumableArray(topo.nodes));
      })();
    }
  },
  manifest: {
    build: function build(obj, desc) {
      if (desc.keys) {
        obj = obj.keys(desc.keys);
      }

      if (desc.dependencies) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = desc.dependencies[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _step5$value = _step5.value,
                rel = _step5$value.rel,
                _step5$value$key = _step5$value.key,
                key = _step5$value$key === void 0 ? null : _step5$value$key,
                peers = _step5$value.peers,
                options = _step5$value.options;
            obj = internals.dependency(obj, rel, key, peers, options);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }

      if (desc.patterns) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = desc.patterns[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var _step6$value = _step6.value,
                regex = _step6$value.regex,
                schema = _step6$value.schema,
                rule = _step6$value.rule,
                fallthrough = _step6$value.fallthrough,
                matches = _step6$value.matches;
            obj = obj.pattern(regex || schema, rule, {
              fallthrough: fallthrough,
              matches: matches
            });
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }

      if (desc.renames) {
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = desc.renames[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var _step7$value = _step7.value,
                from = _step7$value.from,
                to = _step7$value.to,
                _options = _step7$value.options;
            obj = obj.rename(from, to, _options);
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
              _iterator7["return"]();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }
      }

      return obj;
    }
  },
  messages: {
    'object.and': '"{{#label}}" contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',
    'object.assert': '"{{#label}}" is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
    'object.base': '"{{#label}}" must be of type {{#type}}',
    'object.instance': '"{{#label}}" must be an instance of "{{#type}}"',
    'object.length': '"{{#label}}" must have {{#limit}} key{if(#limit == 1, "", "s")}',
    'object.max': '"{{#label}}" must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
    'object.min': '"{{#label}}" must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
    'object.missing': '"{{#label}}" must contain at least one of {{#peersWithLabels}}',
    'object.nand': '"{{#mainWithLabel}}" must not exist simultaneously with {{#peersWithLabels}}',
    'object.oxor': '"{{#label}}" contains a conflict between optional exclusive peers {{#peersWithLabels}}',
    'object.pattern.match': '"{{#label}}" keys failed to match pattern requirements',
    'object.refType': '"{{#label}}" must be a Joi reference',
    'object.rename.multiple': '"{{#label}}" cannot rename "{{#from}}" because multiple renames are disabled and another key was already renamed to "{{#to}}"',
    'object.rename.override': '"{{#label}}" cannot rename "{{#from}}" because override is disabled and target "{{#to}}" exists',
    'object.schema': '"{{#label}}" must be a Joi schema of {{#type}} type',
    'object.unknown': '"{{#label}}" is not allowed',
    'object.with': '"{{#mainWithLabel}}" missing required peer "{{#peerWithLabel}}"',
    'object.without': '"{{#mainWithLabel}}" conflict with forbidden peer "{{#peerWithLabel}}"',
    'object.xor': '"{{#label}}" contains a conflict between exclusive peers {{#peersWithLabels}}'
  }
}); // Helpers

internals.clone = function (value, prefs) {
  // Object
  if (_typeof(value) === 'object') {
    if (prefs.nonEnumerables) {
      return Clone(value, {
        shallow: true
      });
    }

    var _clone = Object.create(Object.getPrototypeOf(value));

    Object.assign(_clone, value);
    return _clone;
  } // Function


  var clone = function clone() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return value.apply(this, args);
  };

  clone.prototype = Clone(value.prototype);
  Object.defineProperty(clone, 'name', {
    value: value.name,
    writable: false
  });
  Object.defineProperty(clone, 'length', {
    value: value.length,
    writable: false
  });
  Object.assign(clone, value);
  return clone;
};

internals.dependency = function (schema, rel, key, peers, options) {
  Assert(key === null || typeof key === 'string', rel, 'key must be a strings'); // Extract options from peers array

  if (!options) {
    options = peers.length > 1 && _typeof(peers[peers.length - 1]) === 'object' ? peers.pop() : {};
  }

  Common.assertOptions(options, ['separator']);
  peers = [].concat(peers); // Cast peer paths

  var separator = Common["default"](options.separator, '.');
  var paths = [];
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = peers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var peer = _step8.value;
      Assert(typeof peer === 'string', rel, 'peers must be a string or a reference');
      paths.push(Compile.ref(peer, {
        separator: separator,
        ancestor: 0
      }));
    } // Cast key

  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
        _iterator8["return"]();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  if (key !== null) {
    key = Compile.ref(key, {
      separator: separator,
      ancestor: 0
    });
  } // Add rule


  var obj = schema.clone();
  obj.$_terms.dependencies = obj.$_terms.dependencies || [];
  obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
  return obj;
};

internals.dependencies = {
  and: function and(schema, dep, value, state, prefs) {
    var missing = [];
    var present = [];
    var count = dep.peers.length;
    var _iteratorNormalCompletion9 = true;
    var _didIteratorError9 = false;
    var _iteratorError9 = undefined;

    try {
      for (var _iterator9 = dep.peers[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
        var peer = _step9.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) === undefined) {
          missing.push(peer.key);
        } else {
          present.push(peer.key);
        }
      }
    } catch (err) {
      _didIteratorError9 = true;
      _iteratorError9 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
          _iterator9["return"]();
        }
      } finally {
        if (_didIteratorError9) {
          throw _iteratorError9;
        }
      }
    }

    if (missing.length !== count && present.length !== count) {
      return {
        code: 'object.and',
        context: {
          present: present,
          presentWithLabels: internals.keysToLabels(schema, present),
          missing: missing,
          missingWithLabels: internals.keysToLabels(schema, missing)
        }
      };
    }
  },
  nand: function nand(schema, dep, value, state, prefs) {
    var present = [];
    var _iteratorNormalCompletion10 = true;
    var _didIteratorError10 = false;
    var _iteratorError10 = undefined;

    try {
      for (var _iterator10 = dep.peers[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
        var peer = _step10.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          present.push(peer.key);
        }
      }
    } catch (err) {
      _didIteratorError10 = true;
      _iteratorError10 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
          _iterator10["return"]();
        }
      } finally {
        if (_didIteratorError10) {
          throw _iteratorError10;
        }
      }
    }

    if (present.length !== dep.peers.length) {
      return;
    }

    var main = dep.paths[0];
    var values = dep.paths.slice(1);
    return {
      code: 'object.nand',
      context: {
        main: main,
        mainWithLabel: internals.keysToLabels(schema, main),
        peers: values,
        peersWithLabels: internals.keysToLabels(schema, values)
      }
    };
  },
  or: function or(schema, dep, value, state, prefs) {
    var _iteratorNormalCompletion11 = true;
    var _didIteratorError11 = false;
    var _iteratorError11 = undefined;

    try {
      for (var _iterator11 = dep.peers[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
        var peer = _step11.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          return;
        }
      }
    } catch (err) {
      _didIteratorError11 = true;
      _iteratorError11 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
          _iterator11["return"]();
        }
      } finally {
        if (_didIteratorError11) {
          throw _iteratorError11;
        }
      }
    }

    return {
      code: 'object.missing',
      context: {
        peers: dep.paths,
        peersWithLabels: internals.keysToLabels(schema, dep.paths)
      }
    };
  },
  oxor: function oxor(schema, dep, value, state, prefs) {
    var present = [];
    var _iteratorNormalCompletion12 = true;
    var _didIteratorError12 = false;
    var _iteratorError12 = undefined;

    try {
      for (var _iterator12 = dep.peers[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
        var peer = _step12.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          present.push(peer.key);
        }
      }
    } catch (err) {
      _didIteratorError12 = true;
      _iteratorError12 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
          _iterator12["return"]();
        }
      } finally {
        if (_didIteratorError12) {
          throw _iteratorError12;
        }
      }
    }

    if (!present.length || present.length === 1) {
      return;
    }

    var context = {
      peers: dep.paths,
      peersWithLabels: internals.keysToLabels(schema, dep.paths)
    };
    context.present = present;
    context.presentWithLabels = internals.keysToLabels(schema, present);
    return {
      code: 'object.oxor',
      context: context
    };
  },
  "with": function _with(schema, dep, value, state, prefs) {
    var _iteratorNormalCompletion13 = true;
    var _didIteratorError13 = false;
    var _iteratorError13 = undefined;

    try {
      for (var _iterator13 = dep.peers[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
        var peer = _step13.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) === undefined) {
          return {
            code: 'object.with',
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    } catch (err) {
      _didIteratorError13 = true;
      _iteratorError13 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
          _iterator13["return"]();
        }
      } finally {
        if (_didIteratorError13) {
          throw _iteratorError13;
        }
      }
    }
  },
  without: function without(schema, dep, value, state, prefs) {
    var _iteratorNormalCompletion14 = true;
    var _didIteratorError14 = false;
    var _iteratorError14 = undefined;

    try {
      for (var _iterator14 = dep.peers[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
        var peer = _step14.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          return {
            code: 'object.without',
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    } catch (err) {
      _didIteratorError14 = true;
      _iteratorError14 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
          _iterator14["return"]();
        }
      } finally {
        if (_didIteratorError14) {
          throw _iteratorError14;
        }
      }
    }
  },
  xor: function xor(schema, dep, value, state, prefs) {
    var present = [];
    var _iteratorNormalCompletion15 = true;
    var _didIteratorError15 = false;
    var _iteratorError15 = undefined;

    try {
      for (var _iterator15 = dep.peers[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
        var peer = _step15.value;

        if (peer.resolve(value, state, prefs, null, {
          shadow: false
        }) !== undefined) {
          present.push(peer.key);
        }
      }
    } catch (err) {
      _didIteratorError15 = true;
      _iteratorError15 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
          _iterator15["return"]();
        }
      } finally {
        if (_didIteratorError15) {
          throw _iteratorError15;
        }
      }
    }

    if (present.length === 1) {
      return;
    }

    var context = {
      peers: dep.paths,
      peersWithLabels: internals.keysToLabels(schema, dep.paths)
    };

    if (present.length === 0) {
      return {
        code: 'object.missing',
        context: context
      };
    }

    context.present = present;
    context.presentWithLabels = internals.keysToLabels(schema, present);
    return {
      code: 'object.xor',
      context: context
    };
  }
};

internals.keysToLabels = function (schema, keys) {
  if (Array.isArray(keys)) {
    return keys.map(function (key) {
      return schema.$_mapLabels(key);
    });
  }

  return schema.$_mapLabels(keys);
};

internals.rename = function (schema, value, state, prefs, errors) {
  var renamed = {};
  var _iteratorNormalCompletion16 = true;
  var _didIteratorError16 = false;
  var _iteratorError16 = undefined;

  try {
    for (var _iterator16 = schema.$_terms.renames[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
      var rename = _step16.value;
      var matches = [];
      var pattern = typeof rename.from !== 'string';

      if (!pattern) {
        if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {
          matches.push(rename);
        }
      } else {
        for (var from in value) {
          if (value[from] === undefined && rename.options.ignoreUndefined) {
            continue;
          }

          if (from === rename.to) {
            continue;
          }

          var match = rename.from.exec(from);

          if (!match) {
            continue;
          }

          matches.push({
            from: from,
            to: rename.to,
            match: match
          });
        }
      }

      for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {
        var _match = _matches[_i];
        var _from = _match.from;
        var to = _match.to;

        if (to instanceof Template) {
          to = to.render(value, state, prefs, _match.match);
        }

        if (_from === to) {
          continue;
        }

        if (!rename.options.multiple && renamed[to]) {
          errors.push(schema.$_createError('object.rename.multiple', value, {
            from: _from,
            to: to,
            pattern: pattern
          }, state, prefs));

          if (prefs.abortEarly) {
            return false;
          }
        }

        if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
          errors.push(schema.$_createError('object.rename.override', value, {
            from: _from,
            to: to,
            pattern: pattern
          }, state, prefs));

          if (prefs.abortEarly) {
            return false;
          }
        }

        if (value[_from] === undefined) {
          delete value[to];
        } else {
          value[to] = value[_from];
        }

        renamed[to] = true;

        if (!rename.options.alias) {
          delete value[_from];
        }
      }
    }
  } catch (err) {
    _didIteratorError16 = true;
    _iteratorError16 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
        _iterator16["return"]();
      }
    } finally {
      if (_didIteratorError16) {
        throw _iteratorError16;
      }
    }
  }

  return true;
};

internals.unknown = function (schema, value, unprocessed, errors, state, prefs) {
  if (schema.$_terms.patterns) {
    var hasMatches = false;
    var matches = schema.$_terms.patterns.map(function (pattern) {
      if (pattern.matches) {
        hasMatches = true;
        return [];
      }
    });
    var ancestors = [value].concat(_toConsumableArray(state.ancestors));
    var _iteratorNormalCompletion17 = true;
    var _didIteratorError17 = false;
    var _iteratorError17 = undefined;

    try {
      for (var _iterator17 = unprocessed[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
        var key = _step17.value;
        var item = value[key];
        var path = [].concat(_toConsumableArray(state.path), [key]);

        for (var _i2 = 0; _i2 < schema.$_terms.patterns.length; ++_i2) {
          var pattern = schema.$_terms.patterns[_i2];

          if (pattern.regex) {
            var _match2 = pattern.regex.test(key);

            state.mainstay.tracer.debug(state, 'rule', "pattern.".concat(_i2), _match2 ? 'pass' : 'error');

            if (!_match2) {
              continue;
            }
          } else {
            if (!pattern.schema.$_match(key, state.nest(pattern.schema, "pattern.".concat(_i2)), prefs)) {
              continue;
            }
          }

          unprocessed["delete"](key);

          var _localState = state.localize(path, ancestors, {
            schema: pattern.rule,
            key: key
          });

          var _result = pattern.rule.$_validate(item, _localState, prefs);

          if (_result.errors) {
            if (prefs.abortEarly) {
              return {
                value: value,
                errors: _result.errors
              };
            }

            errors.push.apply(errors, _toConsumableArray(_result.errors));
          }

          if (pattern.matches) {
            matches[_i2].push(key);
          }

          value[key] = _result.value;

          if (!pattern.fallthrough) {
            break;
          }
        }
      } // Validate pattern matches rules

    } catch (err) {
      _didIteratorError17 = true;
      _iteratorError17 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
          _iterator17["return"]();
        }
      } finally {
        if (_didIteratorError17) {
          throw _iteratorError17;
        }
      }
    }

    if (hasMatches) {
      for (var i = 0; i < matches.length; ++i) {
        var match = matches[i];

        if (!match) {
          continue;
        }

        var stpm = schema.$_terms.patterns[i].matches;
        var localState = state.localize(state.path, ancestors, stpm);
        var result = stpm.$_validate(match, localState, prefs);

        if (result.errors) {
          var details = Errors.details(result.errors, {
            override: false
          });
          details.matches = match;
          var report = schema.$_createError('object.pattern.match', value, details, state, prefs);

          if (prefs.abortEarly) {
            return {
              value: value,
              errors: report
            };
          }

          errors.push(report);
        }
      }
    }
  }

  if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
    // If no keys or patterns specified, unknown keys allowed
    return;
  }

  if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {
    var stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
    var _iteratorNormalCompletion18 = true;
    var _didIteratorError18 = false;
    var _iteratorError18 = undefined;

    try {
      for (var _iterator18 = unprocessed[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
        var _key7 = _step18.value;

        if (stripUnknown) {
          delete value[_key7];
          unprocessed["delete"](_key7);
        } else if (typeof value[_key7] === 'function') {
          unprocessed["delete"](_key7);
        }
      }
    } catch (err) {
      _didIteratorError18 = true;
      _iteratorError18 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
          _iterator18["return"]();
        }
      } finally {
        if (_didIteratorError18) {
          throw _iteratorError18;
        }
      }
    }
  }

  var forbidUnknown = !Common["default"](schema._flags.unknown, prefs.allowUnknown);

  if (forbidUnknown) {
    var _iteratorNormalCompletion19 = true;
    var _didIteratorError19 = false;
    var _iteratorError19 = undefined;

    try {
      for (var _iterator19 = unprocessed[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
        var unprocessedKey = _step19.value;

        var _localState2 = state.localize([].concat(_toConsumableArray(state.path), [unprocessedKey]), []);

        var _report = schema.$_createError('object.unknown', value[unprocessedKey], {
          child: unprocessedKey
        }, _localState2, prefs, {
          flags: false
        });

        if (prefs.abortEarly) {
          return {
            value: value,
            errors: _report
          };
        }

        errors.push(_report);
      }
    } catch (err) {
      _didIteratorError19 = true;
      _iteratorError19 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
          _iterator19["return"]();
        }
      } finally {
        if (_didIteratorError19) {
          throw _iteratorError19;
        }
      }
    }
  }
};

internals.Dependency =
/*#__PURE__*/
function () {
  function _class(rel, key, peers, paths) {
    _classCallCheck(this, _class);

    this.rel = rel;
    this.key = key;
    this.peers = peers;
    this.paths = paths;
  }

  _createClass(_class, [{
    key: "describe",
    value: function describe() {
      var desc = {
        rel: this.rel,
        peers: this.paths
      };

      if (this.key !== null) {
        desc.key = this.key.key;
      }

      if (this.peers[0].separator !== '.') {
        desc.options = {
          separator: this.peers[0].separator
        };
      }

      return desc;
    }
  }]);

  return _class;
}();

internals.Keys =
/*#__PURE__*/
function (_Array) {
  _inherits(_class2, _Array);

  function _class2() {
    _classCallCheck(this, _class2);

    return _possibleConstructorReturn(this, _getPrototypeOf(_class2).apply(this, arguments));
  }

  _createClass(_class2, [{
    key: "concat",
    value: function concat(source) {
      var result = this.slice();
      var keys = new Map();

      for (var i = 0; i < result.length; ++i) {
        keys.set(result[i].key, i);
      }

      var _iteratorNormalCompletion20 = true;
      var _didIteratorError20 = false;
      var _iteratorError20 = undefined;

      try {
        for (var _iterator20 = source[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
          var item = _step20.value;
          var key = item.key;
          var pos = keys.get(key);

          if (pos !== undefined) {
            result[pos] = {
              key: key,
              schema: result[pos].schema.concat(item.schema)
            };
          } else {
            result.push(item);
          }
        }
      } catch (err) {
        _didIteratorError20 = true;
        _iteratorError20 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
            _iterator20["return"]();
          }
        } finally {
          if (_didIteratorError20) {
            throw _iteratorError20;
          }
        }
      }

      return result;
    }
  }]);

  return _class2;
}(_wrapNativeSuper(Array));