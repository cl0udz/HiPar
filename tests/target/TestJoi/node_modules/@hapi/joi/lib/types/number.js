'use strict';

var Assert = require('@hapi/hoek/lib/assert');

var Any = require('./any');

var Common = require('../common');

var internals = {
  numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
  precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
};
module.exports = Any.extend({
  type: 'number',
  flags: {
    unsafe: {
      "default": false
    }
  },
  coerce: {
    from: 'string',
    method: function method(value, _ref) {
      var schema = _ref.schema,
          error = _ref.error;
      var matches = value.match(internals.numberRx);

      if (!matches) {
        return;
      }

      value = value.trim();
      var result = {
        value: parseFloat(value)
      };

      if (result.value === 0) {
        result.value = 0; // -0
      }

      if (!schema._flags.unsafe) {
        if (value.match(/e/i)) {
          var constructed = internals.normalizeExponent("".concat(result.value / Math.pow(10, matches[1]), "e").concat(matches[1]));

          if (constructed !== internals.normalizeExponent(value)) {
            result.errors = error('number.unsafe');
            return result;
          }
        } else {
          var string = result.value.toString();

          if (string.match(/e/i)) {
            return result;
          }

          if (string !== internals.normalizeDecimal(value)) {
            result.errors = error('number.unsafe');
            return result;
          }
        }
      }

      return result;
    }
  },
  validate: function validate(value, _ref2) {
    var schema = _ref2.schema,
        error = _ref2.error,
        prefs = _ref2.prefs;

    if (value === Infinity || value === -Infinity) {
      return {
        value: value,
        errors: error('number.infinity')
      };
    }

    if (!Common.isNumber(value)) {
      return {
        value: value,
        errors: error('number.base')
      };
    }

    var result = {
      value: value
    };

    if (result.value === 0) {
      result.value = 0; // -0
    }

    if (prefs.convert) {
      var rule = schema.$_getRule('precision');

      if (rule) {
        var precision = Math.pow(10, rule.args.limit); // This is conceptually equivalent to using toFixed but it should be much faster

        result.value = Math.round(result.value * precision) / precision;
      }
    }

    if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
      result.errors = error('number.unsafe');
    }

    return result;
  },
  rules: {
    compare: {
      method: false,
      validate: function validate(value, helpers, _ref3, _ref4) {
        var limit = _ref3.limit;
        var name = _ref4.name,
            operator = _ref4.operator,
            args = _ref4.args;

        if (Common.compare(value, limit, operator)) {
          return value;
        }

        return helpers.error('number.' + name, {
          limit: args.limit,
          value: value
        });
      },
      args: [{
        name: 'limit',
        ref: true,
        assert: Common.isNumber,
        message: 'must be a number'
      }]
    },
    greater: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'greater',
          method: 'compare',
          args: {
            limit: limit
          },
          operator: '>'
        });
      }
    },
    integer: {
      method: function method() {
        return this.$_addRule('integer');
      },
      validate: function validate(value, helpers) {
        if (Math.trunc(value) - value === 0) {
          return value;
        }

        return helpers.error('number.integer');
      }
    },
    less: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'less',
          method: 'compare',
          args: {
            limit: limit
          },
          operator: '<'
        });
      }
    },
    max: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'max',
          method: 'compare',
          args: {
            limit: limit
          },
          operator: '<='
        });
      }
    },
    min: {
      method: function method(limit) {
        return this.$_addRule({
          name: 'min',
          method: 'compare',
          args: {
            limit: limit
          },
          operator: '>='
        });
      }
    },
    multiple: {
      method: function method(base) {
        return this.$_addRule({
          name: 'multiple',
          args: {
            base: base
          }
        });
      },
      validate: function validate(value, helpers, _ref5, options) {
        var base = _ref5.base;

        if (value % base === 0) {
          return value;
        }

        return helpers.error('number.multiple', {
          multiple: options.args.base,
          value: value
        });
      },
      args: [{
        name: 'base',
        ref: true,
        assert: function assert(value) {
          return typeof value === 'number' && isFinite(value) && value > 0;
        },
        message: 'must be a positive number'
      }],
      multi: true
    },
    negative: {
      method: function method() {
        return this.sign('negative');
      }
    },
    port: {
      method: function method() {
        return this.$_addRule('port');
      },
      validate: function validate(value, helpers) {
        if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
          return value;
        }

        return helpers.error('number.port');
      }
    },
    positive: {
      method: function method() {
        return this.sign('positive');
      }
    },
    precision: {
      method: function method(limit) {
        Assert(Number.isSafeInteger(limit), 'limit must be an integer');
        return this.$_addRule({
          name: 'precision',
          args: {
            limit: limit
          }
        });
      },
      validate: function validate(value, helpers, _ref6) {
        var limit = _ref6.limit;
        var places = value.toString().match(internals.precisionRx);
        var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);

        if (decimals <= limit) {
          return value;
        }

        return helpers.error('number.precision', {
          limit: limit,
          value: value
        });
      },
      convert: true
    },
    sign: {
      method: function method(sign) {
        Assert(['negative', 'positive'].includes(sign), 'Invalid sign', sign);
        return this.$_addRule({
          name: 'sign',
          args: {
            sign: sign
          }
        });
      },
      validate: function validate(value, helpers, _ref7) {
        var sign = _ref7.sign;

        if (sign === 'negative' && value < 0 || sign === 'positive' && value > 0) {
          return value;
        }

        return helpers.error("number.".concat(sign));
      }
    },
    unsafe: {
      method: function method() {
        var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        Assert(typeof enabled === 'boolean', 'enabled must be a boolean');
        return this.$_setFlag('unsafe', enabled);
      }
    }
  },
  cast: {
    string: {
      from: function from(value) {
        return typeof value === 'number';
      },
      to: function to(value, helpers) {
        return value.toString();
      }
    }
  },
  messages: {
    'number.base': '"{{#label}}" must be a number',
    'number.greater': '"{{#label}}" must be greater than {{#limit}}',
    'number.infinity': '"{{#label}}" cannot be infinity',
    'number.integer': '"{{#label}}" must be an integer',
    'number.less': '"{{#label}}" must be less than {{#limit}}',
    'number.max': '"{{#label}}" must be less than or equal to {{#limit}}',
    'number.min': '"{{#label}}" must be larger than or equal to {{#limit}}',
    'number.multiple': '"{{#label}}" must be a multiple of {{#multiple}}',
    'number.negative': '"{{#label}}" must be a negative number',
    'number.port': '"{{#label}}" must be a valid port',
    'number.positive': '"{{#label}}" must be a positive number',
    'number.precision': '"{{#label}}" must have no more than {{#limit}} decimal places',
    'number.unsafe': '"{{#label}}" must be a safe number'
  }
}); // Helpers

internals.normalizeExponent = function (str) {
  return str.replace(/E/, 'e').replace(/\.(\d*[1-9])?0+e/, '.$1e').replace(/\.e/, 'e').replace(/e\+/, 'e').replace(/^\+/, '').replace(/^(-?)0+([1-9])/, '$1$2');
};

internals.normalizeDecimal = function (str) {
  str = str.replace(/^\+/, '').replace(/\.0+$/, '').replace(/^(-?)\.([^\.]*)$/, '$10.$2').replace(/^(-?)0+([1-9])/, '$1$2');

  if (str.includes('.') && str.endsWith('0')) {
    str = str.replace(/0+$/, '');
  }

  if (str === '-0') {
    return '0';
  }

  return str;
};