'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.flags");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.trim");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Assert = require('@hapi/hoek/lib/assert');

var Domain = require('@hapi/address/lib/domain');

var Email = require('@hapi/address/lib/email');

var EscapeRegex = require('@hapi/hoek/lib/escapeRegex');

var Tlds = require('@hapi/address/lib/tlds');

var Any = require('../any');

var Common = require('../../common');

var Ip = require('./ip');

var Uri = require('./uri');

var internals = {
  tlds: Tlds instanceof Set ? {
    tlds: {
      allow: Tlds,
      deny: null
    }
  } : false,
  // $lab:coverage:ignore$
  base64Regex: {
    // paddingRequired
    true: {
      // urlSafe
      true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
      false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
    },
    false: {
      true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
      false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
    }
  },
  dataUriRegex: {
    format: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
    base64: {
      // paddingRequired
      true: /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/,
      false: /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
    }
  },
  hexRegex: /^[a-f0-9]+$/i,
  hostRegex: /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/,
  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),
  isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
  guidBrackets: {
    '{': '}',
    '[': ']',
    '(': ')',
    '': ''
  },
  guidVersions: {
    uuidv1: '1',
    uuidv2: '2',
    uuidv3: '3',
    uuidv4: '4',
    uuidv5: '5'
  },
  cidrPresences: ['required', 'optional', 'forbidden'],
  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
};
module.exports = Any.extend({
  type: 'string',
  flags: {
    insensitive: {
      default: false
    },
    truncate: {
      default: false
    }
  },
  terms: {
    replacements: {
      init: null
    }
  },
  coerce: {
    from: 'string',

    method(value, _ref) {
      var schema = _ref.schema,
          state = _ref.state,
          prefs = _ref.prefs;
      var normalize = schema.$_getRule('normalize');

      if (normalize) {
        value = value.normalize(normalize.args.form);
      }

      var casing = schema.$_getRule('case');

      if (casing) {
        value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
      }

      var trim = schema.$_getRule('trim');

      if (trim && trim.args.enabled) {
        value = value.trim();
      }

      if (schema.$_terms.replacements) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = schema.$_terms.replacements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var replacement = _step.value;
            value = value.replace(replacement.pattern, replacement.replacement);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      var hex = schema.$_getRule('hex');

      if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
        value = `0${value}`;
      }

      if (schema.$_getRule('isoDate')) {
        var iso = internals.isoDate(value);

        if (iso) {
          value = iso;
        }
      }

      if (schema._flags.truncate) {
        var rule = schema.$_getRule('max');

        if (rule) {
          var limit = rule.args.limit;

          if (Common.isResolvable(limit)) {
            limit = limit.resolve(value, state, prefs);

            if (!Common.limit(limit)) {
              return {
                value,
                errors: schema.$_createError('any.ref', limit, {
                  ref: rule.args.limit,
                  arg: 'limit',
                  reason: 'must be a positive integer'
                }, state, prefs)
              };
            }
          }

          value = value.slice(0, limit);
        }
      }

      return {
        value
      };
    }

  },

  validate(value, _ref2) {
    var error = _ref2.error;

    if (typeof value !== 'string') {
      return {
        value,
        errors: error('string.base')
      };
    }

    if (value === '') {
      return {
        value,
        errors: error('string.empty')
      };
    }
  },

  rules: {
    alphanum: {
      method() {
        return this.$_addRule('alphanum');
      },

      validate(value, helpers) {
        if (/^[a-zA-Z0-9]+$/.test(value)) {
          return value;
        }

        return helpers.error('string.alphanum');
      }

    },
    base64: {
      method() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Common.assertOptions(options, ['paddingRequired', 'urlSafe']);
        options = _objectSpread({
          urlSafe: false,
          paddingRequired: true
        }, options);
        Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');
        Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');
        return this.$_addRule({
          name: 'base64',
          args: {
            options
          }
        });
      },

      validate(value, helpers, _ref3) {
        var options = _ref3.options;
        var regex = internals.base64Regex[options.paddingRequired][options.urlSafe];

        if (regex.test(value)) {
          return value;
        }

        return helpers.error('string.base64');
      }

    },
    case: {
      method(direction) {
        Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);
        return this.$_addRule({
          name: 'case',
          args: {
            direction
          }
        });
      },

      validate(value, helpers, _ref4) {
        var direction = _ref4.direction;

        if (direction === 'lower' && value === value.toLocaleLowerCase() || direction === 'upper' && value === value.toLocaleUpperCase()) {
          return value;
        }

        return helpers.error(`string.${direction}case`);
      },

      convert: true
    },
    creditCard: {
      method() {
        return this.$_addRule('creditCard');
      },

      validate(value, helpers) {
        var i = value.length;
        var sum = 0;
        var mul = 1;

        while (i--) {
          var char = value.charAt(i) * mul;
          sum = sum + (char - (char > 9) * 9);
          mul = mul ^ 3;
        }

        if (sum > 0 && sum % 10 === 0) {
          return value;
        }

        return helpers.error('string.creditCard');
      }

    },
    dataUri: {
      method() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Common.assertOptions(options, ['paddingRequired']);
        options = _objectSpread({
          paddingRequired: true
        }, options);
        Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');
        return this.$_addRule({
          name: 'dataUri',
          args: {
            options
          }
        });
      },

      validate(value, helpers, _ref5) {
        var options = _ref5.options;
        var matches = value.match(internals.dataUriRegex.format);

        if (matches) {
          if (!matches[2]) {
            return value;
          }

          if (matches[2] !== 'base64') {
            return value;
          }

          var base64regex = internals.dataUriRegex.base64[options.paddingRequired];

          if (base64regex.test(matches[3])) {
            return value;
          }
        }

        return helpers.error('string.dataUri');
      }

    },
    domain: {
      method(options) {
        if (options) {
          Common.assertOptions(options, ['allowUnicode', 'minDomainSegments', 'tlds']);
        }

        var address = internals.addressOptions(options);
        return this.$_addRule({
          name: 'domain',
          args: {
            options
          },
          address
        });
      },

      validate(value, helpers, args, _ref6) {
        var address = _ref6.address;

        if (Domain.isValid(value, address)) {
          return value;
        }

        return helpers.error('string.domain');
      }

    },
    email: {
      method() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Common.assertOptions(options, ['allowUnicode', 'ignoreLength', 'minDomainSegments', 'multiple', 'separator', 'tlds']);
        Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');
        var address = internals.addressOptions(options);
        var regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\s*`);
        return this.$_addRule({
          name: 'email',
          args: {
            options
          },
          regex,
          address
        });
      },

      validate(value, helpers, _ref7, _ref8) {
        var options = _ref7.options;
        var regex = _ref8.regex,
            address = _ref8.address;
        var emails = options.multiple ? value.split(regex) : [value];
        var invalids = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = emails[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var email = _step2.value;

            if (!Email.isValid(email, address)) {
              invalids.push(email);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (!invalids.length) {
          return value;
        }

        return helpers.error('string.email', {
          value,
          invalids
        });
      }

    },
    guid: {
      alias: 'uuid',

      method() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Common.assertOptions(options, ['version']);
        var versionNumbers = '';

        if (options.version) {
          var versions = [].concat(options.version);
          Assert(versions.length >= 1, 'version must have at least 1 valid version specified');
          var set = new Set();

          for (var i = 0; i < versions.length; ++i) {
            var version = versions[i];
            Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
            var versionNumber = internals.guidVersions[version.toLowerCase()];
            Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
            Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');
            versionNumbers += versionNumber;
            set.add(versionNumber);
          }
        }

        var regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, 'i');
        return this.$_addRule({
          name: 'guid',
          args: {
            options
          },
          regex
        });
      },

      validate(value, helpers, args, _ref9) {
        var regex = _ref9.regex;
        var results = regex.exec(value);

        if (!results) {
          return helpers.error('string.guid');
        } // Matching braces


        if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
          return helpers.error('string.guid');
        }

        return value;
      }

    },
    hex: {
      method() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Common.assertOptions(options, ['byteAligned']);
        options = _objectSpread({
          byteAligned: false
        }, options);
        Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');
        return this.$_addRule({
          name: 'hex',
          args: {
            options
          }
        });
      },

      validate(value, helpers, _ref10) {
        var options = _ref10.options;

        if (!internals.hexRegex.test(value)) {
          return helpers.error('string.hex');
        }

        if (options.byteAligned && value.length % 2 !== 0) {
          return helpers.error('string.hexAlign');
        }

        return value;
      }

    },
    hostname: {
      method() {
        return this.$_addRule('hostname');
      },

      validate(value, helpers) {
        if (value.length <= 255 && internals.hostRegex.test(value) || internals.ipRegex.test(value)) {
          return value;
        }

        return helpers.error('string.hostname');
      }

    },
    insensitive: {
      method() {
        return this.$_setFlag('insensitive', true);
      }

    },
    ip: {
      method() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Common.assertOptions(options, ['cidr', 'version']);
        options = Object.assign({}, options); // Shallow cloned

        var regex = internals.ipRegex;

        if (options.cidr) {
          Assert(typeof options.cidr === 'string', 'cidr must be a string');
          options.cidr = options.cidr.toLowerCase();
          Assert(internals.cidrPresences.includes(options.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));

          if (!options.version && options.cidr !== 'optional') {
            regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], options.cidr);
          }
        } else {
          options.cidr = 'optional';
        }

        var versions;

        if (options.version) {
          if (!Array.isArray(options.version)) {
            options.version = [options.version];
          }

          Assert(options.version.length >= 1, 'version must have at least 1 version specified');
          versions = [];

          for (var i = 0; i < options.version.length; ++i) {
            var version = options.version[i];
            Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
            version = version.toLowerCase();
            Assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
            versions.push(version);
          }

          versions = Array.from(new Set(versions));
          regex = Ip.createIpRegex(versions, options.cidr);
        }

        return this.$_addRule({
          name: 'ip',
          args: {
            options
          },
          versions,
          regex
        });
      },

      validate(value, helpers, _ref11, _ref12) {
        var options = _ref11.options;
        var versions = _ref12.versions,
            regex = _ref12.regex;

        if (regex.test(value)) {
          return value;
        }

        if (versions) {
          return helpers.error('string.ipVersion', {
            value,
            cidr: options.cidr,
            version: versions
          });
        }

        return helpers.error('string.ip', {
          value,
          cidr: options.cidr
        });
      }

    },
    isoDate: {
      method() {
        return this.$_addRule('isoDate');
      },

      validate(value, _ref13) {
        var error = _ref13.error;

        if (internals.isoDate(value)) {
          return value;
        }

        return error('string.isoDate');
      }

    },
    isoDuration: {
      method() {
        return this.$_addRule('isoDuration');
      },

      validate(value, helpers) {
        if (internals.isoDurationRegex.test(value)) {
          return value;
        }

        return helpers.error('string.isoDuration');
      }

    },
    length: {
      method(limit, encoding) {
        return internals.length(this, 'length', limit, '=', encoding);
      },

      validate(value, helpers, _ref14, _ref15) {
        var limit = _ref14.limit,
            encoding = _ref14.encoding;
        var name = _ref15.name,
            operator = _ref15.operator,
            args = _ref15.args;
        var length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length; // $lab:coverage:ignore$

        if (Common.compare(length, limit, operator)) {
          return value;
        }

        return helpers.error('string.' + name, {
          limit: args.limit,
          value,
          encoding
        });
      },

      args: [{
        name: 'limit',
        ref: true,
        assert: Common.limit,
        message: 'must be a positive integer'
      }, 'encoding']
    },
    lowercase: {
      method() {
        return this.case('lower');
      }

    },
    max: {
      method(limit, encoding) {
        return internals.length(this, 'max', limit, '<=', encoding);
      },

      args: ['limit', 'encoding']
    },
    min: {
      method(limit, encoding) {
        return internals.length(this, 'min', limit, '>=', encoding);
      },

      args: ['limit', 'encoding']
    },
    normalize: {
      method() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NFC';
        Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));
        return this.$_addRule({
          name: 'normalize',
          args: {
            form
          }
        });
      },

      validate(value, _ref16, _ref17) {
        var error = _ref16.error;
        var form = _ref17.form;

        if (value === value.normalize(form)) {
          return value;
        }

        return error('string.normalize', {
          value,
          form
        });
      },

      convert: true
    },
    pattern: {
      alias: 'regex',

      method(regex) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Assert(regex instanceof RegExp, 'regex must be a RegExp');
        Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');

        if (typeof options === 'string') {
          options = {
            name: options
          };
        }

        Common.assertOptions(options, ['invert', 'name']);
        var errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');
        return this.$_addRule({
          name: 'pattern',
          args: {
            regex,
            options
          },
          errorCode
        });
      },

      validate(value, helpers, _ref18, _ref19) {
        var regex = _ref18.regex,
            options = _ref18.options;
        var errorCode = _ref19.errorCode;
        var patternMatch = regex.test(value);

        if (patternMatch ^ options.invert) {
          return value;
        }

        return helpers.error(errorCode, {
          name: options.name,
          regex,
          value
        });
      },

      args: ['regex', 'options'],
      multi: true
    },
    replace: {
      method(pattern, replacement) {
        if (typeof pattern === 'string') {
          pattern = new RegExp(EscapeRegex(pattern), 'g');
        }

        Assert(pattern instanceof RegExp, 'pattern must be a RegExp');
        Assert(typeof replacement === 'string', 'replacement must be a String');
        var obj = this.clone();

        if (!obj.$_terms.replacements) {
          obj.$_terms.replacements = [];
        }

        obj.$_terms.replacements.push({
          pattern,
          replacement
        });
        return obj;
      }

    },
    token: {
      method() {
        return this.$_addRule('token');
      },

      validate(value, helpers) {
        if (/^\w+$/.test(value)) {
          return value;
        }

        return helpers.error('string.token');
      }

    },
    trim: {
      method() {
        var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        Assert(typeof enabled === 'boolean', 'enabled must be a boolean');
        return this.$_addRule({
          name: 'trim',
          args: {
            enabled
          }
        });
      },

      validate(value, helpers, _ref20) {
        var enabled = _ref20.enabled;

        if (!enabled || value === value.trim()) {
          return value;
        }

        return helpers.error('string.trim');
      },

      convert: true
    },
    truncate: {
      method() {
        var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        Assert(typeof enabled === 'boolean', 'enabled must be a boolean');
        return this.$_setFlag('truncate', enabled);
      }

    },
    uppercase: {
      method() {
        return this.case('upper');
      }

    },
    uri: {
      method() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme']);
        var unknownOptions = Object.keys(options).filter(function (key) {
          return !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets', 'domain'].includes(key);
        });
        Assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);

        if (options.domain) {
          Common.assertOptions(options.domain, ['allowUnicode', 'minDomainSegments', 'tlds']);
        }

        var regex = Uri.createRegex(options);
        var domain = options.domain ? internals.addressOptions(options.domain) : null;
        return this.$_addRule({
          name: 'uri',
          args: {
            options
          },
          regex,
          domain
        });
      },

      validate(value, helpers, _ref21, _ref22) {
        var options = _ref21.options;
        var regex = _ref22.regex,
            domain = _ref22.domain;

        if (['http:/', 'https:/'].includes(value)) {
          // scheme:/ is technically valid but makes no sense
          return helpers.error('string.uri');
        }

        var match = regex.exec(value);

        if (match) {
          if (domain && !Domain.isValid(match[1], domain)) {
            return helpers.error('string.domain', {
              value: match[1]
            });
          }

          return value;
        }

        if (options.relativeOnly) {
          return helpers.error('string.uriRelativeOnly');
        }

        if (options.scheme) {
          return helpers.error('string.uriCustomScheme', {
            scheme: regex.scheme,
            value
          });
        }

        return helpers.error('string.uri');
      }

    }
  },
  manifest: {
    build(obj, desc) {
      if (desc.replacements) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = desc.replacements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _step3$value = _step3.value,
                pattern = _step3$value.pattern,
                replacement = _step3$value.replacement;
            obj = obj.replace(pattern, replacement);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      return obj;
    }

  },
  messages: {
    'string.alphanum': '"{{#label}}" must only contain alpha-numeric characters',
    'string.base': '"{{#label}}" must be a string',
    'string.base64': '"{{#label}}" must be a valid base64 string',
    'string.creditCard': '"{{#label}}" must be a credit card',
    'string.dataUri': '"{{#label}}" must be a valid dataUri string',
    'string.domain': '"{{#label}}" must contain a valid domain name',
    'string.email': '"{{#label}}" must be a valid email',
    'string.empty': '"{{#label}}" is not allowed to be empty',
    'string.guid': '"{{#label}}" must be a valid GUID',
    'string.hex': '"{{#label}}" must only contain hexadecimal characters',
    'string.hexAlign': '"{{#label}}" hex decoded representation must be byte aligned',
    'string.hostname': '"{{#label}}" must be a valid hostname',
    'string.ip': '"{{#label}}" must be a valid ip address with a {{#cidr}} CIDR',
    'string.ipVersion': '"{{#label}}" must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',
    'string.isoDate': '"{{#label}}" must be in iso format',
    'string.isoDuration': '"{{#label}}" must be a valid ISO 8601 duration',
    'string.length': '"{{#label}}" length must be {{#limit}} characters long',
    'string.lowercase': '"{{#label}}" must only contain lowercase characters',
    'string.max': '"{{#label}}" length must be less than or equal to {{#limit}} characters long',
    'string.min': '"{{#label}}" length must be at least {{#limit}} characters long',
    'string.normalize': '"{{#label}}" must be unicode normalized in the {{#form}} form',
    'string.token': '"{{#label}}" must only contain alpha-numeric and underscore characters',
    'string.pattern.base': '"{{#label}}" with value "{[.]}" fails to match the required pattern: {{#regex}}',
    'string.pattern.name': '"{{#label}}" with value "{[.]}" fails to match the {{#name}} pattern',
    'string.pattern.invert.base': '"{{#label}}" with value "{[.]}" matches the inverted pattern: {{#regex}}',
    'string.pattern.invert.name': '"{{#label}}" with value "{[.]}" matches the inverted {{#name}} pattern',
    'string.trim': '"{{#label}}" must not have leading or trailing whitespace',
    'string.uri': '"{{#label}}" must be a valid uri',
    'string.uriCustomScheme': '"{{#label}}" must be a valid uri with a scheme matching the {{#scheme}} pattern',
    'string.uriRelativeOnly': '"{{#label}}" must be a valid relative uri',
    'string.uppercase': '"{{#label}}" must only contain uppercase characters'
  }
}); // Helpers

internals.addressOptions = function (options) {
  if (!options) {
    return options;
  } // minDomainSegments


  Assert(options.minDomainSegments === undefined || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer'); // tlds

  if (options.tlds === false) {
    return options;
  }

  if (options.tlds === true || options.tlds === undefined) {
    Assert(internals.tlds, 'Built-in TLD list disabled');
    return Object.assign({}, options, internals.tlds);
  }

  Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');
  var deny = options.tlds.deny;

  if (deny) {
    if (Array.isArray(deny)) {
      options = Object.assign({}, options, {
        tlds: {
          deny: new Set(deny)
        }
      });
    }

    Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');
    Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');
    return options;
  }

  var allow = options.tlds.allow;

  if (!allow) {
    return options;
  }

  if (allow === true) {
    Assert(internals.tlds, 'Built-in TLD list disabled');
    return Object.assign({}, options, internals.tlds);
  }

  if (Array.isArray(allow)) {
    options = Object.assign({}, options, {
      tlds: {
        allow: new Set(allow)
      }
    });
  }

  Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');
  return options;
};

internals.isoDate = function (value) {
  if (!Common.isIsoDate(value)) {
    return null;
  }

  var date = new Date(value);

  if (isNaN(date.getTime())) {
    return null;
  }

  return date.toISOString();
};

internals.length = function (schema, name, limit, operator, encoding) {
  Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding); // $lab:coverage:ignore$

  return schema.$_addRule({
    name,
    method: 'length',
    args: {
      limit,
      encoding
    },
    operator
  });
};