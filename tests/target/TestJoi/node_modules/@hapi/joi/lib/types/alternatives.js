'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var Assert = require('@hapi/hoek/lib/assert');

var Any = require('./any');

var Common = require('../common');

var Compile = require('../compile');

var Errors = require('../errors');

var Ref = require('../ref');

var internals = {};
module.exports = Any.extend({
  type: 'alternatives',
  flags: {
    match: {
      default: 'any'
    } // 'any', 'one', 'all'

  },
  terms: {
    matches: {
      init: [],
      register: Ref.toSibling
    }
  },

  args(schema) {
    for (var _len = arguments.length, schemas = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      schemas[_key - 1] = arguments[_key];
    }

    if (schemas.length === 1) {
      if (Array.isArray(schemas[0])) {
        return schema.try(...schemas[0]);
      }
    }

    return schema.try(...schemas);
  },

  validate(value, helpers) {
    var schema = helpers.schema,
        error = helpers.error,
        state = helpers.state,
        prefs = helpers.prefs; // Match all or one

    if (schema._flags.match) {
      var hits = 0;
      var matched;

      for (var i = 0; i < schema.$_terms.matches.length; ++i) {
        var item = schema.$_terms.matches[i];
        var localState = state.nest(item.schema, `match.${i}`);
        localState.snapshot();
        var result = item.schema.$_validate(value, localState, prefs);

        if (!result.errors) {
          ++hits;
          matched = result.value;
        } else {
          localState.restore();
        }
      }

      if (!hits) {
        return {
          errors: error('alternatives.any')
        };
      }

      if (schema._flags.match === 'one') {
        return hits === 1 ? {
          value: matched
        } : {
          errors: error('alternatives.one')
        };
      }

      return hits === schema.$_terms.matches.length ? {
        value
      } : {
        errors: error('alternatives.all')
      };
    } // Match any


    var errors = [];

    for (var _i = 0; _i < schema.$_terms.matches.length; ++_i) {
      var _item = schema.$_terms.matches[_i]; // Try

      if (_item.schema) {
        var _localState = state.nest(_item.schema, `match.${_i}`);

        _localState.snapshot();

        var _result = _item.schema.$_validate(value, _localState, prefs);

        if (!_result.errors) {
          return _result;
        }

        _localState.restore();

        errors.push({
          schema: _item.schema,
          reports: _result.errors
        });
        continue;
      } // Conditional


      var input = _item.ref ? _item.ref.resolve(value, state, prefs) : value;
      var tests = _item.is ? [_item] : _item.switch;

      for (var j = 0; j < tests.length; ++j) {
        var test = tests[j];
        var is = test.is,
            then = test.then,
            otherwise = test.otherwise;
        var id = `match.${_i}${_item.switch ? '.' + j : ''}`;

        if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
          if (otherwise) {
            return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
          }
        } else if (then) {
          return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
        }
      }
    }

    return internals.errors(errors, helpers);
  },

  rules: {
    conditional: {
      method(condition, options) {
        Assert(!this._flags._endedSwitch, 'Unreachable condition');
        Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');
        Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');
        var obj = this.clone();
        var match = Compile.when(obj, condition, options);
        var conditions = match.is ? [match] : match.switch;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = conditions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            if (item.then && item.otherwise) {
              obj.$_setFlag('_endedSwitch', true, {
                clone: false
              });
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        obj.$_terms.matches.push(match);
        return obj.$_mutateRebuild();
      }

    },
    match: {
      method(mode) {
        Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);

        if (mode !== 'any') {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this.$_terms.matches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var match = _step2.value;
              Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        return this.$_setFlag('match', mode);
      }

    },
    try: {
      method() {
        for (var _len2 = arguments.length, schemas = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          schemas[_key2] = arguments[_key2];
        }

        Assert(schemas.length, 'Missing alternative schemas');
        Common.verifyFlat(schemas, 'try');
        Assert(!this._flags._endedSwitch, 'Unreachable condition');
        var obj = this.clone();

        for (var _i2 = 0, _schemas = schemas; _i2 < _schemas.length; _i2++) {
          var schema = _schemas[_i2];
          obj.$_terms.matches.push({
            schema: obj.$_compile(schema)
          });
        }

        return obj.$_mutateRebuild();
      }

    }
  },
  overrides: {
    label(name) {
      var obj = this.$_super.label(name);

      var each = function each(item, source) {
        return source.path[0] !== 'is' ? item.label(name) : undefined;
      };

      return obj.$_modify({
        each,
        ref: false
      });
    }

  },

  rebuild(schema) {
    // Flag when an alternative type is an array
    var each = function each(item) {
      if (Common.isSchema(item) && item.type === 'array') {
        schema.$_setFlag('_arrayItems', true, {
          clone: false
        });
      }
    };

    schema.$_modify({
      each
    });
  },

  manifest: {
    build(obj, desc) {
      if (desc.matches) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = desc.matches[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var match = _step3.value;
            var schema = match.schema,
                ref = match.ref,
                is = match.is,
                not = match.not,
                then = match.then,
                otherwise = match.otherwise;

            if (schema) {
              obj = obj.try(schema);
            } else if (ref) {
              obj = obj.conditional(ref, {
                is,
                then,
                not,
                otherwise,
                switch: match.switch
              });
            } else {
              obj = obj.conditional(is, {
                then,
                otherwise
              });
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      return obj;
    }

  },
  messages: {
    'alternatives.all': '"{{#label}}" does not match all of the required types',
    'alternatives.any': '"{{#label}}" does not match any of the allowed types',
    'alternatives.match': '"{{#label}}" does not match any of the allowed types',
    'alternatives.one': '"{{#label}}" matches more than one allowed type',
    'alternatives.types': '"{{#label}}" must be one of {{#types}}'
  }
}); // Helpers

internals.errors = function (failures, _ref) {
  var error = _ref.error,
      state = _ref.state;

  // Nothing matched due to type criteria rules
  if (!failures.length) {
    return {
      errors: error('alternatives.any')
    };
  } // Single error


  if (failures.length === 1) {
    return {
      errors: failures[0].reports
    };
  } // Analyze reasons


  var valids = new Set();
  var complex = [];
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = failures[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _step4$value = _step4.value,
          reports = _step4$value.reports,
          schema = _step4$value.schema;

      // Multiple errors (!abortEarly)
      if (reports.length > 1) {
        return internals.unmatched(failures, error);
      } // Custom error


      var report = reports[0];

      if (report instanceof Errors.Report === false) {
        return internals.unmatched(failures, error);
      } // Internal object or array error


      if (report.state.path.length !== state.path.length) {
        complex.push({
          type: schema.type,
          report
        });
        continue;
      } // Valids


      if (report.code === 'any.only') {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = report.local.valids[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var valid = _step5.value;
            valids.add(valid);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        continue;
      } // Base type


      var _report$code$split = report.code.split('.'),
          _report$code$split2 = _slicedToArray(_report$code$split, 2),
          type = _report$code$split2[0],
          code = _report$code$split2[1];

      if (code !== 'base') {
        complex.push({
          type: schema.type,
          report
        });
        continue;
      }

      valids.add(type);
    } // All errors are base types or valids

  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  if (!complex.length) {
    return {
      errors: error('alternatives.types', {
        types: [...valids]
      })
    };
  } // Single complex error


  if (complex.length === 1) {
    return {
      errors: complex[0].report
    };
  }

  return internals.unmatched(failures, error);
};

internals.unmatched = function (failures, error) {
  var errors = [];
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = failures[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var failure = _step6.value;
      errors.push(...failure.reports);
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
        _iterator6.return();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  return {
    errors: error('alternatives.match', Errors.details(errors, {
      override: false
    }))
  };
};