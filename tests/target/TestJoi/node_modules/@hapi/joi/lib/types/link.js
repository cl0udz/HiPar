'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.to-string");

var Assert = require('@hapi/hoek/lib/assert');

var Any = require('./any');

var Common = require('../common');

var Compile = require('../compile');

var Errors = require('../errors');

var internals = {};
module.exports = Any.extend({
  type: 'link',
  properties: {
    schemaChain: true
  },
  terms: {
    link: {
      init: null,
      manifest: 'single',
      register: false
    }
  },

  args(schema, ref) {
    return schema.ref(ref);
  },

  validate(value, _ref) {
    var schema = _ref.schema,
        state = _ref.state,
        prefs = _ref.prefs;
    Assert(schema.$_terms.link, 'Uninitialized link schema');
    var linked = internals.generate(schema, value, state, prefs);
    var ref = schema.$_terms.link[0].ref;
    return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
  },

  generate(schema, value, state, prefs) {
    return internals.generate(schema, value, state, prefs);
  },

  rules: {
    ref: {
      method(ref) {
        Assert(!this.$_terms.link, 'Cannot reinitialize schema');
        ref = Compile.ref(ref);
        Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);
        Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');
        var obj = this.clone();
        obj.$_terms.link = [{
          ref
        }];
        return obj;
      }

    },
    relative: {
      method() {
        var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return this.$_setFlag('relative', enabled);
      }

    }
  },
  overrides: {
    concat(source) {
      Assert(this.$_terms.link, 'Uninitialized link schema');
      Assert(Common.isSchema(source), 'Invalid schema object');
      Assert(source.type !== 'link', 'Cannot merge type link with another link');
      var obj = this.clone();

      if (!obj.$_terms.whens) {
        obj.$_terms.whens = [];
      }

      obj.$_terms.whens.push({
        concat: source
      });
      return obj.$_mutateRebuild();
    }

  },
  manifest: {
    build(obj, desc) {
      Assert(desc.link, 'Invalid link description missing link');
      return obj.ref(desc.link);
    }

  }
}); // Helpers

internals.generate = function (schema, value, state, prefs) {
  var linked = state.mainstay.links.get(schema);

  if (linked) {
    return linked._generate(value, state, prefs).schema;
  }

  var ref = schema.$_terms.link[0].ref;

  var _internals$perspectiv = internals.perspective(ref, state),
      perspective = _internals$perspectiv.perspective,
      path = _internals$perspectiv.path;

  internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);

  try {
    linked = path.length ? perspective.$_reach(path) : perspective;
  } catch (ignoreErr) {
    internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);
  }

  internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);

  if (!schema._flags.relative) {
    state.mainstay.links.set(schema, linked);
  }

  return linked._generate(value, state, prefs).schema;
};

internals.perspective = function (ref, state) {
  if (ref.type === 'local') {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = state.schemas[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _step.value,
            schema = _step$value.schema,
            key = _step$value.key;
        // From parent to root
        var id = schema._flags.id || key;

        if (id === ref.path[0]) {
          return {
            perspective: schema,
            path: ref.path.slice(1)
          };
        }

        if (schema.$_terms.shared) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = schema.$_terms.shared[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var shared = _step2.value;

              if (shared._flags.id === ref.path[0]) {
                return {
                  perspective: shared,
                  path: ref.path.slice(1)
                };
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return {
      perspective: null,
      path: null
    };
  }

  if (ref.ancestor === 'root') {
    return {
      perspective: state.schemas[state.schemas.length - 1].schema,
      path: ref.path
    };
  }

  return {
    perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema,
    path: ref.path
  };
};

internals.assert = function (condition, message, ref, schema, state, prefs) {
  if (condition) {
    // Manual check to avoid generating error message on success
    return;
  }

  Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
};