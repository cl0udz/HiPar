'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Clone = require('@hapi/hoek/lib/clone');

var Reach = require('@hapi/hoek/lib/reach');

var Common = require('./common');

var internals = {
  value: Symbol('value')
};

module.exports = internals.State =
/*#__PURE__*/
function () {
  function _class(path, ancestors, state) {
    _classCallCheck(this, _class);

    this.path = path;
    this.ancestors = ancestors; // [parent, ..., root]

    this.mainstay = state.mainstay;
    this.schemas = state.schemas; // [current, ..., root]

    this.debug = null;
  }

  _createClass(_class, [{
    key: "localize",
    value: function localize(path) {
      var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var schema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var state = new internals.State(path, ancestors, this);

      if (schema && state.schemas) {
        state.schemas = [internals.schemas(schema)].concat(_toConsumableArray(state.schemas));
      }

      return state;
    }
  }, {
    key: "nest",
    value: function nest(schema, debug) {
      var state = new internals.State(this.path, this.ancestors, this);
      state.schemas = state.schemas && [internals.schemas(schema)].concat(_toConsumableArray(state.schemas));
      state.debug = debug;
      return state;
    }
  }, {
    key: "shadow",
    value: function shadow(value, reason) {
      this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
      this.mainstay.shadow.set(this.path, value, reason);
    }
  }, {
    key: "snapshot",
    value: function snapshot() {
      if (this.mainstay.shadow) {
        this._snapshot = Clone(this.mainstay.shadow.node(this.path));
      }
    }
  }, {
    key: "restore",
    value: function restore() {
      if (this.mainstay.shadow) {
        this.mainstay.shadow.override(this.path, this._snapshot);
        this._snapshot = undefined;
      }
    }
  }]);

  return _class;
}();

internals.schemas = function (schema) {
  if (Common.isSchema(schema)) {
    return {
      schema: schema
    };
  }

  return schema;
};

internals.Shadow =
/*#__PURE__*/
function () {
  function _class2() {
    _classCallCheck(this, _class2);

    this._values = null;
  }

  _createClass(_class2, [{
    key: "set",
    value: function set(path, value, reason) {
      if (!path.length) {
        // No need to store root value
        return;
      }

      if (reason === 'strip' && typeof path[path.length - 1] === 'number') {
        // Cannot store stripped array values (due to shift)
        return;
      }

      this._values = this._values || new Map();
      var node = this._values;

      for (var i = 0; i < path.length; ++i) {
        var segment = path[i];
        var next = node.get(segment);

        if (!next) {
          next = new Map();
          node.set(segment, next);
        }

        node = next;
      }

      node[internals.value] = value;
    }
  }, {
    key: "get",
    value: function get(path) {
      var node = this.node(path);

      if (node) {
        return node[internals.value];
      }
    }
  }, {
    key: "node",
    value: function node(path) {
      if (!this._values) {
        return;
      }

      return Reach(this._values, path, {
        iterables: true
      });
    }
  }, {
    key: "override",
    value: function override(path, node) {
      if (!this._values) {
        return;
      }

      var parents = path.slice(0, -1);
      var own = path[path.length - 1];
      var parent = Reach(this._values, parents, {
        iterables: true
      });

      if (node) {
        parent.set(own, node);
        return;
      }

      if (parent) {
        parent["delete"](own);
      }
    }
  }]);

  return _class2;
}();