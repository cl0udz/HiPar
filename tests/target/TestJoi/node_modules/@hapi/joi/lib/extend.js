'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Common = require('./common');

var Messages = require('./messages');

var internals = {};

exports.type = function (from, options) {
  var base = Object.getPrototypeOf(from);
  var prototype = Clone(base);

  var schema = from._assign(Object.create(prototype));

  var def = Object.assign({}, options); // Shallow cloned

  delete def.base;
  prototype._definition = def;
  var parent = base._definition || {};
  def.messages = Messages.merge(parent.messages, def.messages);
  def.properties = Object.assign({}, parent.properties, def.properties); // Type

  schema.type = def.type; // Flags

  def.flags = Object.assign({}, parent.flags, def.flags); // Terms

  var terms = Object.assign({}, parent.terms);

  if (def.terms) {
    for (var name in def.terms) {
      // Only apply own terms
      var term = def.terms[name];
      Assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);
      schema.$_terms[name] = term.init;
      terms[name] = term;
    }
  }

  def.terms = terms; // Constructor arguments

  if (!def.args) {
    def.args = parent.args;
  } // Prepare


  def.prepare = internals.prepare(def.prepare, parent.prepare); // Coerce

  if (def.coerce) {
    if (typeof def.coerce === 'function') {
      def.coerce = {
        method: def.coerce
      };
    }

    if (def.coerce.from && !Array.isArray(def.coerce.from)) {
      def.coerce = {
        method: def.coerce.method,
        from: [].concat(def.coerce.from)
      };
    }
  }

  def.coerce = internals.coerce(def.coerce, parent.coerce); // Validate

  def.validate = internals.validate(def.validate, parent.validate); // Rules

  var rules = Object.assign({}, parent.rules);

  if (def.rules) {
    var _loop = function _loop(_name) {
      var rule = def.rules[_name];
      Assert(_typeof(rule) === 'object', 'Invalid rule definition for', def.type, _name);
      var method = rule.method;

      if (method === undefined) {
        method = function method() {
          return this.$_addRule(_name);
        };
      }

      if (method) {
        Assert(!prototype[_name], 'Rule conflict in', def.type, _name);
        prototype[_name] = method;
      }

      Assert(!rules[_name], 'Rule conflict in', def.type, _name);
      rules[_name] = rule;

      if (rule.alias) {
        var aliases = [].concat(rule.alias);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var alias = _step.value;
            prototype[alias] = rule.method;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      if (rule.args) {
        rule.argsByName = new Map();
        rule.args = rule.args.map(function (arg) {
          if (typeof arg === 'string') {
            arg = {
              name: arg
            };
          }

          Assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);

          if (Common.isSchema(arg.assert)) {
            arg.assert = arg.assert.strict().label(arg.name);
          }

          rule.argsByName.set(arg.name, arg);
          return arg;
        });
      }
    };

    for (var _name in def.rules) {
      _loop(_name);
    }
  }

  def.rules = rules; // Modifiers

  var modifiers = Object.assign({}, parent.modifiers);

  if (def.modifiers) {
    var _loop2 = function _loop2(_name2) {
      Assert(!prototype[_name2], 'Rule conflict in', def.type, _name2);
      var modifier = def.modifiers[_name2];
      Assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, _name2);

      var method = function method(arg) {
        return this.rule(_defineProperty({}, _name2, arg));
      };

      prototype[_name2] = method;
      modifiers[_name2] = modifier;
    };

    for (var _name2 in def.modifiers) {
      _loop2(_name2);
    }
  }

  def.modifiers = modifiers; // Overrides

  if (def.overrides) {
    prototype._super = base;
    schema.$_super = {};

    for (var override in def.overrides) {
      Assert(base[override], 'Cannot override missing', override);
      schema.$_super[override] = base[override].bind(schema);
    }

    Object.assign(prototype, def.overrides);
  } // Casts


  def.cast = Object.assign({}, parent.cast, def.cast); // Manifest

  var manifest = Object.assign({}, parent.manifest, def.manifest);
  manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
  def.manifest = manifest; // Rebuild

  def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
  return schema;
}; // Helpers


internals.build = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return function (obj, desc) {
    return parent(child(obj, desc), desc);
  };
};

internals.coerce = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return {
    from: child.from && parent.from ? _toConsumableArray(new Set([].concat(_toConsumableArray(child.from), _toConsumableArray(parent.from)))) : null,
    method: function method(value, helpers) {
      var coerced;

      if (!parent.from || parent.from.includes(_typeof(value))) {
        coerced = parent.method(value, helpers);

        if (coerced) {
          if (coerced.errors || coerced.value === undefined) {
            return coerced;
          }

          value = coerced.value;
        }
      }

      if (!child.from || child.from.includes(_typeof(value))) {
        var own = child.method(value, helpers);

        if (own) {
          return own;
        }
      }

      return coerced;
    }
  };
};

internals.prepare = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return function (value, helpers) {
    var prepared = child(value, helpers);

    if (prepared) {
      if (prepared.errors || prepared.value === undefined) {
        return prepared;
      }

      value = prepared.value;
    }

    return parent(value, helpers) || prepared;
  };
};

internals.rebuild = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return function (schema) {
    parent(schema);
    child(schema);
  };
};

internals.validate = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return function (value, helpers) {
    var result = parent(value, helpers);

    if (result) {
      if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
        return result;
      }

      value = result.value;
    }

    return child(value, helpers) || result;
  };
};