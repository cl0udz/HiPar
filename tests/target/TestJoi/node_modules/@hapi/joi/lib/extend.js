'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.map");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.flags");

require("core-js/modules/es.set");

require("core-js/modules/es.string.includes");

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Common = require('./common');

var Messages = require('./messages');

var internals = {};

exports.type = function (from, options) {
  var base = Object.getPrototypeOf(from);
  var prototype = Clone(base);

  var schema = from._assign(Object.create(prototype));

  var def = Object.assign({}, options); // Shallow cloned

  delete def.base;
  prototype._definition = def;
  var parent = base._definition || {};
  def.messages = Messages.merge(parent.messages, def.messages);
  def.properties = Object.assign({}, parent.properties, def.properties); // Type

  schema.type = def.type; // Flags

  def.flags = Object.assign({}, parent.flags, def.flags); // Terms

  var terms = Object.assign({}, parent.terms);

  if (def.terms) {
    for (var name in def.terms) {
      // Only apply own terms
      var term = def.terms[name];
      Assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);
      schema.$_terms[name] = term.init;
      terms[name] = term;
    }
  }

  def.terms = terms; // Constructor arguments

  if (!def.args) {
    def.args = parent.args;
  } // Prepare


  def.prepare = internals.prepare(def.prepare, parent.prepare); // Coerce

  if (def.coerce) {
    if (typeof def.coerce === 'function') {
      def.coerce = {
        method: def.coerce
      };
    }

    if (def.coerce.from && !Array.isArray(def.coerce.from)) {
      def.coerce = {
        method: def.coerce.method,
        from: [].concat(def.coerce.from)
      };
    }
  }

  def.coerce = internals.coerce(def.coerce, parent.coerce); // Validate

  def.validate = internals.validate(def.validate, parent.validate); // Rules

  var rules = Object.assign({}, parent.rules);

  if (def.rules) {
    var _loop = function _loop(_name) {
      var rule = def.rules[_name];
      Assert(typeof rule === 'object', 'Invalid rule definition for', def.type, _name);
      var method = rule.method;

      if (method === undefined) {
        method = function method() {
          return this.$_addRule(_name);
        };
      }

      if (method) {
        Assert(!prototype[_name], 'Rule conflict in', def.type, _name);
        prototype[_name] = method;
      }

      Assert(!rules[_name], 'Rule conflict in', def.type, _name);
      rules[_name] = rule;

      if (rule.alias) {
        var aliases = [].concat(rule.alias);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var alias = _step.value;
            prototype[alias] = rule.method;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      if (rule.args) {
        rule.argsByName = new Map();
        rule.args = rule.args.map(function (arg) {
          if (typeof arg === 'string') {
            arg = {
              name: arg
            };
          }

          Assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);

          if (Common.isSchema(arg.assert)) {
            arg.assert = arg.assert.strict().label(arg.name);
          }

          rule.argsByName.set(arg.name, arg);
          return arg;
        });
      }
    };

    for (var _name in def.rules) {
      _loop(_name);
    }
  }

  def.rules = rules; // Modifiers

  var modifiers = Object.assign({}, parent.modifiers);

  if (def.modifiers) {
    var _loop2 = function _loop2(_name2) {
      Assert(!prototype[_name2], 'Rule conflict in', def.type, _name2);
      var modifier = def.modifiers[_name2];
      Assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, _name2);

      var method = function method(arg) {
        return this.rule({
          [_name2]: arg
        });
      };

      prototype[_name2] = method;
      modifiers[_name2] = modifier;
    };

    for (var _name2 in def.modifiers) {
      _loop2(_name2);
    }
  }

  def.modifiers = modifiers; // Overrides

  if (def.overrides) {
    prototype._super = base;
    schema.$_super = {};

    for (var override in def.overrides) {
      Assert(base[override], 'Cannot override missing', override);
      schema.$_super[override] = base[override].bind(schema);
    }

    Object.assign(prototype, def.overrides);
  } // Casts


  def.cast = Object.assign({}, parent.cast, def.cast); // Manifest

  var manifest = Object.assign({}, parent.manifest, def.manifest);
  manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
  def.manifest = manifest; // Rebuild

  def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
  return schema;
}; // Helpers


internals.build = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return function (obj, desc) {
    return parent(child(obj, desc), desc);
  };
};

internals.coerce = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return {
    from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,

    method(value, helpers) {
      var coerced;

      if (!parent.from || parent.from.includes(typeof value)) {
        coerced = parent.method(value, helpers);

        if (coerced) {
          if (coerced.errors || coerced.value === undefined) {
            return coerced;
          }

          value = coerced.value;
        }
      }

      if (!child.from || child.from.includes(typeof value)) {
        var own = child.method(value, helpers);

        if (own) {
          return own;
        }
      }

      return coerced;
    }

  };
};

internals.prepare = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return function (value, helpers) {
    var prepared = child(value, helpers);

    if (prepared) {
      if (prepared.errors || prepared.value === undefined) {
        return prepared;
      }

      value = prepared.value;
    }

    return parent(value, helpers) || prepared;
  };
};

internals.rebuild = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return function (schema) {
    parent(schema);
    child(schema);
  };
};

internals.validate = function (child, parent) {
  if (!child || !parent) {
    return child || parent;
  }

  return function (value, helpers) {
    var result = parent(value, helpers);

    if (result) {
      if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
        return result;
      }

      value = result.value;
    }

    return child(value, helpers) || result;
  };
};