'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Ignore = require('@hapi/hoek/lib/ignore');

var Reach = require('@hapi/hoek/lib/reach');

var Common = require('./common');

var Errors = require('./errors');

var State = require('./state');

var internals = {
  result: Symbol('result')
};

exports.entry = function (value, schema, prefs) {
  var settings = Common.defaults;

  if (prefs) {
    Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');
    settings = Common.preferences(Common.defaults, prefs);
  }

  var result = internals.entry(value, schema, settings);
  Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');
  var outcome = {
    value: result.value
  };

  if (result.error) {
    outcome.error = result.error;
  }

  if (result.mainstay.warnings.length) {
    outcome.warning = Errors.details(result.mainstay.warnings);
  }

  if (result.mainstay.debug) {
    outcome.debug = result.mainstay.debug;
  }

  return outcome;
};

exports.entryAsync = function _callee(value, schema, prefs) {
  var settings, result, mainstay, root, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, method, path, label, node, key, parent, output, outcome;

  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          settings = Common.defaults;

          if (prefs) {
            settings = Common.preferences(Common.defaults, prefs);
          }

          result = internals.entry(value, schema, settings);
          mainstay = result.mainstay;

          if (!result.error) {
            _context.next = 7;
            break;
          }

          if (mainstay.debug) {
            result.error.debug = mainstay.debug;
          }

          throw result.error;

        case 7:
          if (!mainstay.externals.length) {
            _context.next = 51;
            break;
          }

          root = result.value;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 12;
          _iterator = mainstay.externals[Symbol.iterator]();

        case 14:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 36;
            break;
          }

          _step$value = _step.value, method = _step$value.method, path = _step$value.path, label = _step$value.label;
          node = root;
          key = void 0;
          parent = void 0;

          if (path.length) {
            key = path[path.length - 1];
            parent = Reach(root, path.slice(0, -1));
            node = parent[key];
          }

          _context.prev = 20;
          _context.next = 23;
          return regeneratorRuntime.awrap(method(node));

        case 23:
          output = _context.sent;

          if (!(output === undefined || output === node)) {
            _context.next = 26;
            break;
          }

          return _context.abrupt("continue", 33);

        case 26:
          if (parent) {
            parent[key] = output;
          } else {
            root = output;
          }

          _context.next = 33;
          break;

        case 29:
          _context.prev = 29;
          _context.t0 = _context["catch"](20);
          _context.t0.message += " (".concat(label, ")"); // Change message to include path

          throw _context.t0;

        case 33:
          _iteratorNormalCompletion = true;
          _context.next = 14;
          break;

        case 36:
          _context.next = 42;
          break;

        case 38:
          _context.prev = 38;
          _context.t1 = _context["catch"](12);
          _didIteratorError = true;
          _iteratorError = _context.t1;

        case 42:
          _context.prev = 42;
          _context.prev = 43;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 45:
          _context.prev = 45;

          if (!_didIteratorError) {
            _context.next = 48;
            break;
          }

          throw _iteratorError;

        case 48:
          return _context.finish(45);

        case 49:
          return _context.finish(42);

        case 50:
          result.value = root;

        case 51:
          if (!(!settings.warnings && !settings.debug)) {
            _context.next = 53;
            break;
          }

          return _context.abrupt("return", result.value);

        case 53:
          outcome = {
            value: result.value
          };

          if (mainstay.warnings.length) {
            outcome.warning = Errors.details(mainstay.warnings);
          }

          if (mainstay.debug) {
            outcome.debug = mainstay.debug;
          }

          return _context.abrupt("return", outcome);

        case 57:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[12, 38, 42, 50], [20, 29], [43,, 45, 49]]);
};

internals.entry = function (value, schema, prefs) {
  // Prepare state
  var _internals$tracer = internals.tracer(schema, prefs),
      tracer = _internals$tracer.tracer,
      cleanup = _internals$tracer.cleanup;

  var debug = prefs.debug ? [] : null;
  var links = schema._ids._schemaChain ? new Map() : null;
  var mainstay = {
    externals: [],
    warnings: [],
    tracer: tracer,
    debug: debug,
    links: links
  };
  var schemas = schema._ids._schemaChain ? [{
    schema: schema
  }] : null;
  var state = new State([], [], {
    mainstay: mainstay,
    schemas: schemas
  }); // Validate value

  var result = exports.validate(value, schema, state, prefs); // Process value and errors

  if (cleanup) {
    schema.$_root.untrace();
  }

  var error = Errors.process(result.errors, value, prefs);
  return {
    value: result.value,
    error: error,
    mainstay: mainstay
  };
};

internals.tracer = function (schema, prefs) {
  if (schema.$_root._tracer) {
    return {
      tracer: schema.$_root._tracer._register(schema)
    };
  }

  if (prefs.debug) {
    Assert(schema.$_root.trace, 'Debug mode not supported');
    return {
      tracer: schema.$_root.trace()._register(schema),
      cleanup: true
    };
  }

  return {
    tracer: internals.ignore
  };
};

exports.validate = function (value, schema, state, prefs) {
  var overrides = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  if (schema.$_terms.whens) {
    schema = schema._generate(value, state, prefs).schema;
  } // Setup state and settings


  if (schema._preferences) {
    prefs = internals.prefs(schema, prefs);
  } // Cache


  if (schema._cache && prefs.cache) {
    var result = schema._cache.get(value);

    state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);

    if (result) {
      return result;
    }
  } // Helpers


  var createError = function createError(code, local, localState) {
    return schema.$_createError(code, value, local, localState || state, prefs);
  };

  var helpers = {
    original: value,
    prefs: prefs,
    schema: schema,
    state: state,
    error: createError,
    warn: function warn(code, local, localState) {
      return state.mainstay.warnings.push(createError(code, local, localState));
    },
    message: function message(messages, local) {
      return schema.$_createError('custom', value, local, state, prefs, {
        messages: messages
      });
    }
  }; // Prepare

  state.mainstay.tracer.entry(schema, state);
  var def = schema._definition;

  if (def.prepare && value !== undefined && prefs.convert) {
    var prepared = def.prepare(value, helpers);

    if (prepared) {
      state.mainstay.tracer.value(state, 'prepare', value, prepared.value);

      if (prepared.errors) {
        return internals.finalize(prepared.value, [].concat(prepared.errors), helpers); // Prepare error always aborts early
      }

      value = prepared.value;
    }
  } // Type coercion


  if (def.coerce && value !== undefined && prefs.convert && (!def.coerce.from || def.coerce.from.includes(_typeof(value)))) {
    var coerced = def.coerce.method(value, helpers);

    if (coerced) {
      state.mainstay.tracer.value(state, 'coerced', value, coerced.value);

      if (coerced.errors) {
        return internals.finalize(coerced.value, [].concat(coerced.errors), helpers); // Coerce error always aborts early
      }

      value = coerced.value;
    }
  } // Empty value


  var empty = schema._flags.empty;

  if (empty && empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {
    state.mainstay.tracer.value(state, 'empty', value, undefined);
    value = undefined;
  } // Presence requirements (required, optional, forbidden)


  var presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? 'ignore' : prefs.presence);

  if (value === undefined) {
    if (presence === 'forbidden') {
      return internals.finalize(value, null, helpers);
    }

    if (presence === 'required') {
      return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);
    }

    if (presence === 'optional') {
      if (schema._flags["default"] !== Common.symbols.deepDefault) {
        return internals.finalize(value, null, helpers);
      }

      state.mainstay.tracer.value(state, 'default', value, {});
      value = {};
    }
  } else if (presence === 'forbidden') {
    return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);
  } // Allowed values


  var errors = [];

  if (schema._valids) {
    var match = schema._valids.get(value, state, prefs, schema._flags.insensitive);

    if (match) {
      if (prefs.convert) {
        state.mainstay.tracer.value(state, 'valids', value, match.value);
        value = match.value;
      }

      state.mainstay.tracer.filter(schema, state, 'valid', match);
      return internals.finalize(value, null, helpers);
    }

    if (schema._flags.only) {
      var report = schema.$_createError('any.only', value, {
        valids: schema._valids.values({
          display: true
        })
      }, state, prefs);

      if (prefs.abortEarly) {
        return internals.finalize(value, [report], helpers);
      }

      errors.push(report);
    }
  } // Denied values


  if (schema._invalids) {
    var _match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);

    if (_match) {
      state.mainstay.tracer.filter(schema, state, 'invalid', _match);

      var _report = schema.$_createError('any.invalid', value, {
        invalids: schema._invalids.values({
          display: true
        })
      }, state, prefs);

      if (prefs.abortEarly) {
        return internals.finalize(value, [_report], helpers);
      }

      errors.push(_report);
    }
  } // Base type


  if (def.validate) {
    var base = def.validate(value, helpers);

    if (base) {
      state.mainstay.tracer.value(state, 'base', value, base.value);
      value = base.value;

      if (base.errors) {
        if (!Array.isArray(base.errors)) {
          errors.push(base.errors);
          return internals.finalize(value, errors, helpers); // Base error always aborts early
        }

        if (base.errors.length) {
          errors.push.apply(errors, _toConsumableArray(base.errors));
          return internals.finalize(value, errors, helpers); // Base error always aborts early
        }
      }
    }
  } // Validate tests


  if (!schema._rules.length) {
    return internals.finalize(value, errors, helpers);
  }

  return internals.rules(value, errors, helpers);
};

internals.rules = function (value, errors, helpers) {
  var schema = helpers.schema,
      state = helpers.state,
      prefs = helpers.prefs;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = schema._rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var rule = _step2.value;
      var definition = schema._definition.rules[rule.method]; // Skip rules that are also applied in coerce step

      if (definition.convert && prefs.convert) {
        state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');
        continue;
      } // Resolve references


      var ret = void 0;
      var args = rule.args;

      if (rule._resolve.length) {
        args = Object.assign({}, args); // Shallow copy

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = rule._resolve[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var key = _step3.value;
            var resolver = definition.argsByName.get(key);
            var resolved = args[key].resolve(value, state, prefs);
            var normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            var invalid = Common.validateArg(normalized, null, resolver);

            if (invalid) {
              ret = schema.$_createError('any.ref', resolved, {
                arg: key,
                ref: args[key],
                reason: invalid
              }, state, prefs);
              break;
            }

            args[key] = normalized;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      } // Test rule


      ret = ret || definition.validate(value, helpers, args, rule); // Use ret if already set to reference error

      var result = internals.rule(ret, rule);

      if (result.errors) {
        state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');

        if (rule.warn) {
          var _state$mainstay$warni;

          (_state$mainstay$warni = state.mainstay.warnings).push.apply(_state$mainstay$warni, _toConsumableArray(result.errors));

          continue;
        }

        if (prefs.abortEarly) {
          return internals.finalize(value, result.errors, helpers);
        }

        errors.push.apply(errors, _toConsumableArray(result.errors));
      } else {
        state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');
        state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);
        value = result.value;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return internals.finalize(value, errors, helpers);
};

internals.rule = function (ret, rule) {
  if (ret instanceof Errors.Report) {
    internals.error(ret, rule);
    return {
      errors: [ret],
      value: null
    };
  }

  if (Array.isArray(ret) && (ret[0] instanceof Errors.Report || ret[0] instanceof Error)) {
    ret.forEach(function (report) {
      return internals.error(report, rule);
    });
    return {
      errors: ret,
      value: null
    };
  }

  return {
    errors: null,
    value: ret
  };
};

internals.error = function (report, rule) {
  if (rule.message) {
    report._setTemplate(rule.message);
  }

  return report;
};

internals.finalize = function (value, errors, helpers) {
  errors = errors || [];
  var schema = helpers.schema,
      state = helpers.state,
      prefs = helpers.prefs; // Failover value

  if (errors.length) {
    var failover = internals["default"]('failover', undefined, errors, helpers);

    if (failover !== undefined) {
      state.mainstay.tracer.value(state, 'failover', value, failover);
      value = failover;
      errors = [];
    }
  } // Error override


  if (errors.length && schema._flags.error) {
    if (typeof schema._flags.error === 'function') {
      errors = schema._flags.error(errors);

      if (!Array.isArray(errors)) {
        errors = [errors];
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = errors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var error = _step4.value;
          Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    } else {
      errors = [schema._flags.error];
    }
  } // Default


  if (value === undefined) {
    var defaulted = internals["default"]('default', value, errors, helpers);
    state.mainstay.tracer.value(state, 'default', value, defaulted);
    value = defaulted;
  } // Cast


  if (schema._flags.cast && value !== undefined) {
    var caster = schema._definition.cast[schema._flags.cast];

    if (caster.from(value)) {
      var casted = caster.to(value, helpers);
      state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);
      value = casted;
    }
  } // Externals


  if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {
    // Disabled for matching
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = schema.$_terms.externals[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var method = _step5.value.method;
        state.mainstay.externals.push({
          method: method,
          path: state.path,
          label: Errors.label(schema._flags, state, prefs)
        });
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
          _iterator5["return"]();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }
  } // Result


  var result = {
    value: value,
    errors: errors.length ? errors : null
  };

  if (schema._flags.result) {
    result.value = schema._flags.result === 'strip' ? undefined :
    /* raw */
    helpers.original;
    state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
    state.shadow(value, schema._flags.result);
  } // Cache


  if (schema._cache && prefs.cache !== false && !schema._refs.length) {
    schema._cache.set(helpers.original, result);
  }

  return result;
};

internals.prefs = function (schema, prefs) {
  var isDefaultOptions = prefs === Common.defaults;

  if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
    return schema._preferences[Common.symbols.prefs];
  }

  prefs = Common.preferences(prefs, schema._preferences);

  if (isDefaultOptions) {
    schema._preferences[Common.symbols.prefs] = prefs;
  }

  return prefs;
};

internals["default"] = function (flag, value, errors, _ref) {
  var schema = _ref.schema,
      state = _ref.state,
      prefs = _ref.prefs;
  var source = schema._flags[flag];

  if (prefs.noDefaults || source === undefined) {
    return value;
  }

  state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');

  if (!source) {
    return source;
  }

  if (typeof source === 'function') {
    var args = source.length > 0 ? [Clone(state.ancestors[0]), prefs] : [];

    try {
      return source.apply(void 0, args);
    } catch (err) {
      errors.push(schema.$_createError("any.".concat(flag), null, {
        error: err
      }, state, prefs));
      return;
    }
  }

  if (_typeof(source) !== 'object') {
    return source;
  }

  if (source[Common.symbols.literal]) {
    return source.literal;
  }

  if (Common.isResolvable(source)) {
    return source.resolve(value, state, prefs);
  }

  return Clone(source);
};

internals.trim = function (value, schema) {
  if (typeof value !== 'string') {
    return value;
  }

  var trim = schema.$_getRule('trim');

  if (!trim || !trim.args.enabled) {
    return value;
  }

  return value.trim();
};

internals.ignore = {
  active: false,
  debug: Ignore,
  entry: Ignore,
  filter: Ignore,
  log: Ignore,
  resolve: Ignore,
  value: Ignore
};