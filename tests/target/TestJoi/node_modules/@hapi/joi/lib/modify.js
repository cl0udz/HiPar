'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Assert = require('@hapi/hoek/lib/assert');

var Common = require('./common');

var Ref = require('./ref');

var internals = {};

exports.Ids = internals.Ids =
/*#__PURE__*/
function () {
  function _class() {
    _classCallCheck(this, _class);

    this._byId = new Map();
    this._byKey = new Map();
    this._schemaChain = false;
  }

  _createClass(_class, [{
    key: "clone",
    value: function clone() {
      var clone = new internals.Ids();
      clone._byId = new Map(this._byId);
      clone._byKey = new Map(this._byKey);
      clone._schemaChain = this._schemaChain;
      return clone;
    }
  }, {
    key: "concat",
    value: function concat(source) {
      if (source._schemaChain) {
        this._schemaChain = true;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = source._byId.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              id = _step$value[0],
              value = _step$value[1];

          Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);

          this._byId.set(id, value);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = source._byKey.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              key = _step2$value[0],
              _value = _step2$value[1];

          Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);

          this._byKey.set(key, _value);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "fork",
    value: function fork(path, adjuster, root) {
      var chain = this._collect(path);

      chain.push({
        schema: root
      });
      var tail = chain.shift();
      var adjusted = {
        id: tail.id,
        schema: adjuster(tail.schema)
      };
      Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = chain[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var node = _step3.value;
          adjusted = {
            id: node.id,
            schema: internals.fork(node.schema, adjusted.id, adjusted.schema)
          };
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return adjusted.schema;
    }
  }, {
    key: "labels",
    value: function labels(path) {
      var behind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var current = path[0];

      var node = this._get(current);

      if (!node) {
        return [].concat(_toConsumableArray(behind), _toConsumableArray(path)).join('.');
      }

      var forward = path.slice(1);
      behind = [].concat(_toConsumableArray(behind), [node.schema._flags.label || current]);

      if (!forward.length) {
        return behind.join('.');
      }

      return node.schema._ids.labels(forward, behind);
    }
  }, {
    key: "reach",
    value: function reach(path) {
      var behind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var current = path[0];

      var node = this._get(current);

      Assert(node, 'Schema does not contain path', [].concat(_toConsumableArray(behind), _toConsumableArray(path)).join('.'));
      var forward = path.slice(1);

      if (!forward.length) {
        return node.schema;
      }

      return node.schema._ids.reach(forward, [].concat(_toConsumableArray(behind), [current]));
    }
  }, {
    key: "register",
    value: function register(schema) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          key = _ref.key;

      if (!schema || !Common.isSchema(schema)) {
        return;
      }

      if (schema.$_property('schemaChain') || schema._ids._schemaChain) {
        this._schemaChain = true;
      }

      var id = schema._flags.id;

      if (id) {
        var existing = this._byId.get(id);

        Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);
        Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);

        this._byId.set(id, {
          schema: schema,
          id: id
        });
      }

      if (key) {
        Assert(!this._byKey.has(key), 'Schema already contains key:', key);
        Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);

        this._byKey.set(key, {
          schema: schema,
          id: key
        });
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this._byId = new Map();
      this._byKey = new Map();
      this._schemaChain = false;
    }
  }, {
    key: "_collect",
    value: function _collect(path) {
      var behind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var nodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var current = path[0];

      var node = this._get(current);

      Assert(node, 'Schema does not contain path', [].concat(_toConsumableArray(behind), _toConsumableArray(path)).join('.'));
      nodes = [node].concat(_toConsumableArray(nodes));
      var forward = path.slice(1);

      if (!forward.length) {
        return nodes;
      }

      return node.schema._ids._collect(forward, [].concat(_toConsumableArray(behind), [current]), nodes);
    }
  }, {
    key: "_get",
    value: function _get(id) {
      return this._byId.get(id) || this._byKey.get(id);
    }
  }]);

  return _class;
}();

internals.fork = function (schema, id, replacement) {
  var each = function each(item, _ref2) {
    var key = _ref2.key;

    if (id === (item._flags.id || key)) {
      return replacement;
    }
  };

  var obj = exports.schema(schema, {
    each: each,
    ref: false
  });
  return obj.$_mutateRebuild();
};

exports.schema = function (schema, options) {
  var obj;

  for (var name in schema._flags) {
    if (name[0] === '_') {
      continue;
    }

    var result = internals.scan(schema._flags[name], {
      source: 'flags',
      name: name
    }, options);

    if (result !== undefined) {
      obj = obj || schema.clone();
      obj._flags[name] = result;
    }
  }

  for (var i = 0; i < schema._rules.length; ++i) {
    var rule = schema._rules[i];

    var _result = internals.scan(rule.args, {
      source: 'rules',
      name: rule.name
    }, options);

    if (_result !== undefined) {
      obj = obj || schema.clone();
      var clone = Object.assign({}, rule);
      clone.args = _result;
      obj._rules[i] = clone;

      var existingUnique = obj._singleRules.get(rule.name);

      if (existingUnique === rule) {
        obj._singleRules.set(rule.name, clone);
      }
    }
  }

  for (var _name in schema.$_terms) {
    if (_name[0] === '_') {
      continue;
    }

    var _result2 = internals.scan(schema.$_terms[_name], {
      source: 'terms',
      name: _name
    }, options);

    if (_result2 !== undefined) {
      obj = obj || schema.clone();
      obj.$_terms[_name] = _result2;
    }
  }

  return obj;
};

internals.scan = function (item, source, options, _path, _key) {
  var path = _path || [];

  if (item === null || _typeof(item) !== 'object') {
    return;
  }

  var clone;

  if (Array.isArray(item)) {
    for (var i = 0; i < item.length; ++i) {
      var key = source.source === 'terms' && source.name === 'keys' && item[i].key;
      var result = internals.scan(item[i], source, options, [i].concat(_toConsumableArray(path)), key);

      if (result !== undefined) {
        clone = clone || item.slice();
        clone[i] = result;
      }
    }

    return clone;
  }

  if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
    var _result3 = options.each(item, _objectSpread({}, source, {
      path: path,
      key: _key
    }));

    if (_result3 === item) {
      return;
    }

    return _result3;
  }

  for (var _key2 in item) {
    if (_key2[0] === '_') {
      continue;
    }

    var _result4 = internals.scan(item[_key2], source, options, [_key2].concat(_toConsumableArray(path)), _key);

    if (_result4 !== undefined) {
      clone = clone || Object.assign({}, item);
      clone[_key2] = _result4;
    }
  }

  return clone;
};