'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Assert = require('@hapi/hoek/lib/assert');

var Clone = require('@hapi/hoek/lib/clone');

var Cache = require('./cache');

var Common = require('./common');

var Compile = require('./compile');

var Errors = require('./errors');

var Extend = require('./extend');

var Manifest = require('./manifest');

var Ref = require('./ref');

var Template = require('./template');

var Trace = require('./trace');

var Schemas;
var internals = {
  types: {
    alternatives: require('./types/alternatives'),
    any: require('./types/any'),
    array: require('./types/array'),
    "boolean": require('./types/boolean'),
    date: require('./types/date'),
    "function": require('./types/function'),
    link: require('./types/link'),
    number: require('./types/number'),
    object: require('./types/object'),
    string: require('./types/string'),
    symbol: require('./types/symbol')
  }
};

if (Buffer) {
  // $lab:coverage:ignore$
  internals.types.binary = require('./types/binary');
}

internals.root = function () {
  var root = {
    _types: new Set(Object.keys(internals.types))
  }; // Types

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var type = _step.value;

      root[type] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');
        return internals.generate(this, internals.types[type], args);
      };
    };

    for (var _iterator = root._types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    } // Shortcuts

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _loop2 = function _loop2() {
    var method = _arr[_i];

    root[method] = function () {
      var _this$any;

      return (_this$any = this.any())[method].apply(_this$any, arguments);
    };
  };

  for (var _i = 0, _arr = ['allow', 'custom', 'disallow', 'equal', 'exist', 'forbidden', 'invalid', 'not', 'only', 'optional', 'options', 'prefs', 'preferences', 'required', 'strip', 'valid', 'when']; _i < _arr.length; _i++) {
    _loop2();
  } // Methods


  Object.assign(root, internals.methods); // Aliases

  root.alt = root.alternatives;
  root.bool = root["boolean"];
  root.func = root["function"];
  root.x = root.expression; // Trace

  if (Trace.setup) {
    // $lab:coverage:ignore$
    Trace.setup(root);
  }

  return root;
};

internals.methods = {
  ValidationError: Errors.ValidationError,
  version: Common.version,
  cache: Cache.provider,
  assert: function assert(value, schema)
  /* [message], [options] */
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }

    internals.assert(value, schema, true, args);
  },
  attempt: function attempt(value, schema)
  /* [message], [options] */
  {
    for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      args[_key3 - 2] = arguments[_key3];
    }

    return internals.assert(value, schema, false, args);
  },
  build: function build(desc) {
    Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');
    return Manifest.build(this, desc);
  },
  checkPreferences: function checkPreferences(prefs) {
    Common.checkPreferences(prefs);
  },
  compile: function compile(schema, options) {
    return Compile.compile(this, schema, options);
  },
  defaults: function defaults(modifier) {
    Assert(typeof modifier === 'function', 'modifier must be a function');
    var joi = Object.assign({}, this);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      var _loop3 = function _loop3() {
        var type = _step2.value;
        var schema = modifier(joi[type]());
        Assert(Common.isSchema(schema), 'modifier must return a valid schema object');

        joi[type] = function () {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          return internals.generate(this, schema, args);
        };
      };

      for (var _iterator2 = joi._types[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        _loop3();
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return joi;
  },
  expression: function expression() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return _construct(Template, args);
  },
  extend: function extend() {
    var _this = this;

    for (var _len6 = arguments.length, extensions = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      extensions[_key6] = arguments[_key6];
    }

    Common.verifyFlat(extensions, 'extend');
    Schemas = Schemas || require('./schemas');
    Assert(extensions.length, 'You need to provide at least one extension');
    this.assert(extensions, Schemas.extensions);
    var joi = Object.assign({}, this);
    joi._types = new Set(joi._types);

    var _loop4 = function _loop4() {
      var extension = _extensions[_i2];

      if (typeof extension === 'function') {
        extension = extension(joi);
      }

      _this.assert(extension, Schemas.extension);

      Assert(joi[extension.type] === undefined || joi._types.has(extension.type), 'Cannot override name', extension.type);

      var base = extension.base || _this.any();

      var schema = Extend.type(base, extension);

      joi._types.add(extension.type);

      joi[extension.type] = function () {
        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        return internals.generate(this, schema, args);
      };
    };

    for (var _i2 = 0, _extensions = extensions; _i2 < _extensions.length; _i2++) {
      _loop4();
    }

    return joi;
  },
  isExpression: Template.isTemplate,
  isRef: Ref.isRef,
  isSchema: Common.isSchema,
  "in": function _in() {
    return Ref["in"].apply(Ref, arguments);
  },
  override: Common.symbols.override,
  ref: function ref() {
    return Ref.create.apply(Ref, arguments);
  },
  types: function types() {
    var types = {};
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = this._types[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var type = _step3.value;
        types[type] = this[type]();
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return types;
  }
}; // Helpers

internals.assert = function (value, schema, annotate, args
/* [message], [options] */
) {
  var message = args[0] instanceof Error || typeof args[0] === 'string' ? args[0] : null;
  var options = message ? args[1] : args[0];
  var result = schema.validate(value, Common.preferences({
    errors: {
      stack: true
    }
  }, options || {}));
  var error = result.error;

  if (!error) {
    return result.value;
  }

  if (message instanceof Error) {
    throw message;
  }

  annotate = annotate && typeof error.annotate === 'function';
  var display = annotate ? error.annotate() : error.message;

  if (error instanceof Errors.ValidationError === false) {
    error = Clone(error);
  }

  error.message = message ? "".concat(message, " ").concat(display) : display;
  throw error;
};

internals.generate = function (root, schema, args) {
  var _schema$_definition;

  Assert(root, 'Must be invoked on a Joi instance.');
  schema.$_root = root;

  if (!schema._definition.args || !args.length) {
    return schema;
  }

  return (_schema$_definition = schema._definition).args.apply(_schema$_definition, [schema].concat(_toConsumableArray(args)));
};

module.exports = internals.root();