'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var MongooseError = require('../../error/index');

var SkipPopulateValue = require('./SkipPopulateValue');

var get = require('../get');

var getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');

var isPathExcluded = require('../projection/isPathExcluded');

var getSchemaTypes = require('./getSchemaTypes');

var getVirtual = require('./getVirtual');

var normalizeRefPath = require('./normalizeRefPath');

var util = require('util');

var utils = require('../../utils');

var modelSymbol = require('../symbols').modelSymbol;

var populateModelSymbol = require('../symbols').populateModelSymbol;

var schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;

module.exports = function getModelsMapForPopulate(model, docs, options) {
  var i;
  var doc;
  var len = docs.length;
  var available = {};
  var map = [];
  var modelNameFromQuery = options.model && options.model.modelName || options.model;
  var schema;
  var refPath;
  var Model;
  var currentOptions;
  var modelNames;
  var modelName;
  var modelForFindSchema;
  var originalModel = options.model;
  var isVirtual = false;
  var modelSchema = model.schema;

  var _loop = function _loop() {
    doc = docs[i];
    schema = getSchemaTypes(modelSchema, doc, options.path);
    var isUnderneathDocArray = schema && schema.$isUnderneathDocArray;

    if (isUnderneathDocArray && get(options, 'options.sort') != null) {
      return {
        v: new MongooseError('Cannot populate with `sort` on path ' + options.path + ' because it is a subproperty of a document array')
      };
    }

    modelNames = null;
    var isRefPath = false;
    var normalizedRefPath = null;

    if (Array.isArray(schema)) {
      for (var j = 0; j < schema.length; ++j) {
        var _modelNames = void 0;

        var res = void 0;

        try {
          res = _getModelNames(doc, schema[j]);
          _modelNames = res.modelNames;
          isRefPath = isRefPath || res.isRefPath;
          normalizedRefPath = normalizedRefPath || res.refPath;
        } catch (error) {
          return {
            v: error
          };
        }

        if (isRefPath && !res.isRefPath) {
          continue;
        }

        if (!_modelNames) {
          continue;
        }

        modelNames = modelNames || [];

        for (var x = 0; x < _modelNames.length; ++x) {
          if (modelNames.indexOf(_modelNames[x]) === -1) {
            modelNames.push(_modelNames[x]);
          }
        }
      }
    } else {
      try {
        var _res = _getModelNames(doc, schema);

        modelNames = _res.modelNames;
        isRefPath = _res.isRefPath;
        normalizedRefPath = _res.refPath;
      } catch (error) {
        return {
          v: error
        };
      }

      if (!modelNames) {
        return "continue";
      }
    }

    var _virtualRes = getVirtual(model.schema, options.path);

    var virtual = _virtualRes == null ? null : _virtualRes.virtual;
    var localField = void 0;
    var count = false;

    if (virtual && virtual.options) {
      var virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + '.' : '';

      if (typeof virtual.options.localField === 'function') {
        localField = virtualPrefix + virtual.options.localField.call(doc, doc);
      } else {
        localField = virtualPrefix + virtual.options.localField;
      }

      count = virtual.options.count;
    } else {
      localField = options.path;
    }

    var foreignField = virtual && virtual.options ? virtual.options.foreignField : '_id'; // `justOne = null` means we don't know from the schema whether the end
    // result should be an array or a single doc. This can result from
    // populating a POJO using `Model.populate()`

    var justOne = null;

    if ('justOne' in options && options.justOne !== void 0) {
      justOne = options.justOne;
    } else if (virtual && virtual.options && virtual.options.refPath) {
      var _normalizedRefPath = normalizeRefPath(virtual.options.refPath, doc, options.path);

      justOne = !!virtual.options.justOne;
      isVirtual = true;
      var refValue = utils.getValue(_normalizedRefPath, doc);
      modelNames = Array.isArray(refValue) ? refValue : [refValue];
    } else if (virtual && virtual.options && virtual.options.ref) {
      var normalizedRef;

      if (typeof virtual.options.ref === 'function') {
        normalizedRef = virtual.options.ref.call(doc, doc);
      } else {
        normalizedRef = virtual.options.ref;
      }

      justOne = !!virtual.options.justOne;
      isVirtual = true;

      if (!modelNames) {
        modelNames = [].concat(normalizedRef);
      }
    } else if (schema && !schema[schemaMixedSymbol]) {
      // Skip Mixed types because we explicitly don't do casting on those.
      justOne = !schema.$isMongooseArray;
    }

    if (!modelNames) {
      return "continue";
    }

    if (virtual && (!localField || !foreignField)) {
      return {
        v: new MongooseError('If you are populating a virtual, you must set the ' + 'localField and foreignField options')
      };
    }

    options.isVirtual = isVirtual;
    options.virtual = virtual;

    if (typeof localField === 'function') {
      localField = localField.call(doc, doc);
    }

    if (typeof foreignField === 'function') {
      foreignField = foreignField.call(doc);
    }

    var localFieldPathType = modelSchema._getPathType(localField);

    var localFieldPath = localFieldPathType === 'real' ? modelSchema.path(localField) : localFieldPathType.schema;
    var localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
    var ret = void 0;

    var _populateOptions = get(options, 'options', {});

    var getters = 'getters' in _populateOptions ? _populateOptions.getters : options.isVirtual && get(virtual, 'options.getters', false);

    if (localFieldGetters.length > 0 && getters) {
      var hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);
      var localFieldValue = utils.getValue(localField, doc);

      if (Array.isArray(localFieldValue)) {
        var localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);
        ret = localFieldValue.map(function (localFieldArrVal, localFieldArrIndex) {
          return localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]);
        });
      } else {
        ret = localFieldPath.applyGetters(localFieldValue, hydratedDoc);
      }
    } else {
      ret = convertTo_id(utils.getValue(localField, doc), schema);
    }

    var id = String(utils.getValue(foreignField, doc));
    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;
    var match = get(options, 'match', null) || get(currentOptions, 'match', null) || get(options, 'virtual.options.match', null) || get(options, 'virtual.options.options.match', null);
    var hasMatchFunction = typeof match === 'function';

    if (hasMatchFunction) {
      match = match.call(doc, doc);
    } // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear
    // out embedded discriminator docs that don't have a `refPath` on the
    // populated path.


    if (isRefPath && normalizedRefPath != null) {
      var pieces = normalizedRefPath.split('.');
      var cur = '';

      for (var _i = 0; _i < pieces.length; ++_i) {
        cur = cur + (cur.length === 0 ? '' : '.') + pieces[_i];
        var schematype = modelSchema.path(cur);

        if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length > 0) {
          var subdocs = utils.getValue(cur, doc);
          var remnant = options.path.substr(cur.length + 1);
          var discriminatorKey = schematype.caster.schema.options.discriminatorKey;
          modelNames = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = subdocs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var subdoc = _step.value;
              var discriminatorValue = utils.getValue(discriminatorKey, subdoc);
              var discriminatorSchema = schematype.caster.discriminators[discriminatorValue].schema;

              if (discriminatorSchema == null) {
                continue;
              }

              var _path = discriminatorSchema.path(remnant);

              if (_path == null || _path.options.refPath == null) {
                var _ret2 = function () {
                  var docValue = utils.getValue(localField.substr(cur.length + 1), subdoc);
                  ret = ret.map(function (v) {
                    return v === docValue ? SkipPopulateValue(v) : v;
                  });
                  return "continue";
                }();

                if (_ret2 === "continue") continue;
              }

              var _modelName = utils.getValue(pieces.slice(_i + 1).join('.'), subdoc);

              modelNames.push(_modelName);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }
    }

    var k = modelNames.length;

    while (k--) {
      modelName = modelNames[k];

      if (modelName == null) {
        continue;
      } // `PopulateOptions#connection`: if the model is passed as a string, the
      // connection matters because different connections have different models.


      var connection = options.connection != null ? options.connection : model.db;

      try {
        Model = originalModel && originalModel[modelSymbol] ? originalModel : modelName[modelSymbol] ? modelName : connection.model(modelName);
      } catch (error) {
        return {
          v: error
        };
      }

      var ids = ret;
      var flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];

      if (isRefPath && Array.isArray(ret) && flat.length === modelNames.length) {
        ids = flat.filter(function (val, i) {
          return modelNames[i] === modelName;
        });
      }

      if (!available[modelName]) {
        currentOptions = {
          model: Model
        };

        if (isVirtual && virtual.options && virtual.options.options) {
          currentOptions.options = utils.clone(virtual.options.options);
        }

        utils.merge(currentOptions, options); // Used internally for checking what model was used to populate this
        // path.

        options[populateModelSymbol] = Model;
        available[modelName] = _defineProperty({
          model: Model,
          options: currentOptions,
          match: hasMatchFunction ? [match] : match,
          docs: [doc],
          ids: [ids],
          allIds: [ret],
          localField: new Set([localField]),
          foreignField: new Set([foreignField]),
          justOne: justOne,
          isVirtual: isVirtual,
          virtual: virtual,
          count: count
        }, populateModelSymbol, Model);
        map.push(available[modelName]);
      } else {
        available[modelName].localField.add(localField);
        available[modelName].foreignField.add(foreignField);
        available[modelName].docs.push(doc);
        available[modelName].ids.push(ids);
        available[modelName].allIds.push(ret);

        if (hasMatchFunction) {
          available[modelName].match.push(match);
        }
      }
    }
  };

  for (i = 0; i < len; i++) {
    var _ret = _loop();

    switch (_ret) {
      case "continue":
        continue;

      default:
        if (_typeof(_ret) === "object") return _ret.v;
    }
  }

  function _getModelNames(doc, schema) {
    var modelNames;
    var discriminatorKey;
    var isRefPath = false;

    if (schema && schema.caster) {
      schema = schema.caster;
    }

    if (schema && schema.$isSchemaMap) {
      schema = schema.$__schemaType;
    }

    if (!schema && model.discriminators) {
      discriminatorKey = model.schema.discriminatorMapping.key;
    }

    refPath = schema && schema.options && schema.options.refPath;
    var normalizedRefPath = normalizeRefPath(refPath, doc, options.path);

    if (modelNameFromQuery) {
      modelNames = [modelNameFromQuery]; // query options
    } else if (normalizedRefPath) {
      if (options._queryProjection != null && isPathExcluded(options._queryProjection, normalizedRefPath)) {
        throw new MongooseError('refPath `' + normalizedRefPath + '` must not be excluded in projection, got ' + util.inspect(options._queryProjection));
      }

      if (modelSchema.virtuals.hasOwnProperty(normalizedRefPath) && doc.$__ == null) {
        modelNames = [modelSchema.virtuals[normalizedRefPath].applyGetters(void 0, doc)];
      } else {
        modelNames = utils.getValue(normalizedRefPath, doc);
      }

      if (Array.isArray(modelNames)) {
        modelNames = utils.array.flatten(modelNames);
      }

      isRefPath = true;
    } else {
      var modelForCurrentDoc = model;
      var schemaForCurrentDoc;

      if (!schema && discriminatorKey) {
        modelForFindSchema = utils.getValue(discriminatorKey, doc);

        if (modelForFindSchema) {
          // `modelForFindSchema` is the discriminator value, so we might need
          // find the discriminated model name
          var discriminatorModel = getDiscriminatorByValue(model, modelForFindSchema);

          if (discriminatorModel != null) {
            modelForCurrentDoc = discriminatorModel;
          } else {
            try {
              modelForCurrentDoc = model.db.model(modelForFindSchema);
            } catch (error) {
              return error;
            }
          }

          schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);

          if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
            schemaForCurrentDoc = schemaForCurrentDoc.caster;
          }
        }
      } else {
        schemaForCurrentDoc = schema;
      }

      var _virtualRes = getVirtual(modelForCurrentDoc.schema, options.path);

      var virtual = _virtualRes == null ? null : _virtualRes.virtual;
      var ref;

      var _refPath;

      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {
        ref = handleRefFunction(ref, doc);
        modelNames = [ref];
      } else if ((ref = get(virtual, 'options.ref')) != null) {
        ref = handleRefFunction(ref, doc); // When referencing nested arrays, the ref should be an Array
        // of modelNames.

        if (Array.isArray(ref)) {
          modelNames = ref;
        } else {
          modelNames = [ref];
        }

        isVirtual = true;
      } else if ((_refPath = get(schemaForCurrentDoc, 'options.refPath')) != null) {
        isRefPath = true;
        _refPath = normalizeRefPath(_refPath, doc, options.path);
        modelNames = utils.getValue(_refPath, doc);

        if (Array.isArray(modelNames)) {
          modelNames = utils.array.flatten(modelNames);
        }
      } else {
        // We may have a discriminator, in which case we don't want to
        // populate using the base model by default
        modelNames = discriminatorKey ? null : [model.modelName];
      }
    }

    if (!modelNames) {
      return {
        modelNames: modelNames,
        isRefPath: isRefPath,
        refPath: normalizedRefPath
      };
    }

    if (!Array.isArray(modelNames)) {
      modelNames = [modelNames];
    }

    return {
      modelNames: modelNames,
      isRefPath: isRefPath,
      refPath: normalizedRefPath
    };
  }

  return map;
};
/*!
 * ignore
 */


function handleRefFunction(ref, doc) {
  if (typeof ref === 'function' && !ref[modelSymbol]) {
    return ref.call(doc, doc);
  }

  return ref;
}
/*!
 * Retrieve the _id of `val` if a Document or Array of Documents.
 *
 * @param {Array|Document|Any} val
 * @return {Array|Document|Any}
 */


function convertTo_id(val, schema) {
  if (val != null && val.$__ != null) return val._id;

  if (Array.isArray(val)) {
    for (var i = 0; i < val.length; ++i) {
      if (val[i] != null && val[i].$__ != null) {
        val[i] = val[i]._id;
      }
    }

    if (val.isMongooseArray && val.$schema()) {
      return val.$schema().cast(val, val.$parent());
    }

    return [].concat(val);
  } // `populate('map')` may be an object if populating on a doc that hasn't
  // been hydrated yet


  if (val != null && val.constructor.name === 'Object' && ( // The intent here is we should only flatten the object if we expect
  // to get a Map in the end. Avoid doing this for mixed types.
  schema == null || schema[schemaMixedSymbol] == null)) {
    var ret = [];

    for (var _i2 = 0, _Object$keys = Object.keys(val); _i2 < _Object$keys.length; _i2++) {
      var key = _Object$keys[_i2];
      ret.push(val[key]);
    }

    return ret;
  } // If doc has already been hydrated, e.g. `doc.populate('map').execPopulate()`
  // then `val` will already be a map


  if (val instanceof Map) {
    return Array.from(val.values());
  }

  return val;
}