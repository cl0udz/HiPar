'use strict';

var symbols = require('../../schema/symbols');

var utils = require('../../utils');
/*!
 * ignore
 */


module.exports = applyHooks;
/*!
 * ignore
 */

applyHooks.middlewareFunctions = ['deleteOne', 'save', 'validate', 'remove', 'updateOne', 'init'];
/*!
 * Register hooks for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */

function applyHooks(model, schema, options) {
  options = options || {};
  var kareemOptions = {
    useErrorHandlers: true,
    numCallbackParams: 1,
    nullResultByDefault: true,
    contextParameter: true
  };
  var objToDecorate = options.decorateDoc ? model : model.prototype;
  model.$appliedHooks = true;

  for (var _i = 0, _Object$keys = Object.keys(schema.paths); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var type = schema.paths[key];
    var childModel = null;

    if (type.$isSingleNested) {
      childModel = type.caster;
    } else if (type.$isMongooseDocumentArray) {
      childModel = type.Constructor;
    } else {
      continue;
    }

    if (childModel.$appliedHooks) {
      continue;
    }

    applyHooks(childModel, type.schema, options);

    if (childModel.discriminators != null) {
      var keys = Object.keys(childModel.discriminators);

      for (var j = 0; j < keys.length; ++j) {
        applyHooks(childModel.discriminators[keys[j]], childModel.discriminators[keys[j]].schema, options);
      }
    }
  } // Built-in hooks rely on hooking internal functions in order to support
  // promises and make it so that `doc.save.toString()` provides meaningful
  // information.


  var middleware = schema.s.hooks.filter(function (hook) {
    if (hook.name === 'updateOne' || hook.name === 'deleteOne') {
      return !!hook['document'];
    }

    if (hook.name === 'remove') {
      return hook['document'] == null || !!hook['document'];
    }

    return true;
  }).filter(function (hook) {
    // If user has overwritten the method, don't apply built-in middleware
    if (schema.methods[hook.name]) {
      return !hook.fn[symbols.builtInMiddleware];
    }

    return true;
  });
  model._middleware = middleware;
  objToDecorate.$__save = middleware.createWrapper('save', objToDecorate.$__save, null, kareemOptions);
  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
  objToDecorate.$__validate = middleware.createWrapper('validate', objToDecorate.$__originalValidate, null, kareemOptions);
  objToDecorate.$__remove = middleware.createWrapper('remove', objToDecorate.$__remove, null, kareemOptions);
  objToDecorate.$__deleteOne = middleware.createWrapper('deleteOne', objToDecorate.$__deleteOne, null, kareemOptions);
  objToDecorate.$__init = middleware.createWrapperSync('init', objToDecorate.$__init, null, kareemOptions); // Support hooks for custom methods

  var customMethods = Object.keys(schema.methods);
  var customMethodOptions = Object.assign({}, kareemOptions, {
    // Only use `checkForPromise` for custom methods, because mongoose
    // query thunks are not as consistent as I would like about returning
    // a nullish value rather than the query. If a query thunk returns
    // a query, `checkForPromise` causes infinite recursion
    checkForPromise: true
  });

  var _loop = function _loop() {
    var method = _customMethods[_i2];

    if (!middleware.hasHooks(method)) {
      // Don't wrap if there are no hooks for the custom method to avoid
      // surprises. Also, `createWrapper()` enforces consistent async,
      // so wrapping a sync method would break it.
      return "continue";
    }

    var originalMethod = objToDecorate[method];

    objToDecorate[method] = function () {
      var _this = this;

      var args = Array.prototype.slice.call(arguments);
      var cb = utils.last(args);
      var argsWithoutCallback = typeof cb === 'function' ? args.slice(0, args.length - 1) : args;
      return utils.promiseOrCallback(cb, function (callback) {
        return _this["$__".concat(method)].apply(_this, argsWithoutCallback.concat([callback]));
      }, model.events);
    };

    objToDecorate["$__".concat(method)] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
  };

  for (var _i2 = 0, _customMethods = customMethods; _i2 < _customMethods.length; _i2++) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }
}