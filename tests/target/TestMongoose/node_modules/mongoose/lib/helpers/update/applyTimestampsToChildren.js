'use strict';

var cleanPositionalOperators = require('../schema/cleanPositionalOperators');

var handleTimestampOption = require('../schema/handleTimestampOption');

module.exports = applyTimestampsToChildren;
/*!
 * ignore
 */

function applyTimestampsToChildren(now, update, schema) {
  if (update == null) {
    return;
  }

  var keys = Object.keys(update);
  var key;
  var createdAt;
  var updatedAt;
  var timestamps;
  var path;
  var hasDollarKey = keys.length && keys[0].startsWith('$');

  if (hasDollarKey) {
    if (update.$push) {
      for (key in update.$push) {
        var $path = schema.path(key);

        if (update.$push[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
          timestamps = $path.schema.options.timestamps;
          createdAt = handleTimestampOption(timestamps, 'createdAt');
          updatedAt = handleTimestampOption(timestamps, 'updatedAt');

          if (update.$push[key].$each) {
            update.$push[key].$each.forEach(function (subdoc) {
              if (updatedAt != null) {
                subdoc[updatedAt] = now;
              }

              if (createdAt != null) {
                subdoc[createdAt] = now;
              }
            });
          } else {
            if (updatedAt != null) {
              update.$push[key][updatedAt] = now;
            }

            if (createdAt != null) {
              update.$push[key][createdAt] = now;
            }
          }
        }
      }
    }

    if (update.$set != null) {
      var _keys = Object.keys(update.$set);

      for (var _i = 0, _keys2 = _keys; _i < _keys2.length; _i++) {
        key = _keys2[_i];
        // Replace positional operator `$` and array filters `$[]` and `$[.*]`
        var keyToSearch = cleanPositionalOperators(key);
        path = schema.path(keyToSearch);

        if (!path) {
          continue;
        }

        var parentSchemaType = null;
        var pieces = keyToSearch.split('.');

        for (var i = pieces.length - 1; i > 0; --i) {
          var s = schema.path(pieces.slice(0, i).join('.'));

          if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
            parentSchemaType = s;
            break;
          }
        }

        if (Array.isArray(update.$set[key]) && path.$isMongooseDocumentArray) {
          applyTimestampsToDocumentArray(update.$set[key], path, now);
        } else if (update.$set[key] && path.$isSingleNested) {
          applyTimestampsToSingleNested(update.$set[key], path, now);
        } else if (parentSchemaType != null) {
          timestamps = parentSchemaType.schema.options.timestamps;
          createdAt = handleTimestampOption(timestamps, 'createdAt');
          updatedAt = handleTimestampOption(timestamps, 'updatedAt');

          if (!timestamps || updatedAt == null) {
            continue;
          }

          if (parentSchemaType.$isSingleNested) {
            // Single nested is easy
            update.$set[parentSchemaType.path + '.' + updatedAt] = now;
            continue;
          }

          var childPath = key.substr(parentSchemaType.path.length + 1);

          if (/^\d+$/.test(childPath)) {
            update.$set[parentSchemaType.path + '.' + childPath][updatedAt] = now;
            continue;
          }

          var firstDot = childPath.indexOf('.');
          childPath = firstDot !== -1 ? childPath.substr(0, firstDot) : childPath;
          update.$set[parentSchemaType.path + '.' + childPath + '.' + updatedAt] = now;
        } else if (path.schema != null && path.schema != schema && update.$set[key]) {
          timestamps = path.schema.options.timestamps;
          createdAt = handleTimestampOption(timestamps, 'createdAt');
          updatedAt = handleTimestampOption(timestamps, 'updatedAt');

          if (!timestamps) {
            continue;
          }

          if (updatedAt != null) {
            update.$set[key][updatedAt] = now;
          }

          if (createdAt != null) {
            update.$set[key][createdAt] = now;
          }
        }
      }
    }
  } else {
    var _keys3 = Object.keys(update).filter(function (key) {
      return !key.startsWith('$');
    });

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _keys3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        key = _step.value;

        // Replace positional operator `$` and array filters `$[]` and `$[.*]`
        var _keyToSearch = cleanPositionalOperators(key);

        path = schema.path(_keyToSearch);

        if (!path) {
          continue;
        }

        if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
          applyTimestampsToDocumentArray(update[key], path, now);
        } else if (update[key] != null && path.$isSingleNested) {
          applyTimestampsToSingleNested(update[key], path, now);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
}

function applyTimestampsToDocumentArray(arr, schematype, now) {
  var timestamps = schematype.schema.options.timestamps;

  if (!timestamps) {
    return;
  }

  var len = arr.length;
  var createdAt = handleTimestampOption(timestamps, 'createdAt');
  var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

  for (var i = 0; i < len; ++i) {
    if (updatedAt != null) {
      arr[i][updatedAt] = now;
    }

    if (createdAt != null) {
      arr[i][createdAt] = now;
    }
  }
}

function applyTimestampsToSingleNested(subdoc, schematype, now) {
  var timestamps = schematype.schema.options.timestamps;

  if (!timestamps) {
    return;
  }

  var createdAt = handleTimestampOption(timestamps, 'createdAt');
  var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

  if (updatedAt != null) {
    subdoc[updatedAt] = now;
  }

  if (createdAt != null) {
    subdoc[createdAt] = now;
  }
}