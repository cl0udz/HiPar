"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.date.to-string.js");

require("core-js/modules/es.function.bind.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.parse-int.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/es.string.split.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/web.timers.js");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Module dependencies.
 */
var FTP = require('ftp');

var path = require('path');

var NotFoundError = require('./notfound');

var NotModifiedError = require('./notmodified');

var debug = require('debug')('get-uri:ftp');
/**
 * Module exports.
 */


module.exports = get;
/**
 * Returns a Readable stream from an "ftp:" URI.
 *
 * @api protected
 */

function get(parsed, opts, fn) {
  var cache = opts.cache;
  var client = new FTP();
  var filepath = parsed.pathname;
  var lastModified;
  client.once('error', onerror);
  client.once('ready', onready);
  client.once('greeting', ongreeting);

  function onready() {
    // first we have to figure out the Last Modified date.
    // try the MDTM command first, which is an optional extension command.
    client.lastMod(filepath, onlastmod);
  }

  function ongreeting(greeting) {
    debug('FTP greeting: %o', greeting);
  }

  function onerror(err) {
    client.end();
    fn(err);
  }

  function onfile(err, stream) {
    if (err) return onerror(err);
    stream.once('end', onend);
    stream.lastModified = lastModified;
    fn(null, stream);
  }

  function onend() {
    // close the FTP client socket connection
    client.end();
  }

  function getFile() {
    client.get(filepath, onfile);
  }

  function onlastmod(err, lastmod) {
    // handle the "file not found" error code
    if (err) {
      if (550 == err.code) {
        onerror(new NotFoundError());
      } // any other error then we'll try the LIST command instead

    }

    if (lastmod) {
      setLastMod(lastmod);
    } else {
      // try to get the last modified date via the LIST command (uses
      // more bandwidth, but is more compatible with older FTP servers
      var dir = path.dirname(filepath);
      client.list(dir, onlist);
    }
  }

  function setLastMod(lastmod) {
    lastModified = lastmod;

    if (cache && isNotModified()) {
      // file is the same as in the "cache", return a not modified error
      onerror(new NotModifiedError());
    } else {
      // XXX: a small timeout seemed necessary otherwise FTP servers
      // were returning empty sockets for the file occasionally
      setTimeout(client.get.bind(client, filepath, onfile), 10);
    }
  }

  function onlist(err, list) {
    if (err) return onerror(err);
    var name = path.basename(filepath); // attempt to find the "entry" with a matching "name"

    var entry;

    for (var i = 0; i < list.length; i++) {
      entry = list[i];
      debug('file %o: %o', i, entry.name);

      if (entry.name == name) {
        break;
      }

      entry = null;
    }

    if (entry) {
      setLastMod(entry.date);
    } else {
      onerror(new NotFoundError());
    }
  } // called when `lastModified` is set, and a "cache" stream was provided


  function isNotModified() {
    return +cache.lastModified == +lastModified;
  }

  opts.host = parsed.hostname || parsed.host || 'localhost';
  opts.port = parseInt(parsed.port, 10) || 21;
  if (debug.enabled) opts.debug = debug;

  if (parsed.auth) {
    var _parsed$auth$split = parsed.auth.split(":"),
        _parsed$auth$split2 = _slicedToArray(_parsed$auth$split, 2),
        user = _parsed$auth$split2[0],
        password = _parsed$auth$split2[1];

    opts.user = user;
    opts.password = password;
  }

  client.connect(opts);
}