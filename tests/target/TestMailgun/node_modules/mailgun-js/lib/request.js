"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/es.array.index-of.js");

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.date.to-string.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/es.string.match.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/web.dom-collections.iterator.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var https = require('https');

var http = require('http');

var ProxyAgent = require('proxy-agent');

var qs = require('querystring');

var fs = require('fs');

var Readable = require('stream').Readable;

var FormData = require('form-data');

var Attachment = require('./attachment');

var retry = require('async').retry;

var promisifyCall = require('promisify-call');

var debug = require('debug')('mailgun-js');

function isOk(i) {
  return typeof i !== 'undefined' && i !== null;
}

function getDataValue(key, input) {
  if (isSpecialParam(key) && _typeof(input) === 'object') {
    return JSON.stringify(input);
  } else if (typeof input === 'number' || typeof input === 'boolean') {
    return input.toString();
  }

  return input;
}

function isSpecialParam(paramKey) {
  var key = paramKey.toLowerCase();
  return key === 'vars' || key === 'members' || key === 'recipient-variables' || key.indexOf('v:') === 0;
}

function isMultiUnsubsribe(path, data) {
  return path.indexOf('/unsubscribes') && data && Array.isArray(data);
}

function prepareData(data) {
  var params = {};

  for (var key in data) {
    if (key !== 'attachment' && key !== 'inline' && isOk(data[key])) {
      var value = getDataValue(key, data[key]);

      if (isOk(value)) {
        params[key] = value;
      }
    } else {
      params[key] = data[key];
    }
  }

  return params;
}

var Request =
/*#__PURE__*/
function () {
  function Request(options) {
    _classCallCheck(this, Request);

    this.host = options.host;
    this.protocol = options.protocol;
    this.port = options.port;
    this.endpoint = options.endpoint;
    this.auth = options.auth;
    this.proxy = options.proxy;
    this.timeout = options.timeout;
    this.retry = options.retry || 1;
    this.testMode = options.testMode;
    this.testModeLogger = typeof options.testModeLogger === 'function' ? options.testModeLogger : this.defaultTestModeLogger;
  }

  _createClass(Request, [{
    key: "_request",
    value: function _request(method, resource, data, fn) {
      var _this = this;

      var path = ''.concat(this.endpoint, resource);
      var params = prepareData(data);
      this.payload = '';
      var isMIME = path.indexOf('/messages.mime') >= 0;
      this.headers = {};

      if (method === 'GET' || method === 'DELETE') {
        this.payload = qs.stringify(params);
        if (this.payload) path = path.concat('?', this.payload);
      } else {
        if (isMIME) {
          this.headers['Content-Type'] = 'multipart/form-data';
        } else if (method === 'POST' && isMultiUnsubsribe(path, data)) {
          this.headers['Content-Type'] = 'application/json';
        } else {
          this.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }

        if (params && (params.attachment || params.inline || isMIME && params.message)) {
          this.prepareFormData(params);
        } else {
          if (method === 'POST' && isMultiUnsubsribe(path, data)) {
            this.payload = JSON.stringify(data);
          } else {
            this.payload = qs.stringify(params);
          }

          if (this.payload) {
            this.headers['Content-Length'] = Buffer.byteLength(this.payload);
          } else {
            this.headers['Content-Length'] = 0;
          }
        }
      } // check for MIME is true in case of messages GET


      if (method === 'GET' && path.indexOf('/messages') >= 0 && params && params.MIME === true) {
        this.headers.Accept = 'message/rfc2822';
      }

      debug('%s %s', method, path);
      var opts = {
        'hostname': this.host,
        'port': this.port,
        'protocol': this.protocol,
        path: path,
        method: method,
        'headers': this.headers,
        'auth': this.auth,
        'agent': false,
        'timeout': this.timeout
      };

      if (this.proxy) {
        opts.agent = new ProxyAgent(this.proxy);
      }

      if (this.testMode) {
        this.testModeLogger(opts, this.payload, this.form);
        return fn();
      }

      if (_typeof(this.retry) === 'object' || this.retry > 1) {
        retry(this.retry, function (retryCb) {
          _this.callback = retryCb;

          _this.performRequest(opts);
        }, fn);
      } else {
        this.callback = fn;
        this.performRequest(opts);
      }
    }
  }, {
    key: "request",
    value: function request(method, resource, data, fn) {
      if (typeof data === 'function' && !fn) {
        fn = data;
        data = {};
      }

      if (!data) {
        data = {};
      }

      return promisifyCall(this, this._request, method, resource, data, fn);
    }
  }, {
    key: "prepareFormData",
    value: function prepareFormData(data) {
      var _this2 = this;

      this.form = new FormData();

      var _loop = function _loop(key) {
        if ({}.hasOwnProperty.call(data, key)) {
          var obj = data[key];

          if (isOk(obj)) {
            if (key === 'attachment' || key === 'inline') {
              if (Array.isArray(obj)) {
                for (var i = 0; i < obj.length; i++) {
                  _this2.handleAttachmentObject(key, obj[i]);
                }
              } else {
                _this2.handleAttachmentObject(key, obj);
              }
            } else if (key === 'message') {
              _this2.handleMimeObject(key, obj);
            } else if (Array.isArray(obj)) {
              obj.forEach(function (element) {
                if (isOk(element)) {
                  var value = getDataValue(key, element);

                  if (isOk(value)) {
                    _this2.form.append(key, value);
                  }
                }
              });
            } else {
              var value = getDataValue(key, obj);

              if (isOk(value)) {
                _this2.form.append(key, value);
              }
            }
          }
        }
      };

      for (var key in data) {
        _loop(key);
      }

      this.headers = this.form.getHeaders();
    }
  }, {
    key: "handleMimeObject",
    value: function handleMimeObject(key, obj) {
      if (typeof obj === 'string') {
        if (fs.existsSync(obj) && fs.statSync(obj).isFile()) {
          this.form.append('message', fs.createReadStream(obj));
        } else {
          this.form.append('message', Buffer.from(obj), {
            'filename': 'message.mime',
            'contentType': 'message/rfc822',
            'knownLength': obj.length
          });
        }
      } else if (obj instanceof Readable) {
        this.form.append('message', obj);
      }
    }
  }, {
    key: "handleAttachmentObject",
    value: function handleAttachmentObject(key, obj) {
      if (!this.form) this.form = new FormData();

      if (Buffer.isBuffer(obj)) {
        debug('appending buffer to form data. key: %s', key);
        this.form.append(key, obj, {
          'filename': 'file'
        });
      } else if (typeof obj === 'string') {
        debug('appending stream to form data. key: %s obj: %s', key, obj);
        this.form.append(key, fs.createReadStream(obj));
      } else if (_typeof(obj) === 'object' && obj.readable === true) {
        debug('appending readable stream to form data. key: %s obj: %s', key, obj);
        this.form.append(key, obj);
      } else if (_typeof(obj) === 'object' && obj instanceof Attachment) {
        var attachmentType = obj.getType();

        if (attachmentType === 'path') {
          debug('appending attachment stream to form data. key: %s data: %s filename: %s', key, obj.data, obj.filename);
          this.form.append(key, fs.createReadStream(obj.data), {
            'filename': obj.filename || 'attached file'
          });
        } else if (attachmentType === 'buffer') {
          debug('appending attachment buffer to form data. key: %s filename: %s', key, obj.filename);
          var formOpts = {
            'filename': obj.filename || 'attached file'
          };

          if (obj.contentType) {
            formOpts.contentType = obj.contentType;
          }

          if (obj.knownLength) {
            formOpts.knownLength = obj.knownLength;
          }

          this.form.append(key, obj.data, formOpts);
        } else if (attachmentType === 'stream') {
          if (obj.knownLength && !obj.contentType || !obj.knownLength && obj.contentType) {
            debug('missing content type or length for attachment stream. key: %s', key);
          } else {
            debug('appending attachment stream to form data. key: %s', key); // add all known options

            var _formOpts = {};

            if (obj.filename) {
              _formOpts.filename = obj.filename;
            }

            if (obj.contentType) {
              _formOpts.contentType = obj.contentType;
            }

            if (obj.knownLength) {
              _formOpts.knownLength = obj.knownLength;
            }

            this.form.append(key, obj.data, _formOpts);
          }
        }
      } else {
        debug('unknown attachment type. key: %s', key);
      }
    }
  }, {
    key: "handleResponse",
    value: function handleResponse(res) {
      var _this3 = this;

      var chunks = '';
      var error;
      res.on('data', function (chunk) {
        chunks += chunk;
      });
      res.on('error', function (err) {
        error = err;
      });
      res.on('end', function () {
        var body;
        debug('response status code: %s content type: %s error: %s', res.statusCode, res.headers['content-type'], error); // FIXME: An ugly hack to overcome invalid response type in mailgun api (see http://bit.ly/1eF30fU).
        // We skip content-type validation for 'campaings' endpoint assuming it is JSON.

        var skipContentTypeCheck = res.req && res.req.path && res.req.path.match(/\/campaigns/);
        var isJSON = res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') >= 0;

        if (chunks && !error && (skipContentTypeCheck || isJSON)) {
          try {
            body = JSON.parse(chunks);
          } catch (e) {
            error = e;
          }
        }

        if (process.env.DEBUG_MAILGUN_FORCE_RETRY) {
          error = new Error('Force retry error');
          delete process.env.DEBUG_MAILGUN_FORCE_RETRY;
        }

        if (!error && res.statusCode !== 200) {
          var msg = body || chunks || res.statusMessage;

          if (body) {
            msg = body.message || body.response;
          }

          error = new Error(msg);
          error.statusCode = res.statusCode;
        }

        return _this3.callback(error, body);
      });
    }
  }, {
    key: "performRequest",
    value: function performRequest(options) {
      var _this4 = this;

      var method = options.method;

      if (this.form && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
        var alreadyHandled = false;
        this.form.submit(options, function (err, res) {
          if (alreadyHandled) {
            return;
          }

          alreadyHandled = true;

          if (err) {
            return _this4.callback(err);
          }

          return _this4.handleResponse(res);
        });
      } else {
        var req;

        if (options.protocol === 'http:') {
          req = http.request(options, function (res) {
            return _this4.handleResponse(res);
          });
        } else {
          req = https.request(options, function (res) {
            return _this4.handleResponse(res);
          });
        }

        if (options.timeout) {
          req.setTimeout(options.timeout, function () {
            // timeout occurs
            req.abort();
          });
        }

        req.on('error', function (e) {
          return _this4.callback(e);
        });

        if (this.payload && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
          req.write(this.payload);
        }

        req.end();
      }
    }
  }, {
    key: "defaultTestModeLogger",
    value: function defaultTestModeLogger(httpOptions, payload, formData) {
      var testlog = debug.enabled ? debug : console.log;
      testlog('options: %o', httpOptions);
      testlog('payload: %o', payload);
      testlog('form: %o', formData);
    }
  }]);

  return Request;
}();

module.exports = Request;