"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.index-of.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.join.js");

require("core-js/modules/es.date.now.js");

require("core-js/modules/es.date.to-string.js");

require("core-js/modules/es.object.assign.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.parse-int.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/web.timers.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var tsscmp = require('tsscmp');

var crypto = require('crypto');

var Attachment = require('./attachment');

var Request = require('./request');

var builder = require('./build');

var resources = require('./schema').definitions;

var mailgunExpirey = 15 * 60 * 1000;
var mailgunHashType = 'sha256';
var mailgunSignatureEncoding = 'hex';

var Mailgun =
/*#__PURE__*/
function () {
  function Mailgun(options) {
    _classCallCheck(this, Mailgun);

    if (!options.apiKey) {
      throw new Error('apiKey value must be defined!');
    }

    this.username = 'api';
    this.apiKey = options.apiKey;
    this.publicApiKey = options.publicApiKey;
    this.domain = options.domain;
    this.auth = [this.username, this.apiKey].join(':');
    this.mute = options.mute || false;
    this.timeout = options.timeout;
    this.host = options.host || 'api.mailgun.net';
    this.endpoint = options.endpoint || '/v3';
    this.protocol = options.protocol || 'https:';
    this.port = options.port || 443;
    this.retry = options.retry || 1;
    this.testMode = options.testMode;
    this.testModeLogger = options.testModeLogger;

    if (options.proxy) {
      this.proxy = options.proxy;
    }

    this.options = {
      host: this.host,
      endpoint: this.endpoint,
      protocol: this.protocol,
      port: this.port,
      auth: this.auth,
      proxy: this.proxy,
      timeout: this.timeout,
      retry: this.retry,
      testMode: this.testMode,
      testModeLogger: this.testModeLogger
    };
    this.mailgunTokens = {};
  }

  _createClass(Mailgun, [{
    key: "getDomain",
    value: function getDomain(method, resource) {
      var d = this.domain; // filter out API calls that do not require a domain specified

      if (resource.indexOf('/routes') >= 0 || resource.indexOf('/lists') >= 0 || resource.indexOf('/address') >= 0 || resource.indexOf('/domains') >= 0) {
        d = '';
      } else if (resource.indexOf('/messages') >= 0 && (method === 'GET' || method === 'DELETE')) {
        d = "domains/".concat(this.domain);
      }

      return d;
    }
  }, {
    key: "getRequestOptions",
    value: function getRequestOptions(resource) {
      var o = this.options; // use public API key if we have it for the routes that require it

      if ((resource.indexOf('/address/validate') >= 0 || resource.indexOf('/address/parse') >= 0) && this.publicApiKey) {
        var copy = Object.assign({}, this.options);
        copy.auth = [this.username, this.publicApiKey].join(':');
        o = copy;
      }

      return o;
    }
  }, {
    key: "request",
    value: function request(method, resource, data, fn) {
      var fullpath = resource;
      var domain = this.getDomain(method, resource);

      if (domain) {
        fullpath = '/'.concat(domain, resource);
      }

      var req = new Request(this.options);
      return req.request(method, fullpath, data, fn);
    }
  }, {
    key: "post",
    value: function post(path, data, fn) {
      var req = new Request(this.options);
      return req.request('POST', path, data, fn);
    }
  }, {
    key: "get",
    value: function get(path, data, fn) {
      var req = new Request(this.options);
      return req.request('GET', path, data, fn);
    }
  }, {
    key: "delete",
    value: function _delete(path, data, fn) {
      var req = new Request(this.options);
      return req.request('DELETE', path, data, fn);
    }
  }, {
    key: "put",
    value: function put(path, data, fn) {
      var req = new Request(this.options);
      return req.request('PUT', path, data, fn);
    }
  }, {
    key: "validateWebhook",
    value: function validateWebhook(timestamp, token, signature) {
      var _this = this;

      var adjustedTimestamp = parseInt(timestamp, 10) * 1000;
      var fresh = Math.abs(Date.now() - adjustedTimestamp) < mailgunExpirey;

      if (!fresh) {
        if (!this.mute) {
          console.error('[mailgun] Stale Timestamp: this may be an attack');
          console.error('[mailgun] However, this is most likely your fault\n');
          console.error('[mailgun] run `ntpdate ntp.ubuntu.com` and check your system clock\n');
          console.error("[mailgun] System Time: ".concat(new Date().toString()));
          console.error("[mailgun] Mailgun Time: ".concat(new Date(adjustedTimestamp).toString()), timestamp);
          console.error("[mailgun] Delta: ".concat(Date.now() - adjustedTimestamp));
        }

        return false;
      }

      if (this.mailgunTokens[token]) {
        if (!this.mute) {
          console.error('[mailgun] Replay Attack');
        }

        return false;
      }

      this.mailgunTokens[token] = true;
      var tokenTimeout = setTimeout(function () {
        delete _this.mailgunTokens[token];
      }, mailgunExpirey + 5 * 1000);
      tokenTimeout.unref();
      return tsscmp(signature, crypto.createHmac(mailgunHashType, this.apiKey).update(Buffer.from(timestamp + token, 'utf-8')).digest(mailgunSignatureEncoding));
    }
  }, {
    key: "validate",
    value: function validate(address, isPrivate, opts, fn) {
      if (typeof opts === 'function') {
        fn = opts;
        opts = {};
      }

      if (_typeof(isPrivate) === 'object') {
        opts = isPrivate;
        isPrivate = false;
      }

      if (typeof isPrivate === 'function') {
        fn = isPrivate;
        isPrivate = false;
        opts = {};
      }

      var resource = '/address/validate';

      if (isPrivate) {
        resource = '/address/private/validate';
      }

      var options = this.getRequestOptions(resource);
      var req = new Request(options);
      var data = Object.assign({}, {
        address: address
      }, opts);
      return req.request('GET', resource, data, fn);
    }
  }, {
    key: "parse",
    value: function parse(addresses, isPrivate, opts, fn) {
      if (typeof opts === 'function') {
        fn = opts;
        opts = {};
      }

      if (_typeof(isPrivate) === 'object') {
        opts = isPrivate;
        isPrivate = false;
      }

      if (typeof isPrivate === 'function') {
        fn = isPrivate;
        isPrivate = false;
        opts = {};
      }

      var resource = '/address/parse';

      if (isPrivate) {
        resource = '/address/private/parse';
      }

      var options = this.getRequestOptions(resource);
      var req = new Request(options);
      var data = Object.assign({}, {
        addresses: addresses
      }, opts);
      return req.request('GET', resource, data, fn);
    }
  }]);

  return Mailgun;
}();

builder.build(Mailgun, resources);
Mailgun.prototype.Attachment = Attachment;
Mailgun.prototype.Mailgun = Mailgun;

function create(options) {
  return new Mailgun(options);
}

module.exports = create;