"use strict";
/**
 * json-strictify
 *
 * @version 6.3.0
 * @author Raphael Pigulla <pigulla@four66.com>
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const util = tslib_1.__importStar(require("util"));
const CircularReferenceError_1 = tslib_1.__importDefault(require("./CircularReferenceError"));
const InvalidValueError_1 = tslib_1.__importDefault(require("./InvalidValueError"));
;
/**
 * Normalizes a user-specified replacer function.
 *
 * In short, JSON.stringify's "replacer" parameter can either be a function or an array containing the names of the
 * properties to be included. This method normalizes the latter case to the former so we can always treat the
 * "replacer" option as a function internally.
 *
 * For more information about the replacer function take a look at the documentation on
 * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter).
 */
function normalize_replacer(replacer) {
    if (typeof replacer === 'function') {
        return replacer;
    }
    if (Array.isArray(replacer)) {
        return function (key, value) {
            return (key !== '' && replacer.indexOf(key) === -1) ? undefined : value;
        };
    }
    // We can't easily normalize an "empty replacer" with the identity function because we later need to distinguish
    // between a "real" undefined (which is illegal) and an undefined returned by the replacer (which means "drop
    // that value").
    return null;
}
class JSONstrictify {
    constructor(replacer) {
        this.replacer = replacer;
    }
    /**
     * The drop-in replacement function for JSON.stringify.
     *
     * @throws {InvalidValueError}
     * @throws {CircularReferenceError}
     */
    static validate(value, replacer) {
        const normalized_replacer = normalize_replacer(replacer);
        const instance = new JSONstrictify(normalized_replacer);
        const initialData = normalized_replacer ? normalized_replacer.call(value, '', value) : value;
        instance.check(initialData, [], new Set());
    }
    /**
     * Recursively check if the given object can be serialized to JSON safely.
     *
     * @throws {InvalidValueError}
     * @throws {CircularReferenceError}
     */
    check_object(object, references, ancestors) {
        let actual;
        this.assert_no_cycle(object, references, ancestors);
        if (typeof object.toJSON === 'function') {
            actual = object.toJSON();
            return this.check(actual, references, ancestors);
        }
        for (const key in object) {
            actual = this.replacer ? this.replacer.call(object, key, object[key]) : object[key];
            if (!this.replacer || actual !== undefined) {
                this.check(actual, references.concat(key), ancestors.add(object));
            }
        }
    }
    /**
     * Recursively check if the given array can be serialized to JSON safely.
     *
     * @throws {InvalidValueError}
     * @throws {CircularReferenceError}
     */
    check_array(array, references, ancestors) {
        this.assert_no_cycle(array, references, ancestors);
        for (let i = 0; i < array.length; ++i) {
            const actual = this.replacer ? this.replacer.call(array, String(i), array[i]) : array[i];
            this.check(actual, references.concat(String(i)), ancestors.add(array));
        }
    }
    /**
     * Check if the given value is of a known, non-serializable type and provide a more specific, helpful error message.
     *
     * @throws {InvalidValueError}
     */
    check_common_types(value, references) {
        if (util.types.isNativeError(value)) {
            throw new InvalidValueError_1.default('An error object is not JSON-serializable', value, references);
        }
        else if (util.types.isRegExp(value)) {
            throw new InvalidValueError_1.default('A RegExp is not JSON-serializable', value, references);
        }
        else if (value === undefined) {
            throw new InvalidValueError_1.default('undefined is not JSON-serializable', value, references);
        }
        else if (typeof value === 'symbol') {
            throw new InvalidValueError_1.default('A symbol is not JSON-serializable', value, references);
        }
        else if (typeof value === 'function') {
            throw new InvalidValueError_1.default('A function is not JSON-serializable', value, references);
        }
        else if (typeof value === 'bigint') {
            throw new InvalidValueError_1.default('A BigInt is not JSON-serializable', value, references);
        }
        else if (typeof value === 'number' && !isFinite(value)) {
            // The value's string representation itself will actually be descriptive ("Infinity", "-Infinity" or "NaN").
            throw new InvalidValueError_1.default(`${value} is not JSON-serializable`, value, references);
        }
    }
    /**
     * Recursively check if the given value can be serialized to JSON safely.
     *
     * @throws {InvalidValueError}
     * @throws {CircularReferenceError}
     */
    check(value, references, ancestors) {
        // Check for the most common non-serializable types.
        this.check_common_types(value, references);
        // Primitive types are always okay (we've already checked for non-finite numbers).
        if (value === null || typeof value === 'string' || typeof value === 'boolean' || typeof value === 'number') {
            return;
        }
        if (Array.isArray(value)) {
            // If an array, check its elements.
            return this.check_array(value, references, ancestors);
        }
        /* istanbul ignore else */
        if (typeof value === 'object') {
            // If an object, check its properties (we've already checked for null).
            return this.check_object(value, references, ancestors);
        }
        // This case will not occur in a regular Node.js or browser environment, but could happen if you run your
        // script in an engine like Rhino or Nashorn and try to serialize a host object.
        /* istanbul ignore next */
        throw new InvalidValueError_1.default('Invalid type', value, references);
    }
    /**
     * Check if the passed value is a circular reference, i.e. whether it is one of its own ancestors.
     *
     * @throws {CircularReferenceError}
     */
    assert_no_cycle(value, references, ancestors) {
        if (ancestors.has(value)) {
            throw new CircularReferenceError_1.default(references);
        }
    }
}
;
const native_impl = {
    [Symbol.toStringTag]: 'JSON',
    parse: JSON.parse,
    stringify: JSON.stringify,
    enabled(enabled = true) {
        /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
        return enabled ? strict_impl : native_impl;
    }
};
const strict_impl = {
    [Symbol.toStringTag]: 'JSON',
    parse: JSON.parse,
    stringify(value, replacer, space) {
        JSONstrictify.validate(value, replacer);
        // Overloading in TypeScript seems to be a bit wonky...
        return typeof replacer === 'function'
            ? JSON.stringify(value, replacer, space)
            : JSON.stringify(value, replacer, space);
    },
    enabled(enabled = true) {
        return enabled ? strict_impl : native_impl;
    }
};
/* istanbul ignore next */
exports.default = process.env.NODE_ENV === 'production' ? native_impl : strict_impl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvSlNPTnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7R0FNRzs7O0FBRUgsbURBQTRCO0FBRTVCLDhGQUE2RDtBQUM3RCxvRkFBbUQ7QUFRUCxDQUFDO0FBRTdDOzs7Ozs7Ozs7R0FTRztBQUNILFNBQVMsa0JBQWtCLENBQUUsUUFBbUI7SUFDNUMsSUFBSSxPQUFPLFFBQVEsS0FBSyxVQUFVLEVBQUU7UUFDaEMsT0FBTyxRQUFRLENBQUE7S0FDbEI7SUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDekIsT0FBTyxVQUFVLEdBQVcsRUFBRSxLQUFVO1lBQ3BDLE9BQU8sQ0FBQyxHQUFHLEtBQUssRUFBRSxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUE7UUFDM0UsQ0FBQyxDQUFBO0tBQ0o7SUFFRCxnSEFBZ0g7SUFDaEgsNkdBQTZHO0lBQzdHLGdCQUFnQjtJQUNoQixPQUFPLElBQUksQ0FBQTtBQUNmLENBQUM7QUFFRCxNQUFNLGFBQWE7SUFHZixZQUFxQixRQUE0QjtRQUM3QyxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQTtJQUM1QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFFLEtBQVUsRUFBRSxRQUFrQjtRQUNsRCxNQUFNLG1CQUFtQixHQUFHLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQ3hELE1BQU0sUUFBUSxHQUFHLElBQUksYUFBYSxDQUFDLG1CQUFtQixDQUFDLENBQUE7UUFDdkQsTUFBTSxXQUFXLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEtBQUss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QVEsRUFBRSxLQUFLLENBQUMsQ0FBQTtJQUNoRCxDQUFDO0lBQ0QsT0FBTyxDQUFFLFVBQW1CLElBQUk7UUFDNUIsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFBO0lBQzlDLENBQUM7Q0FDSixDQUFBO0FBRUQsMEJBQTBCO0FBQzFCLGtCQUFlLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxLQUFLLFlBQVksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGpzb24tc3RyaWN0aWZ5XG4gKlxuICogQHZlcnNpb24gNi4zLjBcbiAqIEBhdXRob3IgUmFwaGFlbCBQaWd1bGxhIDxwaWd1bGxhQGZvdXI2Ni5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ3V0aWwnXG5cbmltcG9ydCBDaXJjdWxhclJlZmVyZW5jZUVycm9yIGZyb20gJy4vQ2lyY3VsYXJSZWZlcmVuY2VFcnJvcidcbmltcG9ydCBJbnZhbGlkVmFsdWVFcnJvciBmcm9tICcuL0ludmFsaWRWYWx1ZUVycm9yJ1xuXG50eXBlIEFuY2VzdG9ycyA9IFNldDxvYmplY3R8YW55W10+O1xudHlwZSBSZXBsYWNlckZuID0gKHRoaXM6IGFueSwga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IGFueTtcbnR5cGUgUmVwbGFjZXIgPSBSZXBsYWNlckZufChzdHJpbmd8bnVtYmVyKVtdfHVuZGVmaW5lZHxudWxsO1xudHlwZSBOb3JtYWxpemVkUmVwbGFjZXIgPSBudWxsfCgoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IGFueSk7XG50eXBlIEdlbmVyaWNBcnJheSA9IGFueVtdO1xuXG5pbnRlcmZhY2UgR2VuZXJpY09iamVjdCB7W2tleTogc3RyaW5nXTogYW55fTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgdXNlci1zcGVjaWZpZWQgcmVwbGFjZXIgZnVuY3Rpb24uXG4gKlxuICogSW4gc2hvcnQsIEpTT04uc3RyaW5naWZ5J3MgXCJyZXBsYWNlclwiIHBhcmFtZXRlciBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgdGhlXG4gKiBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLiBUaGlzIG1ldGhvZCBub3JtYWxpemVzIHRoZSBsYXR0ZXIgY2FzZSB0byB0aGUgZm9ybWVyIHNvIHdlIGNhbiBhbHdheXMgdHJlYXQgdGhlXG4gKiBcInJlcGxhY2VyXCIgb3B0aW9uIGFzIGEgZnVuY3Rpb24gaW50ZXJuYWxseS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVwbGFjZXIgZnVuY3Rpb24gdGFrZSBhIGxvb2sgYXQgdGhlIGRvY3VtZW50YXRpb24gb25cbiAqIFtNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5I1RoZV9yZXBsYWNlcl9wYXJhbWV0ZXIpLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVfcmVwbGFjZXIgKHJlcGxhY2VyPzogUmVwbGFjZXIpOiBOb3JtYWxpemVkUmVwbGFjZXIge1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBSZXBsYWNlckZuIHtcbiAgICAgICAgICAgIHJldHVybiAoa2V5ICE9PSAnJyAmJiByZXBsYWNlci5pbmRleE9mKGtleSkgPT09IC0xKSA/IHVuZGVmaW5lZCA6IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCBlYXNpbHkgbm9ybWFsaXplIGFuIFwiZW1wdHkgcmVwbGFjZXJcIiB3aXRoIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBiZWNhdXNlIHdlIGxhdGVyIG5lZWQgdG8gZGlzdGluZ3Vpc2hcbiAgICAvLyBiZXR3ZWVuIGEgXCJyZWFsXCIgdW5kZWZpbmVkICh3aGljaCBpcyBpbGxlZ2FsKSBhbmQgYW4gdW5kZWZpbmVkIHJldHVybmVkIGJ5IHRoZSByZXBsYWNlciAod2hpY2ggbWVhbnMgXCJkcm9wXG4gICAgLy8gdGhhdCB2YWx1ZVwiKS5cbiAgICByZXR1cm4gbnVsbFxufVxuXG5jbGFzcyBKU09Oc3RyaWN0aWZ5IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlcGxhY2VyOiBOb3JtYWxpemVkUmVwbGFjZXJcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IgKHJlcGxhY2VyOiBOb3JtYWxpemVkUmVwbGFjZXIpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlciA9IHJlcGxhY2VyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRyb3AtaW4gcmVwbGFjZW1lbnQgZnVuY3Rpb24gZm9yIEpTT04uc3RyaW5naWZ5LlxuICAgICAqXG4gICAgICogQHRocm93cyB7SW52YWxpZFZhbHVlRXJyb3J9XG4gICAgICogQHRocm93cyB7Q2lyY3VsYXJSZWZlcmVuY2VFcnJvcn1cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHZhbGlkYXRlICh2YWx1ZTogYW55LCByZXBsYWNlcjogUmVwbGFjZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZF9yZXBsYWNlciA9IG5vcm1hbGl6ZV9yZXBsYWNlcihyZXBsYWNlcilcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgSlNPTnN0cmljdGlmeShub3JtYWxpemVkX3JlcGxhY2VyKVxuICAgICAgICBjb25zdCBpbml0aWFsRGF0YSA9IG5vcm1hbGl6ZWRfcmVwbGFjZXIgPyBub3JtYWxpemVkX3JlcGxhY2VyLmNhbGwodmFsdWUsICcnLCB2YWx1ZSkgOiB2YWx1ZVxuXG4gICAgICAgIGluc3RhbmNlLmNoZWNrKGluaXRpYWxEYXRhLCBbXSwgbmV3IFNldCgpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGNoZWNrIGlmIHRoZSBnaXZlbiBvYmplY3QgY2FuIGJlIHNlcmlhbGl6ZWQgdG8gSlNPTiBzYWZlbHkuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkVmFsdWVFcnJvcn1cbiAgICAgKiBAdGhyb3dzIHtDaXJjdWxhclJlZmVyZW5jZUVycm9yfVxuICAgICAqL1xuICAgIHByaXZhdGUgY2hlY2tfb2JqZWN0IChvYmplY3Q6IEdlbmVyaWNPYmplY3QsIHJlZmVyZW5jZXM6IHN0cmluZ1tdLCBhbmNlc3RvcnM6IEFuY2VzdG9ycyk6IHZvaWQge1xuICAgICAgICBsZXQgYWN0dWFsXG5cbiAgICAgICAgdGhpcy5hc3NlcnRfbm9fY3ljbGUob2JqZWN0LCByZWZlcmVuY2VzLCBhbmNlc3RvcnMpXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhY3R1YWwgPSBvYmplY3QudG9KU09OKClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrKGFjdHVhbCwgcmVmZXJlbmNlcywgYW5jZXN0b3JzKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBhY3R1YWwgPSB0aGlzLnJlcGxhY2VyID8gdGhpcy5yZXBsYWNlci5jYWxsKG9iamVjdCwga2V5LCBvYmplY3Rba2V5XSkgOiBvYmplY3Rba2V5XVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVwbGFjZXIgfHwgYWN0dWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrKGFjdHVhbCwgcmVmZXJlbmNlcy5jb25jYXQoa2V5KSwgYW5jZXN0b3JzLmFkZChvYmplY3QpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgY2hlY2sgaWYgdGhlIGdpdmVuIGFycmF5IGNhbiBiZSBzZXJpYWxpemVkIHRvIEpTT04gc2FmZWx5LlxuICAgICAqXG4gICAgICogQHRocm93cyB7SW52YWxpZFZhbHVlRXJyb3J9XG4gICAgICogQHRocm93cyB7Q2lyY3VsYXJSZWZlcmVuY2VFcnJvcn1cbiAgICAgKi9cbiAgICBwcml2YXRlIGNoZWNrX2FycmF5IChhcnJheTogR2VuZXJpY0FycmF5LCByZWZlcmVuY2VzOiBzdHJpbmdbXSwgYW5jZXN0b3JzOiBBbmNlc3RvcnMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hc3NlcnRfbm9fY3ljbGUoYXJyYXksIHJlZmVyZW5jZXMsIGFuY2VzdG9ycylcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhY3R1YWwgPSB0aGlzLnJlcGxhY2VyID8gdGhpcy5yZXBsYWNlci5jYWxsKGFycmF5LCBTdHJpbmcoaSksIGFycmF5W2ldKSA6IGFycmF5W2ldXG5cbiAgICAgICAgICAgIHRoaXMuY2hlY2soYWN0dWFsLCByZWZlcmVuY2VzLmNvbmNhdChTdHJpbmcoaSkpLCBhbmNlc3RvcnMuYWRkKGFycmF5KSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiBhIGtub3duLCBub24tc2VyaWFsaXphYmxlIHR5cGUgYW5kIHByb3ZpZGUgYSBtb3JlIHNwZWNpZmljLCBoZWxwZnVsIGVycm9yIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkVmFsdWVFcnJvcn1cbiAgICAgKi9cbiAgICBwcml2YXRlIGNoZWNrX2NvbW1vbl90eXBlcyAodmFsdWU6IGFueSwgcmVmZXJlbmNlczogc3RyaW5nW10pOiB2b2lkIHtcbiAgICAgICAgaWYgKHV0aWwudHlwZXMuaXNOYXRpdmVFcnJvcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmFsdWVFcnJvcignQW4gZXJyb3Igb2JqZWN0IGlzIG5vdCBKU09OLXNlcmlhbGl6YWJsZScsIHZhbHVlLCByZWZlcmVuY2VzKVxuICAgICAgICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZhbHVlRXJyb3IoJ0EgUmVnRXhwIGlzIG5vdCBKU09OLXNlcmlhbGl6YWJsZScsIHZhbHVlLCByZWZlcmVuY2VzKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmFsdWVFcnJvcigndW5kZWZpbmVkIGlzIG5vdCBKU09OLXNlcmlhbGl6YWJsZScsIHZhbHVlLCByZWZlcmVuY2VzKVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmFsdWVFcnJvcignQSBzeW1ib2wgaXMgbm90IEpTT04tc2VyaWFsaXphYmxlJywgdmFsdWUsIHJlZmVyZW5jZXMpXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZhbHVlRXJyb3IoJ0EgZnVuY3Rpb24gaXMgbm90IEpTT04tc2VyaWFsaXphYmxlJywgdmFsdWUsIHJlZmVyZW5jZXMpXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRWYWx1ZUVycm9yKCdBIEJpZ0ludCBpcyBub3QgSlNPTi1zZXJpYWxpemFibGUnLCB2YWx1ZSwgcmVmZXJlbmNlcylcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSdzIHN0cmluZyByZXByZXNlbnRhdGlvbiBpdHNlbGYgd2lsbCBhY3R1YWxseSBiZSBkZXNjcmlwdGl2ZSAoXCJJbmZpbml0eVwiLCBcIi1JbmZpbml0eVwiIG9yIFwiTmFOXCIpLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRWYWx1ZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgSlNPTi1zZXJpYWxpemFibGVgLCB2YWx1ZSwgcmVmZXJlbmNlcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgc2VyaWFsaXplZCB0byBKU09OIHNhZmVseS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRWYWx1ZUVycm9yfVxuICAgICAqIEB0aHJvd3Mge0NpcmN1bGFyUmVmZXJlbmNlRXJyb3J9XG4gICAgICovXG4gICAgcHJpdmF0ZSBjaGVjayAodmFsdWU6IGFueSwgcmVmZXJlbmNlczogc3RyaW5nW10sIGFuY2VzdG9yczogQW5jZXN0b3JzKTogdm9pZCB7XG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgbW9zdCBjb21tb24gbm9uLXNlcmlhbGl6YWJsZSB0eXBlcy5cbiAgICAgICAgdGhpcy5jaGVja19jb21tb25fdHlwZXModmFsdWUsIHJlZmVyZW5jZXMpXG5cbiAgICAgICAgLy8gUHJpbWl0aXZlIHR5cGVzIGFyZSBhbHdheXMgb2theSAod2UndmUgYWxyZWFkeSBjaGVja2VkIGZvciBub24tZmluaXRlIG51bWJlcnMpLlxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gSWYgYW4gYXJyYXksIGNoZWNrIGl0cyBlbGVtZW50cy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrX2FycmF5KHZhbHVlLCByZWZlcmVuY2VzLCBhbmNlc3RvcnMpXG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gSWYgYW4gb2JqZWN0LCBjaGVjayBpdHMgcHJvcGVydGllcyAod2UndmUgYWxyZWFkeSBjaGVja2VkIGZvciBudWxsKS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrX29iamVjdCh2YWx1ZSwgcmVmZXJlbmNlcywgYW5jZXN0b3JzKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBjYXNlIHdpbGwgbm90IG9jY3VyIGluIGEgcmVndWxhciBOb2RlLmpzIG9yIGJyb3dzZXIgZW52aXJvbm1lbnQsIGJ1dCBjb3VsZCBoYXBwZW4gaWYgeW91IHJ1biB5b3VyXG4gICAgICAgIC8vIHNjcmlwdCBpbiBhbiBlbmdpbmUgbGlrZSBSaGlubyBvciBOYXNob3JuIGFuZCB0cnkgdG8gc2VyaWFsaXplIGEgaG9zdCBvYmplY3QuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmFsdWVFcnJvcignSW52YWxpZCB0eXBlJywgdmFsdWUsIHJlZmVyZW5jZXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGNpcmN1bGFyIHJlZmVyZW5jZSwgaS5lLiB3aGV0aGVyIGl0IGlzIG9uZSBvZiBpdHMgb3duIGFuY2VzdG9ycy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0NpcmN1bGFyUmVmZXJlbmNlRXJyb3J9XG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3NlcnRfbm9fY3ljbGUgKHZhbHVlOiBHZW5lcmljQXJyYXl8R2VuZXJpY09iamVjdCwgcmVmZXJlbmNlczogc3RyaW5nW10sIGFuY2VzdG9yczogQW5jZXN0b3JzKTogdm9pZCB7XG4gICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENpcmN1bGFyUmVmZXJlbmNlRXJyb3IocmVmZXJlbmNlcylcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCB0eXBlIEpTT05zID0gSlNPTiAmIHtcbiAgICByZWFkb25seSBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0pTT04nO1xuICAgIGVuYWJsZWQgKGVuYWJsZWQ/OiBib29sZWFuKTogSlNPTnM7XG59XG5cbmNvbnN0IG5hdGl2ZV9pbXBsOiBKU09OcyA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ0pTT04nLFxuICAgIHBhcnNlOiBKU09OLnBhcnNlLFxuICAgIHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnksXG4gICAgZW5hYmxlZCAoZW5hYmxlZDogYm9vbGVhbiA9IHRydWUpOiBKU09OcyB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbiAgICAgICAgcmV0dXJuIGVuYWJsZWQgPyBzdHJpY3RfaW1wbCA6IG5hdGl2ZV9pbXBsXG4gICAgfVxufVxuXG5jb25zdCBzdHJpY3RfaW1wbDogSlNPTnMgPSB7XG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdKU09OJyxcbiAgICBwYXJzZTogSlNPTi5wYXJzZSxcbiAgICBzdHJpbmdpZnkgKHZhbHVlOiBhbnksIHJlcGxhY2VyOiBSZXBsYWNlciwgc3BhY2U/OiBzdHJpbmd8bnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgSlNPTnN0cmljdGlmeS52YWxpZGF0ZSh2YWx1ZSwgcmVwbGFjZXIpXG5cbiAgICAgICAgLy8gT3ZlcmxvYWRpbmcgaW4gVHlwZVNjcmlwdCBzZWVtcyB0byBiZSBhIGJpdCB3b25reS4uLlxuICAgICAgICByZXR1cm4gdHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG4gICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG4gICAgfSxcbiAgICBlbmFibGVkIChlbmFibGVkOiBib29sZWFuID0gdHJ1ZSk6IEpTT05zIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZWQgPyBzdHJpY3RfaW1wbCA6IG5hdGl2ZV9pbXBsXG4gICAgfVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGRlZmF1bHQgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IG5hdGl2ZV9pbXBsIDogc3RyaWN0X2ltcGxcbiJdfQ==