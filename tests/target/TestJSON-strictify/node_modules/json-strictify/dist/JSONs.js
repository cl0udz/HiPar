"use strict";
/**
 * json-strictify
 *
 * @version 6.3.0
 * @author Raphael Pigulla <pigulla@four66.com>
 * @license MIT
 */

var _native_impl, _strict_impl;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = require("tslib");

var util = tslib_1.__importStar(require("util"));

var CircularReferenceError_1 = tslib_1.__importDefault(require("./CircularReferenceError"));

var InvalidValueError_1 = tslib_1.__importDefault(require("./InvalidValueError"));

;
/**
 * Normalizes a user-specified replacer function.
 *
 * In short, JSON.stringify's "replacer" parameter can either be a function or an array containing the names of the
 * properties to be included. This method normalizes the latter case to the former so we can always treat the
 * "replacer" option as a function internally.
 *
 * For more information about the replacer function take a look at the documentation on
 * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter).
 */

function normalize_replacer(replacer) {
  if (typeof replacer === 'function') {
    return replacer;
  }

  if (Array.isArray(replacer)) {
    return function (key, value) {
      return key !== '' && replacer.indexOf(key) === -1 ? undefined : value;
    };
  } // We can't easily normalize an "empty replacer" with the identity function because we later need to distinguish
  // between a "real" undefined (which is illegal) and an undefined returned by the replacer (which means "drop
  // that value").


  return null;
}

var JSONstrictify =
/*#__PURE__*/
function () {
  function JSONstrictify(replacer) {
    _classCallCheck(this, JSONstrictify);

    this.replacer = replacer;
  }
  /**
   * The drop-in replacement function for JSON.stringify.
   *
   * @throws {InvalidValueError}
   * @throws {CircularReferenceError}
   */


  _createClass(JSONstrictify, [{
    key: "check_object",

    /**
     * Recursively check if the given object can be serialized to JSON safely.
     *
     * @throws {InvalidValueError}
     * @throws {CircularReferenceError}
     */
    value: function check_object(object, references, ancestors) {
      var actual;
      this.assert_no_cycle(object, references, ancestors);

      if (typeof object.toJSON === 'function') {
        actual = object.toJSON();
        return this.check(actual, references, ancestors);
      }

      for (var key in object) {
        actual = this.replacer ? this.replacer.call(object, key, object[key]) : object[key];

        if (!this.replacer || actual !== undefined) {
          this.check(actual, references.concat(key), ancestors.add(object));
        }
      }
    }
    /**
     * Recursively check if the given array can be serialized to JSON safely.
     *
     * @throws {InvalidValueError}
     * @throws {CircularReferenceError}
     */

  }, {
    key: "check_array",
    value: function check_array(array, references, ancestors) {
      this.assert_no_cycle(array, references, ancestors);

      for (var i = 0; i < array.length; ++i) {
        var actual = this.replacer ? this.replacer.call(array, String(i), array[i]) : array[i];
        this.check(actual, references.concat(String(i)), ancestors.add(array));
      }
    }
    /**
     * Check if the given value is of a known, non-serializable type and provide a more specific, helpful error message.
     *
     * @throws {InvalidValueError}
     */

  }, {
    key: "check_common_types",
    value: function check_common_types(value, references) {
      if (util.types.isNativeError(value)) {
        throw new InvalidValueError_1["default"]('An error object is not JSON-serializable', value, references);
      } else if (util.types.isRegExp(value)) {
        throw new InvalidValueError_1["default"]('A RegExp is not JSON-serializable', value, references);
      } else if (value === undefined) {
        throw new InvalidValueError_1["default"]('undefined is not JSON-serializable', value, references);
      } else if (_typeof(value) === 'symbol') {
        throw new InvalidValueError_1["default"]('A symbol is not JSON-serializable', value, references);
      } else if (typeof value === 'function') {
        throw new InvalidValueError_1["default"]('A function is not JSON-serializable', value, references);
      } else if (typeof value === 'bigint') {
        throw new InvalidValueError_1["default"]('A BigInt is not JSON-serializable', value, references);
      } else if (typeof value === 'number' && !isFinite(value)) {
        // The value's string representation itself will actually be descriptive ("Infinity", "-Infinity" or "NaN").
        throw new InvalidValueError_1["default"]("".concat(value, " is not JSON-serializable"), value, references);
      }
    }
    /**
     * Recursively check if the given value can be serialized to JSON safely.
     *
     * @throws {InvalidValueError}
     * @throws {CircularReferenceError}
     */

  }, {
    key: "check",
    value: function check(value, references, ancestors) {
      // Check for the most common non-serializable types.
      this.check_common_types(value, references); // Primitive types are always okay (we've already checked for non-finite numbers).

      if (value === null || typeof value === 'string' || typeof value === 'boolean' || typeof value === 'number') {
        return;
      }

      if (Array.isArray(value)) {
        // If an array, check its elements.
        return this.check_array(value, references, ancestors);
      }
      /* istanbul ignore else */


      if (_typeof(value) === 'object') {
        // If an object, check its properties (we've already checked for null).
        return this.check_object(value, references, ancestors);
      } // This case will not occur in a regular Node.js or browser environment, but could happen if you run your
      // script in an engine like Rhino or Nashorn and try to serialize a host object.

      /* istanbul ignore next */


      throw new InvalidValueError_1["default"]('Invalid type', value, references);
    }
    /**
     * Check if the passed value is a circular reference, i.e. whether it is one of its own ancestors.
     *
     * @throws {CircularReferenceError}
     */

  }, {
    key: "assert_no_cycle",
    value: function assert_no_cycle(value, references, ancestors) {
      if (ancestors.has(value)) {
        throw new CircularReferenceError_1["default"](references);
      }
    }
  }], [{
    key: "validate",
    value: function validate(value, replacer) {
      var normalized_replacer = normalize_replacer(replacer);
      var instance = new JSONstrictify(normalized_replacer);
      var initialData = normalized_replacer ? normalized_replacer.call(value, '', value) : value;
      instance.check(initialData, [], new Set());
    }
  }]);

  return JSONstrictify;
}();

;
var native_impl = (_native_impl = {}, _defineProperty(_native_impl, Symbol.toStringTag, 'JSON'), _defineProperty(_native_impl, "parse", JSON.parse), _defineProperty(_native_impl, "stringify", JSON.stringify), _defineProperty(_native_impl, "enabled", function enabled() {
  var _enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
  return _enabled ? strict_impl : native_impl;
}), _native_impl);
var strict_impl = (_strict_impl = {}, _defineProperty(_strict_impl, Symbol.toStringTag, 'JSON'), _defineProperty(_strict_impl, "parse", JSON.parse), _defineProperty(_strict_impl, "stringify", function stringify(value, replacer, space) {
  JSONstrictify.validate(value, replacer); // Overloading in TypeScript seems to be a bit wonky...

  return typeof replacer === 'function' ? JSON.stringify(value, replacer, space) : JSON.stringify(value, replacer, space);
}), _defineProperty(_strict_impl, "enabled", function enabled() {
  var _enabled2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  return _enabled2 ? strict_impl : native_impl;
}), _strict_impl);
/* istanbul ignore next */

exports["default"] = process.env.NODE_ENV === 'production' ? native_impl : strict_impl;