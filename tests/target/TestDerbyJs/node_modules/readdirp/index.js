'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.some");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-properties");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-own-property-descriptor");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

function _typeof5(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof5 = function _typeof5(obj) { return typeof obj; }; } else { _typeof5 = function _typeof5(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof5(obj); }

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.some");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-properties");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-own-property-descriptor");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

function _typeof4(obj) {
  if (typeof Symbol === "function" && _typeof5(Symbol.iterator) === "symbol") {
    _typeof4 = function _typeof4(obj) {
      return _typeof5(obj);
    };
  } else {
    _typeof4 = function _typeof4(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof5(obj);
    };
  }

  return _typeof4(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.some");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-properties");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-own-property-descriptor");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

function _typeof3(obj) {
  if (typeof Symbol === "function" && _typeof4(Symbol.iterator) === "symbol") {
    _typeof3 = function _typeof3(obj) {
      return _typeof4(obj);
    };
  } else {
    _typeof3 = function _typeof3(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof4(obj);
    };
  }

  return _typeof3(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.some");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-properties");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-own-property-descriptor");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.some");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-properties");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-own-property-descriptor");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

require("regenerator-runtime/runtime");

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var fs = require('fs');

var _require = require('stream'),
    Readable = _require.Readable;

var sysPath = require('path');

var _require2 = require('util'),
    promisify = _require2.promisify;

var picomatch = require('picomatch');

var readdir = promisify(fs.readdir);
var stat = promisify(fs.stat);
var lstat = promisify(fs.lstat);
/**
 * @typedef {Object} EntryInfo
 * @property {String} path
 * @property {String} fullPath
 * @property {fs.Stats=} stats
 * @property {fs.Dirent=} dirent
 * @property {String} basename
 */

var BANG = '!';
var NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);
var FILE_TYPE = 'files';
var DIR_TYPE = 'directories';
var FILE_DIR_TYPE = 'files_directories';
var EVERYTHING_TYPE = 'all';
var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];

var isNormalFlowError = function isNormalFlowError(error) {
  return NORMAL_FLOW_ERRORS.has(error.code);
};

var normalizeFilter = function normalizeFilter(filter) {
  if (filter === undefined) return;
  if (typeof filter === 'function') return filter;

  if (typeof filter === 'string') {
    var glob = picomatch(filter.trim());
    return function (entry) {
      return glob(entry.basename);
    };
  }

  if (Array.isArray(filter)) {
    var positive = [];
    var negative = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = filter[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;
        var trimmed = item.trim();

        if (trimmed.charAt(0) === BANG) {
          negative.push(picomatch(trimmed.slice(1)));
        } else {
          positive.push(picomatch(trimmed));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (negative.length > 0) {
      if (positive.length > 0) {
        return function (entry) {
          return positive.some(function (f) {
            return f(entry.basename);
          }) && !negative.some(function (f) {
            return f(entry.basename);
          });
        };
      }

      return function (entry) {
        return !negative.some(function (f) {
          return f(entry.basename);
        });
      };
    }

    return function (entry) {
      return positive.some(function (f) {
        return f(entry.basename);
      });
    };
  }
};

var ReaddirpStream =
/*#__PURE__*/
function (_Readable) {
  _inherits(ReaddirpStream, _Readable);

  _createClass(ReaddirpStream, null, [{
    key: "defaultOptions",
    get: function get() {
      return {
        root: '.',

        /* eslint-disable no-unused-vars */
        fileFilter: function fileFilter(path) {
          return true;
        },
        directoryFilter: function directoryFilter(path) {
          return true;
        },

        /* eslint-enable no-unused-vars */
        type: FILE_TYPE,
        lstat: false,
        depth: 2147483648,
        alwaysStat: false
      };
    }
  }]);

  function ReaddirpStream() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ReaddirpStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReaddirpStream).call(this, {
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options.highWaterMark || 4096
    }));

    var opts = _objectSpread({}, ReaddirpStream.defaultOptions, {}, options);

    var root = opts.root,
        type = opts.type;
    _this._fileFilter = normalizeFilter(opts.fileFilter);
    _this._directoryFilter = normalizeFilter(opts.directoryFilter);
    var statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).

    if (process.platform === 'win32' && stat.length === 3) {
      _this._stat = function (path) {
        return statMethod(path, {
          bigint: true
        });
      };
    } else {
      _this._stat = statMethod;
    }

    _this._maxDepth = opts.depth;
    _this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    _this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    _this._wantsEverything = type === EVERYTHING_TYPE;
    _this._root = sysPath.resolve(root);
    _this._isDirent = 'Dirent' in fs && !opts.alwaysStat;
    _this._statsProp = _this._isDirent ? 'dirent' : 'stats';
    _this._rdOptions = {
      encoding: 'utf8',
      withFileTypes: _this._isDirent
    }; // Launch stream with one parent, the root dir.

    try {
      _this.parents = [_this._exploreDir(root, 1)];
    } catch (error) {
      _this.destroy(error);
    }

    _this.reading = false;
    _this.parent = undefined;
    return _this;
  }

  _createClass(ReaddirpStream, [{
    key: "_read",
    value: function _read(batch) {
      var _this2 = this;

      var _loop, _ret;

      return regeneratorRuntime.async(function _read$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!this.reading) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return");

            case 2:
              this.reading = true;
              _context2.prev = 3;

              _loop = function _loop() {
                var _ref, path, depth, _ref$files, files, slice, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, entry, parent;

                return regeneratorRuntime.async(function _loop$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _ref = _this2.parent || {}, path = _ref.path, depth = _ref.depth, _ref$files = _ref.files, files = _ref$files === void 0 ? [] : _ref$files;

                        if (!(files.length > 0)) {
                          _context.next = 33;
                          break;
                        }

                        slice = files.splice(0, batch).map(function (dirent) {
                          return _this2._formatEntry(dirent, path);
                        });
                        _iteratorNormalCompletion2 = true;
                        _didIteratorError2 = false;
                        _iteratorError2 = undefined;
                        _context.prev = 6;
                        _context.next = 9;
                        return regeneratorRuntime.awrap(Promise.all(slice));

                      case 9:
                        _context.t0 = Symbol.iterator;
                        _iterator2 = _context.sent[_context.t0]();

                      case 11:
                        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                          _context.next = 17;
                          break;
                        }

                        entry = _step2.value;

                        if (_this2._isDirAndMatchesFilter(entry)) {
                          if (depth <= _this2._maxDepth) {
                            _this2.parents.push(_this2._exploreDir(entry.fullPath, depth + 1));
                          }

                          if (_this2._wantsDir) {
                            _this2.push(entry);

                            batch--;
                          }
                        } else if (_this2._isFileAndMatchesFilter(entry)) {
                          if (_this2._wantsFile) {
                            _this2.push(entry);

                            batch--;
                          }
                        }

                      case 14:
                        _iteratorNormalCompletion2 = true;
                        _context.next = 11;
                        break;

                      case 17:
                        _context.next = 23;
                        break;

                      case 19:
                        _context.prev = 19;
                        _context.t1 = _context["catch"](6);
                        _didIteratorError2 = true;
                        _iteratorError2 = _context.t1;

                      case 23:
                        _context.prev = 23;
                        _context.prev = 24;

                        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                          _iterator2["return"]();
                        }

                      case 26:
                        _context.prev = 26;

                        if (!_didIteratorError2) {
                          _context.next = 29;
                          break;
                        }

                        throw _iteratorError2;

                      case 29:
                        return _context.finish(26);

                      case 30:
                        return _context.finish(23);

                      case 31:
                        _context.next = 40;
                        break;

                      case 33:
                        parent = _this2.parents.pop();

                        if (parent) {
                          _context.next = 37;
                          break;
                        }

                        _this2.push(null);

                        return _context.abrupt("return", "break");

                      case 37:
                        _context.next = 39;
                        return regeneratorRuntime.awrap(parent);

                      case 39:
                        _this2.parent = _context.sent;

                      case 40:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, null, null, [[6, 19, 23, 31], [24,, 26, 30]]);
              };

            case 5:
              if (!(!this.destroyed && batch > 0)) {
                _context2.next = 13;
                break;
              }

              _context2.next = 8;
              return regeneratorRuntime.awrap(_loop());

            case 8:
              _ret = _context2.sent;

              if (!(_ret === "break")) {
                _context2.next = 11;
                break;
              }

              return _context2.abrupt("break", 13);

            case 11:
              _context2.next = 5;
              break;

            case 13:
              _context2.next = 18;
              break;

            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](3);
              this.destroy(_context2.t0);

            case 18:
              _context2.prev = 18;
              this.reading = false;
              return _context2.finish(18);

            case 21:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[3, 15, 18, 21]]);
    }
  }, {
    key: "_exploreDir",
    value: function _exploreDir(path, depth) {
      var files;
      return regeneratorRuntime.async(function _exploreDir$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return regeneratorRuntime.awrap(readdir(path, this._rdOptions));

            case 3:
              files = _context3.sent;
              _context3.next = 9;
              break;

            case 6:
              _context3.prev = 6;
              _context3.t0 = _context3["catch"](0);

              this._onError(_context3.t0);

            case 9:
              return _context3.abrupt("return", {
                files: files,
                depth: depth,
                path: path
              });

            case 10:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[0, 6]]);
    }
  }, {
    key: "_formatEntry",
    value: function _formatEntry(dirent, path) {
      var basename, fullPath, entry;
      return regeneratorRuntime.async(function _formatEntry$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              basename = this._isDirent ? dirent.name : dirent;
              fullPath = sysPath.resolve(sysPath.join(path, basename));
              entry = {
                path: sysPath.relative(this._root, fullPath),
                fullPath: fullPath,
                basename: basename
              };
              _context4.prev = 3;

              if (!this._isDirent) {
                _context4.next = 8;
                break;
              }

              _context4.t0 = dirent;
              _context4.next = 11;
              break;

            case 8:
              _context4.next = 10;
              return regeneratorRuntime.awrap(this._stat(fullPath));

            case 10:
              _context4.t0 = _context4.sent;

            case 11:
              entry[this._statsProp] = _context4.t0;
              _context4.next = 17;
              break;

            case 14:
              _context4.prev = 14;
              _context4.t1 = _context4["catch"](3);

              this._onError(_context4.t1);

            case 17:
              return _context4.abrupt("return", entry);

            case 18:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this, [[3, 14]]);
    }
  }, {
    key: "_onError",
    value: function _onError(err) {
      if (isNormalFlowError(err) && !this.destroyed) {
        this.emit('warn', err);
      } else {
        throw err;
      }
    }
  }, {
    key: "_isDirAndMatchesFilter",
    value: function _isDirAndMatchesFilter(entry) {
      // entry may be undefined, because a warning or an error were emitted
      // and the statsProp is undefined
      var stats = entry && entry[this._statsProp];
      return stats && stats.isDirectory() && this._directoryFilter(entry);
    }
  }, {
    key: "_isFileAndMatchesFilter",
    value: function _isFileAndMatchesFilter(entry) {
      var stats = entry && entry[this._statsProp];
      var isFileType = stats && (this._wantsEverything && !stats.isDirectory() || stats.isFile() || stats.isSymbolicLink());
      return isFileType && this._fileFilter(entry);
    }
  }]);

  return ReaddirpStream;
}(Readable);
/**
 * @typedef {Object} ReaddirpArguments
 * @property {Function=} fileFilter
 * @property {Function=} directoryFilter
 * @property {String=} type
 * @property {Number=} depth
 * @property {String=} root
 * @property {Boolean=} lstat
 * @property {Boolean=} bigint
 */

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param {String} root Root directory
 * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
 */


var readdirp = function readdirp(root) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var type = options.entryType || options.type;
  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility

  if (type) options.type = type;

  if (!root) {
    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
  } else if (typeof root !== 'string') {
    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error("readdirp: Invalid type passed. Use one of ".concat(ALL_TYPES.join(', ')));
  }

  options.root = root;
  return new ReaddirpStream(options);
};

var readdirpPromise = function readdirpPromise(root) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise(function (resolve, reject) {
    var files = [];
    readdirp(root, options).on('data', function (entry) {
      return files.push(entry);
    }).on('end', function () {
      return resolve(files);
    }).on('error', function (error) {
      return reject(error);
    });
  });
};

readdirp.promise = readdirpPromise;
readdirp.ReaddirpStream = ReaddirpStream;
readdirp["default"] = readdirp;
module.exports = readdirp;