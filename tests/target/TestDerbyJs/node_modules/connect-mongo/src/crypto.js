'use strict';

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var Crypto =
/*#__PURE__*/
function () {
  function Crypto() {
    _classCallCheck(this, Crypto);
  }

  _createClass(Crypto, [{
    key: "init",
    value: function init(options) {
      this.crypto = require('crypto');
      this.algorithm = options.algorithm || 'aes-256-gcm';
      this.hashing = options.hashing || 'sha512';
      this.encodeas = options.encodeas || 'hex';
      this.iv_size = options.iv_size || 16;
      this.at_size = options.at_size || 16;
      this.key_size = options.key_size || 32;
      this.secret = this._deriveKey(options.secret) || false;
    }
  }, {
    key: "set",
    value: function set(plaintext) {
      var iv = this.crypto.randomBytes(this.iv_size).toString(this.encodeas);

      var aad = this._digest(iv + this.secret, JSON.stringify(plaintext), this.hashing, this.encodeas);

      var ct = this._encrypt(this.secret, JSON.stringify(plaintext), this.algorithm, this.encodeas, iv, aad);

      var hmac = this._digest(this.secret, ct.ct, this.hashing, this.encodeas);

      var obj = JSON.stringify({
        hmac: hmac,
        ct: ct.ct,
        at: ct.at,
        aad: aad,
        iv: iv
      });
      return obj;
    }
  }, {
    key: "get",
    value: function get(ciphertext) {
      var ct;

      if (ciphertext) {
        try {
          ct = JSON.parse(ciphertext);
        } catch (err) {
          ct = ciphertext;
        }
      }

      var hmac = this._digest(this.secret, ct.ct, this.hashing, this.encodeas);

      if (hmac !== ct.hmac) {
        throw new Error('Encrypted session was tampered with!');
      }

      if (ct.at) {
        ct.at = Buffer.from(ct.at);
      }

      var pt = this._decrypt(this.secret, ct.ct, this.algorithm, this.encodeas, ct.iv, ct.at, ct.aad);

      return pt;
    }
  }, {
    key: "_digest",
    value: function _digest(key, obj, hashing, encodeas) {
      var hmac = this.crypto.createHmac(this.hashing, key);
      hmac.setEncoding(encodeas);
      hmac.write(obj);
      hmac.end();
      return hmac.read().toString(encodeas);
    }
  }, {
    key: "_encrypt",
    value: function _encrypt(key, pt, algo, encodeas, iv, aad) {
      var cipher = this.crypto.createCipheriv(algo, key, iv, {
        authTagLength: this.at_size
      });
      var ct;
      var at;

      if (aad) {
        try {
          cipher.setAAD(Buffer.from(aad), {
            plaintextLength: Buffer.byteLength(pt)
          });
        } catch (err) {
          throw err;
        }
      }

      ct = cipher.update(pt, 'utf8', encodeas);
      ct += cipher["final"](encodeas);

      try {
        at = cipher.getAuthTag();
      } catch (err) {
        throw err;
      }

      return at ? {
        ct: ct,
        at: at
      } : {
        ct: ct
      };
    }
  }, {
    key: "_decrypt",
    value: function _decrypt(key, ct, algo, encodeas, iv, at, aad) {
      var cipher = this.crypto.createDecipheriv(algo, key, iv);
      var pt;

      if (at) {
        try {
          cipher.setAuthTag(Buffer.from(at));
        } catch (err) {
          throw err;
        }
      }

      if (aad) {
        try {
          cipher.setAAD(Buffer.from(aad), {
            plaintextLength: Buffer.byteLength(ct)
          });
        } catch (err) {
          throw err;
        }
      }

      pt = cipher.update(ct, encodeas, 'utf8');
      pt += cipher["final"]('utf8');
      return pt;
    }
  }, {
    key: "_deriveKey",
    value: function _deriveKey(secret) {
      var hash = this.crypto.createHash(this.hashing);
      hash.update(secret);
      var salt = hash.digest(this.encodeas).substr(0, 16);
      var key = this.crypto.pbkdf2Sync(secret, salt, 10000, 64, this.hashing);
      return key.toString(this.encodeas).substr(0, this.key_size);
    }
  }]);

  return Crypto;
}();

module.exports = new Crypto();