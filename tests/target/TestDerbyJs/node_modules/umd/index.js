'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var templateSTR = "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}defineNamespace()}})(function(){source()});\n";

function template(moduleName, options) {
  if (typeof options === 'boolean') {
    options = {
      commonJS: options
    };
  } else if (!options) {
    options = {};
  }

  var str = templateSTR.replace(/defineNamespace\(\)/g, compileNamespace(moduleName)).split('source()');
  str[0] = str[0].trim(); //make sure these are undefined so as to not get confused if modules have inner UMD systems

  str[0] += 'var define,module,exports;';
  if (options.commonJS) str[0] += 'module={exports:(exports={})};';
  str[0] += '\n';
  if (options.commonJS) str[1] = 'return module.exports;' + str[1];
  str[1] = '\n' + str[1];
  return str;
}

exports = module.exports = function (name, src, options) {
  if (typeof options === 'string' && _typeof(src) === 'object') {
    var tmp = options;
    options = src;
    src = tmp;
  }

  return exports.prelude(name, options) + src + exports.postlude(name, options);
};

exports.prelude = function (moduleName, options) {
  return template(moduleName, options)[0];
};

exports.postlude = function (moduleName, options) {
  return template(moduleName, options)[1];
};

function camelCase(name) {
  name = name.replace(/\-([a-z])/g, function (_, _char) {
    return _char.toUpperCase();
  });

  if (!/^[a-zA-Z_$]$/.test(name[0])) {
    name = name.substr(1);
  }

  var result = name.replace(/[^\w$]+/g, '');

  if (!result) {
    throw new Error('Invalid JavaScript identifier resulted from camel-casing');
  }

  return result;
}

function compileNamespace(name) {
  var names = name.split('.'); // No namespaces, yield the best case 'global.NAME = VALUE'

  if (names.length === 1) {
    return 'g.' + camelCase(name) + ' = f()'; // Acceptable case, with reasonable compilation
  } else if (names.length === 2) {
    names = names.map(camelCase);
    return '(g.' + names[0] + ' || (g.' + names[0] + ' = {})).' + names[1] + ' = f()'; // Worst case, too many namespaces to care about
  } else {
    var valueContainer = names.pop();
    return names.map(compileNamespaceStep).concat(['g.' + camelCase(valueContainer) + ' = f()']).join(';');
  }
}

function compileNamespaceStep(name) {
  name = camelCase(name);
  return 'g=(g.' + name + '||(g.' + name + ' = {}))';
}