"use strict";

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/web.timers");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wheelEventPixels = wheelEventPixels;
exports.onScrollWheel = onScrollWheel;

var _browser = require("../util/browser.js");

var _event = require("../util/event.js");

var _update_display = require("./update_display.js");

var _scrolling = require("./scrolling.js");

var wheelSamples = 0,
    wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we
// know one. These don't have to be accurate -- the result of them
// being wrong would just be a slight flicker on the first wheel
// scroll (if it is large enough).

if (_browser.ie) wheelPixelsPerUnit = -.53;else if (_browser.gecko) wheelPixelsPerUnit = 15;else if (_browser.chrome) wheelPixelsPerUnit = -.7;else if (_browser.safari) wheelPixelsPerUnit = -1 / 3;

function wheelEventDelta(e) {
  var dx = e.wheelDeltaX,
      dy = e.wheelDeltaY;
  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;else if (dy == null) dy = e.wheelDelta;
  return {
    x: dx,
    y: dy
  };
}

function wheelEventPixels(e) {
  var delta = wheelEventDelta(e);
  delta.x *= wheelPixelsPerUnit;
  delta.y *= wheelPixelsPerUnit;
  return delta;
}

function onScrollWheel(cm, e) {
  var delta = wheelEventDelta(e),
      dx = delta.x,
      dy = delta.y;
  var display = cm.display,
      scroll = display.scroller; // Quit if there's nothing to scroll here

  var canScrollX = scroll.scrollWidth > scroll.clientWidth;
  var canScrollY = scroll.scrollHeight > scroll.clientHeight;
  if (!(dx && canScrollX || dy && canScrollY)) return; // Webkit browsers on OS X abort momentum scrolls when the target
  // of the scroll event is removed from the scrollable element.
  // This hack (see related code in patchDisplay) makes sure the
  // element is kept around.

  if (dy && _browser.mac && _browser.webkit) {
    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
      for (var i = 0; i < view.length; i++) {
        if (view[i].node == cur) {
          cm.display.currentWheelTarget = cur;
          break outer;
        }
      }
    }
  } // On some browsers, horizontal scrolling will cause redraws to
  // happen before the gutter has been realigned, causing it to
  // wriggle around in a most unseemly way. When we have an
  // estimated pixels/delta value, we just handle horizontal
  // scrolling entirely here. It'll be slightly off from native, but
  // better than glitching out.


  if (dx && !_browser.gecko && !_browser.presto && wheelPixelsPerUnit != null) {
    if (dy && canScrollY) (0, _scrolling.updateScrollTop)(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
    (0, _scrolling.setScrollLeft)(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)); // Only prevent default scrolling if vertical scrolling is
    // actually possible. Otherwise, it causes vertical scroll
    // jitter on OSX trackpads when deltaX is small and deltaY
    // is large (issue #3579)

    if (!dy || dy && canScrollY) (0, _event.e_preventDefault)(e);
    display.wheelStartX = null; // Abort measurement, if in progress

    return;
  } // 'Project' the visible viewport to cover the area that is being
  // scrolled into view (if we know enough to estimate it).


  if (dy && wheelPixelsPerUnit != null) {
    var pixels = dy * wheelPixelsPerUnit;
    var top = cm.doc.scrollTop,
        bot = top + display.wrapper.clientHeight;
    if (pixels < 0) top = Math.max(0, top + pixels - 50);else bot = Math.min(cm.doc.height, bot + pixels + 50);
    (0, _update_display.updateDisplaySimple)(cm, {
      top: top,
      bottom: bot
    });
  }

  if (wheelSamples < 20) {
    if (display.wheelStartX == null) {
      display.wheelStartX = scroll.scrollLeft;
      display.wheelStartY = scroll.scrollTop;
      display.wheelDX = dx;
      display.wheelDY = dy;
      setTimeout(function () {
        if (display.wheelStartX == null) return;
        var movedX = scroll.scrollLeft - display.wheelStartX;
        var movedY = scroll.scrollTop - display.wheelStartY;
        var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
        display.wheelStartX = display.wheelStartY = null;
        if (!sample) return;
        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
        ++wheelSamples;
      }, 200);
    } else {
      display.wheelDX += dx;
      display.wheelDY += dy;
    }
  }
}