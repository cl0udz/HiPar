"use strict";

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maybeScrollWindow = maybeScrollWindow;
exports.scrollPosIntoView = scrollPosIntoView;
exports.scrollIntoView = scrollIntoView;
exports.addToScrollTop = addToScrollTop;
exports.ensureCursorVisible = ensureCursorVisible;
exports.scrollToCoords = scrollToCoords;
exports.scrollToRange = scrollToRange;
exports.scrollToCoordsRange = scrollToCoordsRange;
exports.updateScrollTop = updateScrollTop;
exports.setScrollTop = setScrollTop;
exports.setScrollLeft = setScrollLeft;

var _pos = require("../line/pos.js");

var _position_measurement = require("../measurement/position_measurement.js");

var _browser = require("../util/browser.js");

var _dom = require("../util/dom.js");

var _event = require("../util/event.js");

var _highlight_worker = require("./highlight_worker.js");

var _line_numbers = require("./line_numbers.js");

var _update_display = require("./update_display.js");

function maybeScrollWindow(cm, rect) {
  if ((0, _event.signalDOMEvent)(cm, "scrollCursorIntoView")) return;
  var display = cm.display,
      box = display.sizer.getBoundingClientRect(),
      doScroll = null;
  if (rect.top + box.top < 0) doScroll = true;else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;

  if (doScroll != null && !_browser.phantom) {
    var scrollNode = (0, _dom.elt)("div", "\u200B", null, "position: absolute;\n                         top: ".concat(rect.top - display.viewOffset - (0, _position_measurement.paddingTop)(cm.display), "px;\n                         height: ").concat(rect.bottom - rect.top + (0, _position_measurement.scrollGap)(cm) + display.barHeight, "px;\n                         left: ").concat(rect.left, "px; width: ").concat(Math.max(2, rect.right - rect.left), "px;"));
    cm.display.lineSpace.appendChild(scrollNode);
    scrollNode.scrollIntoView(doScroll);
    cm.display.lineSpace.removeChild(scrollNode);
  }
} // Scroll a given position into view (immediately), verifying that
// it actually became visible (as line heights are accurately
// measured, the position of something may 'drift' during drawing).


function scrollPosIntoView(cm, pos, end, margin) {
  if (margin == null) margin = 0;
  var rect;

  if (!cm.options.lineWrapping && pos == end) {
    // Set pos and end to the cursor positions around the character pos sticks to
    // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
    // If pos == Pos(_, 0, "before"), pos and end are unchanged
    pos = pos.ch ? (0, _pos.Pos)(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    end = pos.sticky == "before" ? (0, _pos.Pos)(pos.line, pos.ch + 1, "before") : pos;
  }

  for (var limit = 0; limit < 5; limit++) {
    var changed = false;
    var coords = (0, _position_measurement.cursorCoords)(cm, pos);
    var endCoords = !end || end == pos ? coords : (0, _position_measurement.cursorCoords)(cm, end);
    rect = {
      left: Math.min(coords.left, endCoords.left),
      top: Math.min(coords.top, endCoords.top) - margin,
      right: Math.max(coords.left, endCoords.left),
      bottom: Math.max(coords.bottom, endCoords.bottom) + margin
    };
    var scrollPos = calculateScrollPos(cm, rect);
    var startTop = cm.doc.scrollTop,
        startLeft = cm.doc.scrollLeft;

    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
      if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
    }

    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
    }

    if (!changed) break;
  }

  return rect;
} // Scroll a given set of coordinates into view (immediately).


function scrollIntoView(cm, rect) {
  var scrollPos = calculateScrollPos(cm, rect);
  if (scrollPos.scrollTop != null) updateScrollTop(cm, scrollPos.scrollTop);
  if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
} // Calculate a new scroll position needed to scroll the given
// rectangle into view. Returns an object with scrollTop and
// scrollLeft properties. When these are undefined, the
// vertical/horizontal position does not need to be adjusted.


function calculateScrollPos(cm, rect) {
  var display = cm.display,
      snapMargin = (0, _position_measurement.textHeight)(cm.display);
  if (rect.top < 0) rect.top = 0;
  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
  var screen = (0, _position_measurement.displayHeight)(cm),
      result = {};
  if (rect.bottom - rect.top > screen) rect.bottom = rect.top + screen;
  var docBottom = cm.doc.height + (0, _position_measurement.paddingVert)(display);
  var atTop = rect.top < snapMargin,
      atBottom = rect.bottom > docBottom - snapMargin;

  if (rect.top < screentop) {
    result.scrollTop = atTop ? 0 : rect.top;
  } else if (rect.bottom > screentop + screen) {
    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
    if (newTop != screentop) result.scrollTop = newTop;
  }

  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
  var screenw = (0, _position_measurement.displayWidth)(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
  var tooWide = rect.right - rect.left > screenw;
  if (tooWide) rect.right = rect.left + screenw;
  if (rect.left < 10) result.scrollLeft = 0;else if (rect.left < screenleft) result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10));else if (rect.right > screenw + screenleft - 3) result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
  return result;
} // Store a relative adjustment to the scroll position in the current
// operation (to be applied when the operation finishes).


function addToScrollTop(cm, top) {
  if (top == null) return;
  resolveScrollToPos(cm);
  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
} // Make sure that at the end of the operation the current cursor is
// shown.


function ensureCursorVisible(cm) {
  resolveScrollToPos(cm);
  var cur = cm.getCursor();
  cm.curOp.scrollToPos = {
    from: cur,
    to: cur,
    margin: cm.options.cursorScrollMargin
  };
}

function scrollToCoords(cm, x, y) {
  if (x != null || y != null) resolveScrollToPos(cm);
  if (x != null) cm.curOp.scrollLeft = x;
  if (y != null) cm.curOp.scrollTop = y;
}

function scrollToRange(cm, range) {
  resolveScrollToPos(cm);
  cm.curOp.scrollToPos = range;
} // When an operation has its scrollToPos property set, and another
// scroll action is applied before the end of the operation, this
// 'simulates' scrolling that position into view in a cheap way, so
// that the effect of intermediate scroll commands is not ignored.


function resolveScrollToPos(cm) {
  var range = cm.curOp.scrollToPos;

  if (range) {
    cm.curOp.scrollToPos = null;
    var from = (0, _position_measurement.estimateCoords)(cm, range.from),
        to = (0, _position_measurement.estimateCoords)(cm, range.to);
    scrollToCoordsRange(cm, from, to, range.margin);
  }
}

function scrollToCoordsRange(cm, from, to, margin) {
  var sPos = calculateScrollPos(cm, {
    left: Math.min(from.left, to.left),
    top: Math.min(from.top, to.top) - margin,
    right: Math.max(from.right, to.right),
    bottom: Math.max(from.bottom, to.bottom) + margin
  });
  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
} // Sync the scrollable area and scrollbars, ensure the viewport
// covers the visible area.


function updateScrollTop(cm, val) {
  if (Math.abs(cm.doc.scrollTop - val) < 2) return;
  if (!_browser.gecko) (0, _update_display.updateDisplaySimple)(cm, {
    top: val
  });
  setScrollTop(cm, val, true);
  if (_browser.gecko) (0, _update_display.updateDisplaySimple)(cm);
  (0, _highlight_worker.startWorker)(cm, 100);
}

function setScrollTop(cm, val, forceScroll) {
  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
  if (cm.display.scroller.scrollTop == val && !forceScroll) return;
  cm.doc.scrollTop = val;
  cm.display.scrollbars.setScrollTop(val);
  if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
} // Sync scroller and scrollbar, ensure the gutter elements are
// aligned.


function setScrollLeft(cm, val, isScroller, forceScroll) {
  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) return;
  cm.doc.scrollLeft = val;
  (0, _line_numbers.alignHorizontally)(cm);
  if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
  cm.display.scrollbars.setScrollLeft(val);
}