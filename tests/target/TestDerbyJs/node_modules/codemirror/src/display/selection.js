"use strict";

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/web.timers");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSelection = updateSelection;
exports.prepareSelection = prepareSelection;
exports.drawSelectionCursor = drawSelectionCursor;
exports.restartBlink = restartBlink;

var _pos = require("../line/pos.js");

var _spans = require("../line/spans.js");

var _utils_line = require("../line/utils_line.js");

var _position_measurement = require("../measurement/position_measurement.js");

var _bidi = require("../util/bidi.js");

var _dom = require("../util/dom.js");

function updateSelection(cm) {
  cm.display.input.showSelection(cm.display.input.prepareSelection());
}

function prepareSelection(cm) {
  var primary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var doc = cm.doc,
      result = {};
  var curFragment = result.cursors = document.createDocumentFragment();
  var selFragment = result.selection = document.createDocumentFragment();

  for (var i = 0; i < doc.sel.ranges.length; i++) {
    if (!primary && i == doc.sel.primIndex) continue;
    var range = doc.sel.ranges[i];
    if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;
    var collapsed = range.empty();
    if (collapsed || cm.options.showCursorWhenSelecting) drawSelectionCursor(cm, range.head, curFragment);
    if (!collapsed) drawSelectionRange(cm, range, selFragment);
  }

  return result;
} // Draws a cursor for the given range


function drawSelectionCursor(cm, head, output) {
  var pos = (0, _position_measurement.cursorCoords)(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
  var cursor = output.appendChild((0, _dom.elt)("div", "\xA0", "CodeMirror-cursor"));
  cursor.style.left = pos.left + "px";
  cursor.style.top = pos.top + "px";
  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

  if (pos.other) {
    // Secondary cursor, shown when on a 'jump' in bi-directional text
    var otherCursor = output.appendChild((0, _dom.elt)("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
    otherCursor.style.display = "";
    otherCursor.style.left = pos.other.left + "px";
    otherCursor.style.top = pos.other.top + "px";
    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
  }
}

function cmpCoords(a, b) {
  return a.top - b.top || a.left - b.left;
} // Draws the given range as a highlighted selection


function drawSelectionRange(cm, range, output) {
  var display = cm.display,
      doc = cm.doc;
  var fragment = document.createDocumentFragment();
  var padding = (0, _position_measurement.paddingH)(cm.display),
      leftSide = padding.left;
  var rightSide = Math.max(display.sizerWidth, (0, _position_measurement.displayWidth)(cm) - display.sizer.offsetLeft) - padding.right;
  var docLTR = doc.direction == "ltr";

  function add(left, top, width, bottom) {
    if (top < 0) top = 0;
    top = Math.round(top);
    bottom = Math.round(bottom);
    fragment.appendChild((0, _dom.elt)("div", null, "CodeMirror-selected", "position: absolute; left: ".concat(left, "px;\n                             top: ").concat(top, "px; width: ").concat(width == null ? rightSide - left : width, "px;\n                             height: ").concat(bottom - top, "px")));
  }

  function drawForLine(line, fromArg, toArg) {
    var lineObj = (0, _utils_line.getLine)(doc, line);
    var lineLen = lineObj.text.length;
    var start, end;

    function coords(ch, bias) {
      return (0, _position_measurement.charCoords)(cm, (0, _pos.Pos)(line, ch), "div", lineObj, bias);
    }

    function wrapX(pos, dir, side) {
      var extent = (0, _position_measurement.wrappedLineExtentChar)(cm, lineObj, null, pos);
      var prop = dir == "ltr" == (side == "after") ? "left" : "right";
      var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
      return coords(ch, prop)[prop];
    }

    var order = (0, _bidi.getOrder)(lineObj, doc.direction);
    (0, _bidi.iterateBidiSections)(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
      var ltr = dir == "ltr";
      var fromPos = coords(from, ltr ? "left" : "right");
      var toPos = coords(to - 1, ltr ? "right" : "left");
      var openStart = fromArg == null && from == 0,
          openEnd = toArg == null && to == lineLen;
      var first = i == 0,
          last = !order || i == order.length - 1;

      if (toPos.top - fromPos.top <= 3) {
        // Single line
        var openLeft = (docLTR ? openStart : openEnd) && first;
        var openRight = (docLTR ? openEnd : openStart) && last;
        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
        add(left, fromPos.top, right - left, fromPos.bottom);
      } else {
        // Multiple lines
        var topLeft, topRight, botLeft, botRight;

        if (ltr) {
          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
          topRight = docLTR ? rightSide : wrapX(from, dir, "before");
          botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
          botRight = docLTR && openEnd && last ? rightSide : toPos.right;
        } else {
          topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
          botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
        }

        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
        if (fromPos.bottom < toPos.top) add(leftSide, fromPos.bottom, null, toPos.top);
        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
      }

      if (!start || cmpCoords(fromPos, start) < 0) start = fromPos;
      if (cmpCoords(toPos, start) < 0) start = toPos;
      if (!end || cmpCoords(fromPos, end) < 0) end = fromPos;
      if (cmpCoords(toPos, end) < 0) end = toPos;
    });
    return {
      start: start,
      end: end
    };
  }

  var sFrom = range.from(),
      sTo = range.to();

  if (sFrom.line == sTo.line) {
    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
  } else {
    var fromLine = (0, _utils_line.getLine)(doc, sFrom.line),
        toLine = (0, _utils_line.getLine)(doc, sTo.line);
    var singleVLine = (0, _spans.visualLine)(fromLine) == (0, _spans.visualLine)(toLine);
    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;

    if (singleVLine) {
      if (leftEnd.top < rightStart.top - 2) {
        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
      } else {
        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
      }
    }

    if (leftEnd.bottom < rightStart.top) add(leftSide, leftEnd.bottom, null, rightStart.top);
  }

  output.appendChild(fragment);
} // Cursor-blinking


function restartBlink(cm) {
  if (!cm.state.focused) return;
  var display = cm.display;
  clearInterval(display.blinker);
  var on = true;
  display.cursorDiv.style.visibility = "";
  if (cm.options.cursorBlinkRate > 0) display.blinker = setInterval(function () {
    return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
  }, cm.options.cursorBlinkRate);else if (cm.options.cursorBlinkRate < 0) display.cursorDiv.style.visibility = "hidden";
}