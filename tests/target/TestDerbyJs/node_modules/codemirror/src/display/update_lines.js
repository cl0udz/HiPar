"use strict";

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateHeightsInViewport = updateHeightsInViewport;
exports.visibleLines = visibleLines;

var _spans = require("../line/spans.js");

var _utils_line = require("../line/utils_line.js");

var _position_measurement = require("../measurement/position_measurement.js");

var _browser = require("../util/browser.js");

function updateHeightsInViewport(cm) {
  var display = cm.display;
  var prevBottom = display.lineDiv.offsetTop;

  for (var i = 0; i < display.view.length; i++) {
    var cur = display.view[i],
        wrapping = cm.options.lineWrapping;
    var height = void 0,
        width = 0;
    if (cur.hidden) continue;

    if (_browser.ie && _browser.ie_version < 8) {
      var bot = cur.node.offsetTop + cur.node.offsetHeight;
      height = bot - prevBottom;
      prevBottom = bot;
    } else {
      var box = cur.node.getBoundingClientRect();
      height = box.bottom - box.top; // Check that lines don't extend past the right of the current
      // editor width

      if (!wrapping && cur.text.firstChild) width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
    }

    var diff = cur.line.height - height;

    if (diff > .005 || diff < -.005) {
      (0, _utils_line.updateLineHeight)(cur.line, height);
      updateWidgetHeight(cur.line);
      if (cur.rest) for (var j = 0; j < cur.rest.length; j++) {
        updateWidgetHeight(cur.rest[j]);
      }
    }

    if (width > cm.display.sizerWidth) {
      var chWidth = Math.ceil(width / (0, _position_measurement.charWidth)(cm.display));

      if (chWidth > cm.display.maxLineLength) {
        cm.display.maxLineLength = chWidth;
        cm.display.maxLine = cur.line;
        cm.display.maxLineChanged = true;
      }
    }
  }
} // Read and store the height of line widgets associated with the
// given line.


function updateWidgetHeight(line) {
  if (line.widgets) for (var i = 0; i < line.widgets.length; ++i) {
    var w = line.widgets[i],
        parent = w.node.parentNode;
    if (parent) w.height = parent.offsetHeight;
  }
} // Compute the lines that are visible in a given viewport (defaults
// the the current scroll position). viewport may contain top,
// height, and ensure (see op.scrollToPos) properties.


function visibleLines(display, doc, viewport) {
  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
  top = Math.floor(top - (0, _position_measurement.paddingTop)(display));
  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
  var from = (0, _utils_line.lineAtHeight)(doc, top),
      to = (0, _utils_line.lineAtHeight)(doc, bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
  // forces those lines into the viewport (if possible).

  if (viewport && viewport.ensure) {
    var ensureFrom = viewport.ensure.from.line,
        ensureTo = viewport.ensure.to.line;

    if (ensureFrom < from) {
      from = ensureFrom;
      to = (0, _utils_line.lineAtHeight)(doc, (0, _spans.heightAtLine)((0, _utils_line.getLine)(doc, ensureFrom)) + display.wrapper.clientHeight);
    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
      from = (0, _utils_line.lineAtHeight)(doc, (0, _spans.heightAtLine)((0, _utils_line.getLine)(doc, ensureTo)) - display.wrapper.clientHeight);
      to = ensureTo;
    }
  }

  return {
    from: from,
    to: Math.max(to, from + 1)
  };
}