"use strict";

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateLine = updateLine;
exports.cleanUpLine = cleanUpLine;
exports.buildLineContent = buildLineContent;
exports.defaultSpecialCharPlaceholder = defaultSpecialCharPlaceholder;
exports.LineView = LineView;
exports.buildViewArray = buildViewArray;
exports.Line = void 0;

var _bidi = require("../util/bidi.js");

var _browser = require("../util/browser.js");

var _dom = require("../util/dom.js");

var _event = require("../util/event.js");

var _feature_detection = require("../util/feature_detection.js");

var _misc = require("../util/misc.js");

var _highlight = require("./highlight.js");

var _spans = require("./spans.js");

var _utils_line = require("./utils_line.js");

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var Line =
/*#__PURE__*/
function () {
  function Line(text, markedSpans, estimateHeight) {
    _classCallCheck(this, Line);

    this.text = text;
    (0, _spans.attachMarkedSpans)(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  }

  _createClass(Line, [{
    key: "lineNo",
    value: function lineNo() {
      return (0, _utils_line.lineNo)(this);
    }
  }]);

  return Line;
}();

exports.Line = Line;
(0, _event.eventMixin)(Line); // Change the content (text, markers) of a line. Automatically
// invalidates cached information and tries to re-estimate the
// line's height.

function updateLine(line, text, markedSpans, estimateHeight) {
  line.text = text;
  if (line.stateAfter) line.stateAfter = null;
  if (line.styles) line.styles = null;
  if (line.order != null) line.order = null;
  (0, _spans.detachMarkedSpans)(line);
  (0, _spans.attachMarkedSpans)(line, markedSpans);
  var estHeight = estimateHeight ? estimateHeight(line) : 1;
  if (estHeight != line.height) (0, _utils_line.updateLineHeight)(line, estHeight);
} // Detach a line from the document tree and its markers.


function cleanUpLine(line) {
  line.parent = null;
  (0, _spans.detachMarkedSpans)(line);
} // Convert a style as returned by a mode (either null, or a string
// containing one or more styles) to a CSS style. This is cached,
// and also looks for line-wide styles.


var styleToClassCache = {},
    styleToClassCacheWithMode = {};

function interpretTokenStyle(style, options) {
  if (!style || /^\s*$/.test(style)) return null;
  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
  return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
} // Render the DOM representation of the text of a line. Also builds
// up a 'line map', which points at the DOM nodes that represent
// specific stretches of text, and is used by the measuring code.
// The returned object contains the DOM node, this map, and
// information about line-wide styles that were set by the mode.


function buildLineContent(cm, lineView) {
  // The padding-right forces the element to have a 'border', which
  // is needed on Webkit to be able to get line-level bounding
  // rectangles for it (in measureChar).
  var content = (0, _dom.eltP)("span", null, null, _browser.webkit ? "padding-right: .1px" : null);
  var builder = {
    pre: (0, _dom.eltP)("pre", [content], "CodeMirror-line"),
    content: content,
    col: 0,
    pos: 0,
    cm: cm,
    trailingSpace: false,
    splitSpaces: cm.getOption("lineWrapping")
  };
  lineView.measure = {}; // Iterate over the logical lines that make up this visual line.

  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
    var line = i ? lineView.rest[i - 1] : lineView.line,
        order = void 0;
    builder.pos = 0;
    builder.addToken = buildToken; // Optionally wire in some hacks into the token-rendering
    // algorithm, to deal with browser quirks.

    if ((0, _feature_detection.hasBadBidiRects)(cm.display.measure) && (order = (0, _bidi.getOrder)(line, cm.doc.direction))) builder.addToken = buildTokenBadBidi(builder.addToken, order);
    builder.map = [];
    var allowFrontierUpdate = lineView != cm.display.externalMeasured && (0, _utils_line.lineNo)(line);
    insertLineContent(line, builder, (0, _highlight.getLineStyles)(cm, line, allowFrontierUpdate));

    if (line.styleClasses) {
      if (line.styleClasses.bgClass) builder.bgClass = (0, _dom.joinClasses)(line.styleClasses.bgClass, builder.bgClass || "");
      if (line.styleClasses.textClass) builder.textClass = (0, _dom.joinClasses)(line.styleClasses.textClass, builder.textClass || "");
    } // Ensure at least a single node is present, for measuring.


    if (builder.map.length == 0) builder.map.push(0, 0, builder.content.appendChild((0, _feature_detection.zeroWidthElement)(cm.display.measure))); // Store the map and a cache object for the current logical line

    if (i == 0) {
      lineView.measure.map = builder.map;
      lineView.measure.cache = {};
    } else {
      ;
      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
      (lineView.measure.caches || (lineView.measure.caches = [])).push({});
    }
  } // See issue #2901


  if (_browser.webkit) {
    var last = builder.content.lastChild;
    if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) builder.content.className = "cm-tab-wrap-hack";
  }

  (0, _event.signal)(cm, "renderLine", cm, lineView.line, builder.pre);
  if (builder.pre.className) builder.textClass = (0, _dom.joinClasses)(builder.pre.className, builder.textClass || "");
  return builder;
}

function defaultSpecialCharPlaceholder(ch) {
  var token = (0, _dom.elt)("span", "\u2022", "cm-invalidchar");
  token.title = "\\u" + ch.charCodeAt(0).toString(16);
  token.setAttribute("aria-label", token.title);
  return token;
} // Build up the DOM representation for a single token, and add it to
// the line map. Takes care to render special characters separately.


function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
  if (!text) return;
  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
  var special = builder.cm.state.specialChars,
      mustWrap = false;
  var content;

  if (!special.test(text)) {
    builder.col += text.length;
    content = document.createTextNode(displayText);
    builder.map.push(builder.pos, builder.pos + text.length, content);
    if (_browser.ie && _browser.ie_version < 9) mustWrap = true;
    builder.pos += text.length;
  } else {
    content = document.createDocumentFragment();
    var pos = 0;

    while (true) {
      special.lastIndex = pos;
      var m = special.exec(text);
      var skipped = m ? m.index - pos : text.length - pos;

      if (skipped) {
        var _txt = document.createTextNode(displayText.slice(pos, pos + skipped));

        if (_browser.ie && _browser.ie_version < 9) content.appendChild((0, _dom.elt)("span", [_txt]));else content.appendChild(_txt);
        builder.map.push(builder.pos, builder.pos + skipped, _txt);
        builder.col += skipped;
        builder.pos += skipped;
      }

      if (!m) break;
      pos += skipped + 1;
      var txt = void 0;

      if (m[0] == "\t") {
        var tabSize = builder.cm.options.tabSize,
            tabWidth = tabSize - builder.col % tabSize;
        txt = content.appendChild((0, _dom.elt)("span", (0, _misc.spaceStr)(tabWidth), "cm-tab"));
        txt.setAttribute("role", "presentation");
        txt.setAttribute("cm-text", "\t");
        builder.col += tabWidth;
      } else if (m[0] == "\r" || m[0] == "\n") {
        txt = content.appendChild((0, _dom.elt)("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
        txt.setAttribute("cm-text", m[0]);
        builder.col += 1;
      } else {
        txt = builder.cm.options.specialCharPlaceholder(m[0]);
        txt.setAttribute("cm-text", m[0]);
        if (_browser.ie && _browser.ie_version < 9) content.appendChild((0, _dom.elt)("span", [txt]));else content.appendChild(txt);
        builder.col += 1;
      }

      builder.map.push(builder.pos, builder.pos + 1, txt);
      builder.pos++;
    }
  }

  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;

  if (style || startStyle || endStyle || mustWrap || css) {
    var fullStyle = style || "";
    if (startStyle) fullStyle += startStyle;
    if (endStyle) fullStyle += endStyle;
    var token = (0, _dom.elt)("span", [content], fullStyle, css);

    if (attributes) {
      for (var attr in attributes) {
        if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") token.setAttribute(attr, attributes[attr]);
      }
    }

    return builder.content.appendChild(token);
  }

  builder.content.appendChild(content);
} // Change some spaces to NBSP to prevent the browser from collapsing
// trailing spaces at the end of a line when rendering text (issue #1362).


function splitSpaces(text, trailingBefore) {
  if (text.length > 1 && !/  /.test(text)) return text;
  var spaceBefore = trailingBefore,
      result = "";

  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i);
    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) ch = "\xA0";
    result += ch;
    spaceBefore = ch == " ";
  }

  return result;
} // Work around nonsense dimensions being reported for stretches of
// right-to-left text.


function buildTokenBadBidi(inner, order) {
  return function (builder, text, style, startStyle, endStyle, css, attributes) {
    style = style ? style + " cm-force-border" : "cm-force-border";
    var start = builder.pos,
        end = start + text.length;

    for (;;) {
      // Find the part that overlaps with the start of this text
      var part = void 0;

      for (var i = 0; i < order.length; i++) {
        part = order[i];
        if (part.to > start && part.from <= start) break;
      }

      if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, css, attributes);
      inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
      startStyle = null;
      text = text.slice(part.to - start);
      start = part.to;
    }
  };
}

function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
  var widget = !ignoreWidget && marker.widgetNode;
  if (widget) builder.map.push(builder.pos, builder.pos + size, widget);

  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
    if (!widget) widget = builder.content.appendChild(document.createElement("span"));
    widget.setAttribute("cm-marker", marker.id);
  }

  if (widget) {
    builder.cm.display.input.setUneditable(widget);
    builder.content.appendChild(widget);
  }

  builder.pos += size;
  builder.trailingSpace = false;
} // Outputs a number of spans to make up a line, taking highlighting
// and marked text into account.


function insertLineContent(line, builder, styles) {
  var spans = line.markedSpans,
      allText = line.text,
      at = 0;

  if (!spans) {
    for (var _i = 1; _i < styles.length; _i += 2) {
      builder.addToken(builder, allText.slice(at, at = styles[_i]), interpretTokenStyle(styles[_i + 1], builder.cm.options));
    }

    return;
  }

  var len = allText.length,
      pos = 0,
      i = 1,
      text = "",
      style,
      css;
  var nextChange = 0,
      spanStyle,
      spanEndStyle,
      spanStartStyle,
      collapsed,
      attributes;

  for (;;) {
    if (nextChange == pos) {
      // Update current marker set
      spanStyle = spanEndStyle = spanStartStyle = css = "";
      attributes = null;
      collapsed = null;
      nextChange = Infinity;
      var foundBookmarks = [],
          endStyles = void 0;

      for (var j = 0; j < spans.length; ++j) {
        var sp = spans[j],
            m = sp.marker;

        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
          foundBookmarks.push(m);
        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
            nextChange = sp.to;
            spanEndStyle = "";
          }

          if (m.className) spanStyle += " " + m.className;
          if (m.css) css = (css ? css + ";" : "") + m.css;
          if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
          if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to); // support for the old title property
          // https://github.com/codemirror/CodeMirror/pull/5673

          if (m.title) (attributes || (attributes = {})).title = m.title;

          if (m.attributes) {
            for (var attr in m.attributes) {
              (attributes || (attributes = {}))[attr] = m.attributes[attr];
            }
          }

          if (m.collapsed && (!collapsed || (0, _spans.compareCollapsedMarkers)(collapsed.marker, m) < 0)) collapsed = sp;
        } else if (sp.from > pos && nextChange > sp.from) {
          nextChange = sp.from;
        }
      }

      if (endStyles) for (var _j = 0; _j < endStyles.length; _j += 2) {
        if (endStyles[_j + 1] == nextChange) spanEndStyle += " " + endStyles[_j];
      }
      if (!collapsed || collapsed.from == pos) for (var _j2 = 0; _j2 < foundBookmarks.length; ++_j2) {
        buildCollapsedSpan(builder, 0, foundBookmarks[_j2]);
      }

      if (collapsed && (collapsed.from || 0) == pos) {
        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
        if (collapsed.to == null) return;
        if (collapsed.to == pos) collapsed = false;
      }
    }

    if (pos >= len) break;
    var upto = Math.min(len, nextChange);

    while (true) {
      if (text) {
        var end = pos + text.length;

        if (!collapsed) {
          var tokenText = end > upto ? text.slice(0, upto - pos) : text;
          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
        }

        if (end >= upto) {
          text = text.slice(upto - pos);
          pos = upto;
          break;
        }

        pos = end;
        spanStartStyle = "";
      }

      text = allText.slice(at, at = styles[i++]);
      style = interpretTokenStyle(styles[i++], builder.cm.options);
    }
  }
} // These objects are used to represent the visible (currently drawn)
// part of the document. A LineView may correspond to multiple
// logical lines, if those are connected by collapsed ranges.


function LineView(doc, line, lineN) {
  // The starting line
  this.line = line; // Continuing lines, if any

  this.rest = (0, _spans.visualLineContinued)(line); // Number of logical lines in this visual line

  this.size = this.rest ? (0, _utils_line.lineNo)((0, _misc.lst)(this.rest)) - lineN + 1 : 1;
  this.node = this.text = null;
  this.hidden = (0, _spans.lineIsHidden)(doc, line);
} // Create a range of LineView objects for the given lines.


function buildViewArray(cm, from, to) {
  var array = [],
      nextPos;

  for (var pos = from; pos < to; pos = nextPos) {
    var view = new LineView(cm.doc, (0, _utils_line.getLine)(cm.doc, pos), pos);
    nextPos = pos + view.size;
    array.push(view);
  }

  return array;
}