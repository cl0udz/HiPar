"use strict";

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.splice");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkedSpan = MarkedSpan;
exports.getMarkedSpanFor = getMarkedSpanFor;
exports.removeMarkedSpan = removeMarkedSpan;
exports.addMarkedSpan = addMarkedSpan;
exports.stretchSpansOverChange = stretchSpansOverChange;
exports.removeReadOnlyRanges = removeReadOnlyRanges;
exports.detachMarkedSpans = detachMarkedSpans;
exports.attachMarkedSpans = attachMarkedSpans;
exports.compareCollapsedMarkers = compareCollapsedMarkers;
exports.collapsedSpanAtStart = collapsedSpanAtStart;
exports.collapsedSpanAtEnd = collapsedSpanAtEnd;
exports.collapsedSpanAround = collapsedSpanAround;
exports.conflictingCollapsedRange = conflictingCollapsedRange;
exports.visualLine = visualLine;
exports.visualLineEnd = visualLineEnd;
exports.visualLineContinued = visualLineContinued;
exports.visualLineNo = visualLineNo;
exports.visualLineEndNo = visualLineEndNo;
exports.lineIsHidden = lineIsHidden;
exports.heightAtLine = heightAtLine;
exports.lineLength = lineLength;
exports.findMaxLine = findMaxLine;

var _misc = require("../util/misc.js");

var _pos = require("./pos.js");

var _saw_special_spans = require("./saw_special_spans.js");

var _utils_line = require("./utils_line.js");

function MarkedSpan(marker, from, to) {
  this.marker = marker;
  this.from = from;
  this.to = to;
} // Search an array of spans for a span matching the given marker.


function getMarkedSpanFor(spans, marker) {
  if (spans) for (var i = 0; i < spans.length; ++i) {
    var span = spans[i];
    if (span.marker == marker) return span;
  }
} // Remove a span from an array, returning undefined if no spans are
// left (we don't store arrays for lines without spans).


function removeMarkedSpan(spans, span) {
  var r;

  for (var i = 0; i < spans.length; ++i) {
    if (spans[i] != span) (r || (r = [])).push(spans[i]);
  }

  return r;
} // Add a span to a line.


function addMarkedSpan(line, span) {
  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
  span.marker.attachLine(line);
} // Used for the algorithm that adjusts markers for a change in the
// document. These functions cut an array of spans at a given
// character position, returning an array of remaining chunks (or
// undefined if nothing remains).


function markedSpansBefore(old, startCh, isInsert) {
  var nw;
  if (old) for (var i = 0; i < old.length; ++i) {
    var span = old[i],
        marker = span.marker;
    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);

    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
      (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
    }
  }
  return nw;
}

function markedSpansAfter(old, endCh, isInsert) {
  var nw;
  if (old) for (var i = 0; i < old.length; ++i) {
    var span = old[i],
        marker = span.marker;
    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);

    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
      (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
    }
  }
  return nw;
} // Given a change object, compute the new set of marker spans that
// cover the line in which the change took place. Removes spans
// entirely within the change, reconnects spans belonging to the
// same marker that appear on both sides of the change, and cuts off
// spans partially within the change. Returns an array of span
// arrays with one element for each line in (after) the change.


function stretchSpansOverChange(doc, change) {
  if (change.full) return null;
  var oldFirst = (0, _utils_line.isLine)(doc, change.from.line) && (0, _utils_line.getLine)(doc, change.from.line).markedSpans;
  var oldLast = (0, _utils_line.isLine)(doc, change.to.line) && (0, _utils_line.getLine)(doc, change.to.line).markedSpans;
  if (!oldFirst && !oldLast) return null;
  var startCh = change.from.ch,
      endCh = change.to.ch,
      isInsert = (0, _pos.cmp)(change.from, change.to) == 0; // Get the spans that 'stick out' on both sides

  var first = markedSpansBefore(oldFirst, startCh, isInsert);
  var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends

  var sameLine = change.text.length == 1,
      offset = (0, _misc.lst)(change.text).length + (sameLine ? startCh : 0);

  if (first) {
    // Fix up .to properties of first
    for (var i = 0; i < first.length; ++i) {
      var span = first[i];

      if (span.to == null) {
        var found = getMarkedSpanFor(last, span.marker);
        if (!found) span.to = startCh;else if (sameLine) span.to = found.to == null ? null : found.to + offset;
      }
    }
  }

  if (last) {
    // Fix up .from in last (or move them into first in case of sameLine)
    for (var _i = 0; _i < last.length; ++_i) {
      var _span = last[_i];
      if (_span.to != null) _span.to += offset;

      if (_span.from == null) {
        var _found = getMarkedSpanFor(first, _span.marker);

        if (!_found) {
          _span.from = offset;
          if (sameLine) (first || (first = [])).push(_span);
        }
      } else {
        _span.from += offset;
        if (sameLine) (first || (first = [])).push(_span);
      }
    }
  } // Make sure we didn't create any zero-length spans


  if (first) first = clearEmptySpans(first);
  if (last && last != first) last = clearEmptySpans(last);
  var newMarkers = [first];

  if (!sameLine) {
    // Fill gap with whole-line-spans
    var gap = change.text.length - 2,
        gapMarkers;
    if (gap > 0 && first) for (var _i2 = 0; _i2 < first.length; ++_i2) {
      if (first[_i2].to == null) (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[_i2].marker, null, null));
    }

    for (var _i3 = 0; _i3 < gap; ++_i3) {
      newMarkers.push(gapMarkers);
    }

    newMarkers.push(last);
  }

  return newMarkers;
} // Remove spans that are empty and don't have a clearWhenEmpty
// option of false.


function clearEmptySpans(spans) {
  for (var i = 0; i < spans.length; ++i) {
    var span = spans[i];
    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) spans.splice(i--, 1);
  }

  if (!spans.length) return null;
  return spans;
} // Used to 'clip' out readOnly ranges when making a change.


function removeReadOnlyRanges(doc, from, to) {
  var markers = null;
  doc.iter(from.line, to.line + 1, function (line) {
    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
      var mark = line.markedSpans[i].marker;
      if (mark.readOnly && (!markers || (0, _misc.indexOf)(markers, mark) == -1)) (markers || (markers = [])).push(mark);
    }
  });
  if (!markers) return null;
  var parts = [{
    from: from,
    to: to
  }];

  for (var i = 0; i < markers.length; ++i) {
    var mk = markers[i],
        m = mk.find(0);

    for (var j = 0; j < parts.length; ++j) {
      var p = parts[j];
      if ((0, _pos.cmp)(p.to, m.from) < 0 || (0, _pos.cmp)(p.from, m.to) > 0) continue;
      var newParts = [j, 1],
          dfrom = (0, _pos.cmp)(p.from, m.from),
          dto = (0, _pos.cmp)(p.to, m.to);
      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) newParts.push({
        from: p.from,
        to: m.from
      });
      if (dto > 0 || !mk.inclusiveRight && !dto) newParts.push({
        from: m.to,
        to: p.to
      });
      parts.splice.apply(parts, newParts);
      j += newParts.length - 3;
    }
  }

  return parts;
} // Connect or disconnect spans from a line.


function detachMarkedSpans(line) {
  var spans = line.markedSpans;
  if (!spans) return;

  for (var i = 0; i < spans.length; ++i) {
    spans[i].marker.detachLine(line);
  }

  line.markedSpans = null;
}

function attachMarkedSpans(line, spans) {
  if (!spans) return;

  for (var i = 0; i < spans.length; ++i) {
    spans[i].marker.attachLine(line);
  }

  line.markedSpans = spans;
} // Helpers used when computing which overlapping collapsed span
// counts as the larger one.


function extraLeft(marker) {
  return marker.inclusiveLeft ? -1 : 0;
}

function extraRight(marker) {
  return marker.inclusiveRight ? 1 : 0;
} // Returns a number indicating which of two overlapping collapsed
// spans is larger (and thus includes the other). Falls back to
// comparing ids when the spans cover exactly the same range.


function compareCollapsedMarkers(a, b) {
  var lenDiff = a.lines.length - b.lines.length;
  if (lenDiff != 0) return lenDiff;
  var aPos = a.find(),
      bPos = b.find();
  var fromCmp = (0, _pos.cmp)(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
  if (fromCmp) return -fromCmp;
  var toCmp = (0, _pos.cmp)(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
  if (toCmp) return toCmp;
  return b.id - a.id;
} // Find out whether a line ends or starts in a collapsed span. If
// so, return the marker for that span.


function collapsedSpanAtSide(line, start) {
  var sps = _saw_special_spans.sawCollapsedSpans && line.markedSpans,
      found;
  if (sps) for (var sp, i = 0; i < sps.length; ++i) {
    sp = sps[i];
    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) found = sp.marker;
  }
  return found;
}

function collapsedSpanAtStart(line) {
  return collapsedSpanAtSide(line, true);
}

function collapsedSpanAtEnd(line) {
  return collapsedSpanAtSide(line, false);
}

function collapsedSpanAround(line, ch) {
  var sps = _saw_special_spans.sawCollapsedSpans && line.markedSpans,
      found;
  if (sps) for (var i = 0; i < sps.length; ++i) {
    var sp = sps[i];
    if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) found = sp.marker;
  }
  return found;
} // Test whether there exists a collapsed span that partially
// overlaps (covers the start or end, but not both) of a new span.
// Such overlap is not allowed.


function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
  var line = (0, _utils_line.getLine)(doc, lineNo);
  var sps = _saw_special_spans.sawCollapsedSpans && line.markedSpans;
  if (sps) for (var i = 0; i < sps.length; ++i) {
    var sp = sps[i];
    if (!sp.marker.collapsed) continue;
    var found = sp.marker.find(0);
    var fromCmp = (0, _pos.cmp)(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
    var toCmp = (0, _pos.cmp)(found.to, to) || extraRight(sp.marker) - extraRight(marker);
    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? (0, _pos.cmp)(found.to, from) >= 0 : (0, _pos.cmp)(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? (0, _pos.cmp)(found.from, to) <= 0 : (0, _pos.cmp)(found.from, to) < 0)) return true;
  }
} // A visual line is a line as drawn on the screen. Folding, for
// example, can cause multiple logical lines to appear on the same
// visual line. This finds the start of the visual line that the
// given line is part of (usually that is the line itself).


function visualLine(line) {
  var merged;

  while (merged = collapsedSpanAtStart(line)) {
    line = merged.find(-1, true).line;
  }

  return line;
}

function visualLineEnd(line) {
  var merged;

  while (merged = collapsedSpanAtEnd(line)) {
    line = merged.find(1, true).line;
  }

  return line;
} // Returns an array of logical lines that continue the visual line
// started by the argument, or undefined if there are no such lines.


function visualLineContinued(line) {
  var merged, lines;

  while (merged = collapsedSpanAtEnd(line)) {
    line = merged.find(1, true).line;
    (lines || (lines = [])).push(line);
  }

  return lines;
} // Get the line number of the start of the visual line that the
// given line number is part of.


function visualLineNo(doc, lineN) {
  var line = (0, _utils_line.getLine)(doc, lineN),
      vis = visualLine(line);
  if (line == vis) return lineN;
  return (0, _utils_line.lineNo)(vis);
} // Get the line number of the start of the next visual line after
// the given line.


function visualLineEndNo(doc, lineN) {
  if (lineN > doc.lastLine()) return lineN;
  var line = (0, _utils_line.getLine)(doc, lineN),
      merged;
  if (!lineIsHidden(doc, line)) return lineN;

  while (merged = collapsedSpanAtEnd(line)) {
    line = merged.find(1, true).line;
  }

  return (0, _utils_line.lineNo)(line) + 1;
} // Compute whether a line is hidden. Lines count as hidden when they
// are part of a visual line that starts with another line, or when
// they are entirely covered by collapsed, non-widget span.


function lineIsHidden(doc, line) {
  var sps = _saw_special_spans.sawCollapsedSpans && line.markedSpans;
  if (sps) for (var sp, i = 0; i < sps.length; ++i) {
    sp = sps[i];
    if (!sp.marker.collapsed) continue;
    if (sp.from == null) return true;
    if (sp.marker.widgetNode) continue;
    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return true;
  }
}

function lineIsHiddenInner(doc, line, span) {
  if (span.to == null) {
    var end = span.marker.find(1, true);
    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
  }

  if (span.marker.inclusiveRight && span.to == line.text.length) return true;

  for (var sp, i = 0; i < line.markedSpans.length; ++i) {
    sp = line.markedSpans[i];
    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return true;
  }
} // Find the height above the given line.


function heightAtLine(lineObj) {
  lineObj = visualLine(lineObj);
  var h = 0,
      chunk = lineObj.parent;

  for (var i = 0; i < chunk.lines.length; ++i) {
    var line = chunk.lines[i];
    if (line == lineObj) break;else h += line.height;
  }

  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
    for (var _i4 = 0; _i4 < p.children.length; ++_i4) {
      var cur = p.children[_i4];
      if (cur == chunk) break;else h += cur.height;
    }
  }

  return h;
} // Compute the character length of a line, taking into account
// collapsed ranges (see markText) that might hide parts, and join
// other lines onto it.


function lineLength(line) {
  if (line.height == 0) return 0;
  var len = line.text.length,
      merged,
      cur = line;

  while (merged = collapsedSpanAtStart(cur)) {
    var found = merged.find(0, true);
    cur = found.from.line;
    len += found.from.ch - found.to.ch;
  }

  cur = line;

  while (merged = collapsedSpanAtEnd(cur)) {
    var _found2 = merged.find(0, true);

    len -= cur.text.length - _found2.from.ch;
    cur = _found2.to.line;
    len += cur.text.length - _found2.to.ch;
  }

  return len;
} // Find the longest line in the document.


function findMaxLine(cm) {
  var d = cm.display,
      doc = cm.doc;
  d.maxLine = (0, _utils_line.getLine)(doc, doc.first);
  d.maxLineLength = lineLength(d.maxLine);
  d.maxLineChanged = true;
  doc.iter(function (line) {
    var len = lineLength(line);

    if (len > d.maxLineLength) {
      d.maxLineLength = len;
      d.maxLine = line;
    }
  });
}