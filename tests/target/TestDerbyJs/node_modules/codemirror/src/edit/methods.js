"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof10(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof10 = function _typeof10(obj) { return typeof obj; }; } else { _typeof10 = function _typeof10(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof10(obj); }

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof9(obj) {
  if (typeof Symbol === "function" && _typeof10(Symbol.iterator) === "symbol") {
    _typeof9 = function _typeof9(obj) {
      return _typeof10(obj);
    };
  } else {
    _typeof9 = function _typeof9(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof10(obj);
    };
  }

  return _typeof9(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof8(obj) {
  if (typeof Symbol === "function" && _typeof9(Symbol.iterator) === "symbol") {
    _typeof8 = function _typeof8(obj) {
      return _typeof9(obj);
    };
  } else {
    _typeof8 = function _typeof8(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof9(obj);
    };
  }

  return _typeof8(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof7(obj) {
  if (typeof Symbol === "function" && _typeof8(Symbol.iterator) === "symbol") {
    _typeof7 = function _typeof7(obj) {
      return _typeof8(obj);
    };
  } else {
    _typeof7 = function _typeof7(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof8(obj);
    };
  }

  return _typeof7(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof6(obj) {
  if (typeof Symbol === "function" && _typeof7(Symbol.iterator) === "symbol") {
    _typeof6 = function _typeof6(obj) {
      return _typeof7(obj);
    };
  } else {
    _typeof6 = function _typeof6(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof7(obj);
    };
  }

  return _typeof6(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof5(obj) {
  if (typeof Symbol === "function" && _typeof6(Symbol.iterator) === "symbol") {
    _typeof5 = function _typeof5(obj) {
      return _typeof6(obj);
    };
  } else {
    _typeof5 = function _typeof5(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof6(obj);
    };
  }

  return _typeof5(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof4(obj) {
  if (typeof Symbol === "function" && _typeof5(Symbol.iterator) === "symbol") {
    _typeof4 = function _typeof4(obj) {
      return _typeof5(obj);
    };
  } else {
    _typeof4 = function _typeof4(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof5(obj);
    };
  }

  return _typeof4(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof3(obj) {
  if (typeof Symbol === "function" && _typeof4(Symbol.iterator) === "symbol") {
    _typeof3 = function _typeof3(obj) {
      return _typeof4(obj);
    };
  } else {
    _typeof3 = function _typeof3(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof4(obj);
    };
  }

  return _typeof3(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _deleteNearSelection = require("./deleteNearSelection.js");

var _commands = require("./commands.js");

var _document_data = require("../model/document_data.js");

var _dom = require("../util/dom.js");

var _event = require("../util/event.js");

var _highlight = require("../line/highlight.js");

var _indent = require("../input/indent.js");

var _input = require("../input/input.js");

var _key_events = require("./key_events.js");

var _mouse_events = require("./mouse_events.js");

var _keymap = require("../input/keymap.js");

var _movement = require("../input/movement.js");

var _operations = require("../display/operations.js");

var _pos = require("../line/pos.js");

var _position_measurement = require("../measurement/position_measurement.js");

var _selection = require("../model/selection.js");

var _selection_updates = require("../model/selection_updates.js");

var _scrolling = require("../display/scrolling.js");

var _spans = require("../line/spans.js");

var _update_display = require("../display/update_display.js");

var _misc = require("../util/misc.js");

var _operation_group = require("../util/operation_group.js");

var _utils_line = require("../line/utils_line.js");

var _view_tracking = require("../display/view_tracking.js");

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _default(CodeMirror) {
  var optionHandlers = CodeMirror.optionHandlers;
  var helpers = CodeMirror.helpers = {};
  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function focus() {
      window.focus();
      this.display.input.focus();
    },
    setOption: function setOption(option, value) {
      var options = this.options,
          old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option)) (0, _operations.operation)(this, optionHandlers[option])(this, value, old);
      (0, _event.signal)(this, "optionChange", this, option);
    },
    getOption: function getOption(option) {
      return this.options[option];
    },
    getDoc: function getDoc() {
      return this.doc;
    },
    addKeyMap: function addKeyMap(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"]((0, _keymap.getKeyMap)(map));
    },
    removeKeyMap: function removeKeyMap(map) {
      var maps = this.state.keyMaps;

      for (var i = 0; i < maps.length; ++i) {
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
      }
    },
    addOverlay: (0, _operations.methodOp)(function (spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      (0, _misc.insertSorted)(this.state.overlays, {
        mode: mode,
        modeSpec: spec,
        opaque: options && options.opaque,
        priority: options && options.priority || 0
      }, function (overlay) {
        return overlay.priority;
      });
      this.state.modeGen++;
      (0, _view_tracking.regChange)(this);
    }),
    removeOverlay: (0, _operations.methodOp)(function (spec) {
      var overlays = this.state.overlays;

      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;

        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          (0, _view_tracking.regChange)(this);
          return;
        }
      }
    }),
    indentLine: (0, _operations.methodOp)(function (n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";else dir = dir ? "add" : "subtract";
      }

      if ((0, _utils_line.isLine)(this.doc, n)) (0, _indent.indentLine)(this, n, dir, aggressive);
    }),
    indentSelection: (0, _operations.methodOp)(function (how) {
      var ranges = this.doc.sel.ranges,
          end = -1;

      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];

        if (!range.empty()) {
          var from = range.from(),
              to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;

          for (var j = start; j < end; ++j) {
            (0, _indent.indentLine)(this, j, how);
          }

          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) (0, _selection_updates.replaceOneSelection)(this.doc, i, new _selection.Range(from, newRanges[i].to()), _misc.sel_dontScroll);
        } else if (range.head.line > end) {
          (0, _indent.indentLine)(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) (0, _scrolling.ensureCursorVisible)(this);
        }
      }
    }),
    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function getTokenAt(pos, precise) {
      return (0, _highlight.takeToken)(this, pos, precise);
    },
    getLineTokens: function getLineTokens(line, precise) {
      return (0, _highlight.takeToken)(this, (0, _pos.Pos)(line), precise, true);
    },
    getTokenTypeAt: function getTokenTypeAt(pos) {
      pos = (0, _pos.clipPos)(this.doc, pos);
      var styles = (0, _highlight.getLineStyles)(this, (0, _utils_line.getLine)(this.doc, pos.line));
      var before = 0,
          after = (styles.length - 1) / 2,
          ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];else for (;;) {
        var mid = before + after >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;else if (styles[mid * 2 + 1] < ch) before = mid + 1;else {
          type = styles[mid * 2 + 2];
          break;
        }
      }
      var cut = type ? type.indexOf("overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },
    getModeAt: function getModeAt(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },
    getHelper: function getHelper(pos, type) {
      return this.getHelpers(pos, type)[0];
    },
    getHelpers: function getHelpers(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return found;
      var help = helpers[type],
          mode = this.getModeAt(pos);

      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }

      for (var _i = 0; _i < help._global.length; _i++) {
        var cur = help._global[_i];
        if (cur.pred(mode, this) && (0, _misc.indexOf)(found, cur.val) == -1) found.push(cur.val);
      }

      return found;
    },
    getStateAfter: function getStateAfter(line, precise) {
      var doc = this.doc;
      line = (0, _pos.clipLine)(doc, line == null ? doc.first + doc.size - 1 : line);
      return (0, _highlight.getContextBefore)(this, line + 1, precise).state;
    },
    cursorCoords: function cursorCoords(start, mode) {
      var pos,
          range = this.doc.sel.primary();
      if (start == null) pos = range.head;else if (_typeof(start) == "object") pos = (0, _pos.clipPos)(this.doc, start);else pos = start ? range.from() : range.to();
      return (0, _position_measurement.cursorCoords)(this, pos, mode || "page");
    },
    charCoords: function charCoords(pos, mode) {
      return (0, _position_measurement.charCoords)(this, (0, _pos.clipPos)(this.doc, pos), mode || "page");
    },
    coordsChar: function coordsChar(coords, mode) {
      coords = (0, _position_measurement.fromCoordSystem)(this, coords, mode || "page");
      return (0, _position_measurement.coordsChar)(this, coords.left, coords.top);
    },
    lineAtHeight: function lineAtHeight(height, mode) {
      height = (0, _position_measurement.fromCoordSystem)(this, {
        top: height,
        left: 0
      }, mode || "page").top;
      return (0, _utils_line.lineAtHeight)(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function heightAtLine(line, mode, includeWidgets) {
      var end = false,
          lineObj;

      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) line = this.doc.first;else if (line > last) {
          line = last;
          end = true;
        }
        lineObj = (0, _utils_line.getLine)(this.doc, line);
      } else {
        lineObj = line;
      }

      return (0, _position_measurement.intoCoordSystem)(this, lineObj, {
        top: 0,
        left: 0
      }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - (0, _spans.heightAtLine)(lineObj) : 0);
    },
    defaultTextHeight: function defaultTextHeight() {
      return (0, _position_measurement.textHeight)(this.display);
    },
    defaultCharWidth: function defaultCharWidth() {
      return (0, _position_measurement.charWidth)(this.display);
    },
    getViewport: function getViewport() {
      return {
        from: this.display.viewFrom,
        to: this.display.viewTo
      };
    },
    addWidget: function addWidget(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = (0, _position_measurement.cursorCoords)(this, (0, _pos.clipPos)(this.doc, pos));
      var top = pos.bottom,
          left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);

      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
            hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below

        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) top = pos.top - node.offsetHeight;else if (pos.bottom + node.offsetHeight <= vspace) top = pos.bottom;
        if (left + node.offsetWidth > hspace) left = hspace - node.offsetWidth;
      }

      node.style.top = top + "px";
      node.style.left = node.style.right = "";

      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }

      if (scroll) (0, _scrolling.scrollIntoView)(this, {
        left: left,
        top: top,
        right: left + node.offsetWidth,
        bottom: top + node.offsetHeight
      });
    },
    triggerOnKeyDown: (0, _operations.methodOp)(_key_events.onKeyDown),
    triggerOnKeyPress: (0, _operations.methodOp)(_key_events.onKeyPress),
    triggerOnKeyUp: _key_events.onKeyUp,
    triggerOnMouseDown: (0, _operations.methodOp)(_mouse_events.onMouseDown),
    execCommand: function execCommand(cmd) {
      if (_commands.commands.hasOwnProperty(cmd)) return _commands.commands[cmd].call(null, this);
    },
    triggerElectric: (0, _operations.methodOp)(function (text) {
      (0, _input.triggerElectric)(this, text);
    }),
    findPosH: function findPosH(from, amount, unit, visually) {
      var dir = 1;

      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }

      var cur = (0, _pos.clipPos)(this.doc, from);

      for (var i = 0; i < amount; ++i) {
        cur = _findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }

      return cur;
    },
    moveH: (0, _operations.methodOp)(function (dir, unit) {
      var _this = this;

      this.extendSelectionsBy(function (range) {
        if (_this.display.shift || _this.doc.extend || range.empty()) return _findPosH(_this.doc, range.head, dir, unit, _this.options.rtlMoveVisually);else return dir < 0 ? range.from() : range.to();
      }, _misc.sel_move);
    }),
    deleteH: (0, _operations.methodOp)(function (dir, unit) {
      var sel = this.doc.sel,
          doc = this.doc;
      if (sel.somethingSelected()) doc.replaceSelection("", null, "+delete");else (0, _deleteNearSelection.deleteNearSelection)(this, function (range) {
        var other = _findPosH(doc, range.head, dir, unit, false);

        return dir < 0 ? {
          from: other,
          to: range.head
        } : {
          from: range.head,
          to: other
        };
      });
    }),
    findPosV: function findPosV(from, amount, unit, goalColumn) {
      var dir = 1,
          x = goalColumn;

      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }

      var cur = (0, _pos.clipPos)(this.doc, from);

      for (var i = 0; i < amount; ++i) {
        var coords = (0, _position_measurement.cursorCoords)(this, cur, "div");
        if (x == null) x = coords.left;else coords.left = x;
        cur = _findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }

      return cur;
    },
    moveV: (0, _operations.methodOp)(function (dir, unit) {
      var _this2 = this;

      var doc = this.doc,
          goals = [];
      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function (range) {
        if (collapse) return dir < 0 ? range.from() : range.to();
        var headPos = (0, _position_measurement.cursorCoords)(_this2, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);

        var pos = _findPosV(_this2, headPos, dir, unit);

        if (unit == "page" && range == doc.sel.primary()) (0, _scrolling.addToScrollTop)(_this2, (0, _position_measurement.charCoords)(_this2, pos, "div").top - headPos.top);
        return pos;
      }, _misc.sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++) {
        doc.sel.ranges[i].goalColumn = goals[i];
      }
    }),
    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function findWordAt(pos) {
      var doc = this.doc,
          line = (0, _utils_line.getLine)(doc, pos.line).text;
      var start = pos.ch,
          end = pos.ch;

      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.sticky == "before" || end == line.length) && start) --start;else ++end;
        var startChar = line.charAt(start);
        var check = (0, _misc.isWordChar)(startChar, helper) ? function (ch) {
          return (0, _misc.isWordChar)(ch, helper);
        } : /\s/.test(startChar) ? function (ch) {
          return /\s/.test(ch);
        } : function (ch) {
          return !/\s/.test(ch) && !(0, _misc.isWordChar)(ch);
        };

        while (start > 0 && check(line.charAt(start - 1))) {
          --start;
        }

        while (end < line.length && check(line.charAt(end))) {
          ++end;
        }
      }

      return new _selection.Range((0, _pos.Pos)(pos.line, start), (0, _pos.Pos)(pos.line, end));
    },
    toggleOverwrite: function toggleOverwrite(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite) (0, _dom.addClass)(this.display.cursorDiv, "CodeMirror-overwrite");else (0, _dom.rmClass)(this.display.cursorDiv, "CodeMirror-overwrite");
      (0, _event.signal)(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function hasFocus() {
      return this.display.input.getField() == (0, _dom.activeElt)();
    },
    isReadOnly: function isReadOnly() {
      return !!(this.options.readOnly || this.doc.cantEdit);
    },
    scrollTo: (0, _operations.methodOp)(function (x, y) {
      (0, _scrolling.scrollToCoords)(this, x, y);
    }),
    getScrollInfo: function getScrollInfo() {
      var scroller = this.display.scroller;
      return {
        left: scroller.scrollLeft,
        top: scroller.scrollTop,
        height: scroller.scrollHeight - (0, _position_measurement.scrollGap)(this) - this.display.barHeight,
        width: scroller.scrollWidth - (0, _position_measurement.scrollGap)(this) - this.display.barWidth,
        clientHeight: (0, _position_measurement.displayHeight)(this),
        clientWidth: (0, _position_measurement.displayWidth)(this)
      };
    },
    scrollIntoView: (0, _operations.methodOp)(function (range, margin) {
      if (range == null) {
        range = {
          from: this.doc.sel.primary().head,
          to: null
        };
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {
          from: (0, _pos.Pos)(range, 0),
          to: null
        };
      } else if (range.from == null) {
        range = {
          from: range,
          to: null
        };
      }

      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        (0, _scrolling.scrollToRange)(this, range);
      } else {
        (0, _scrolling.scrollToCoordsRange)(this, range.from, range.to, range.margin);
      }
    }),
    setSize: (0, _operations.methodOp)(function (width, height) {
      var _this3 = this;

      var interpret = function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      };

      if (width != null) this.display.wrapper.style.width = interpret(width);
      if (height != null) this.display.wrapper.style.height = interpret(height);
      if (this.options.lineWrapping) (0, _position_measurement.clearLineMeasurementCache)(this);
      var lineNo = this.display.viewFrom;
      this.doc.iter(lineNo, this.display.viewTo, function (line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].noHScroll) {
            (0, _view_tracking.regLineChange)(_this3, lineNo, "widget");
            break;
          }
        }
        ++lineNo;
      });
      this.curOp.forceUpdate = true;
      (0, _event.signal)(this, "refresh", this);
    }),
    operation: function operation(f) {
      return (0, _operations.runInOp)(this, f);
    },
    startOperation: function startOperation() {
      return (0, _operations.startOperation)(this);
    },
    endOperation: function endOperation() {
      return (0, _operations.endOperation)(this);
    },
    refresh: (0, _operations.methodOp)(function () {
      var oldHeight = this.display.cachedTextHeight;
      (0, _view_tracking.regChange)(this);
      this.curOp.forceUpdate = true;
      (0, _position_measurement.clearCaches)(this);
      (0, _scrolling.scrollToCoords)(this, this.doc.scrollLeft, this.doc.scrollTop);
      (0, _update_display.updateGutterSpace)(this.display);
      if (oldHeight == null || Math.abs(oldHeight - (0, _position_measurement.textHeight)(this.display)) > .5) (0, _position_measurement.estimateLineHeights)(this);
      (0, _event.signal)(this, "refresh", this);
    }),
    swapDoc: (0, _operations.methodOp)(function (doc) {
      var old = this.doc;
      old.cm = null; // Cancel the current text selection if any (#5821)

      if (this.state.selectingText) this.state.selectingText();
      (0, _document_data.attachDoc)(this, doc);
      (0, _position_measurement.clearCaches)(this);
      this.display.input.reset();
      (0, _scrolling.scrollToCoords)(this, doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      (0, _operation_group.signalLater)(this, "swapDoc", this, old);
      return old;
    }),
    phrase: function phrase(phraseText) {
      var phrases = this.options.phrases;
      return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
    },
    getInputField: function getInputField() {
      return this.display.input.getField();
    },
    getWrapperElement: function getWrapperElement() {
      return this.display.wrapper;
    },
    getScrollerElement: function getScrollerElement() {
      return this.display.scroller;
    },
    getGutterElement: function getGutterElement() {
      return this.display.gutters;
    }
  };
  (0, _event.eventMixin)(CodeMirror);

  CodeMirror.registerHelper = function (type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {
      _global: []
    };
    helpers[type][name] = value;
  };

  CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);

    helpers[type]._global.push({
      pred: predicate,
      val: value
    });
  };
} // Used for horizontal relative motion. Dir is -1 or 1 (left or
// right), unit can be "char", "column" (like char, but doesn't
// cross line boundaries), "word" (across next word), or "group" (to
// the start of next group of word or non-word-non-whitespace
// chars). The visually param controls whether, in right-to-left
// text, direction 1 means to move towards the next index in the
// string, or towards the character to the right of the current
// position. The resulting position will have a hitSide=true
// property if it reached the end of the document.


function _findPosH(doc, pos, dir, unit, visually) {
  var oldPos = pos;
  var origDir = dir;
  var lineObj = (0, _utils_line.getLine)(doc, pos.line);
  var lineDir = visually && doc.cm && doc.cm.getOption("direction") == "rtl" ? -dir : dir;

  function findNextLine() {
    var l = pos.line + lineDir;
    if (l < doc.first || l >= doc.first + doc.size) return false;
    pos = new _pos.Pos(l, pos.ch, pos.sticky);
    return lineObj = (0, _utils_line.getLine)(doc, l);
  }

  function moveOnce(boundToLine) {
    var next;

    if (visually) {
      next = (0, _movement.moveVisually)(doc.cm, lineObj, pos, dir);
    } else {
      next = (0, _movement.moveLogically)(lineObj, pos, dir);
    }

    if (next == null) {
      if (!boundToLine && findNextLine()) pos = (0, _movement.endOfLine)(visually, doc.cm, lineObj, pos.line, lineDir);else return false;
    } else {
      pos = next;
    }

    return true;
  }

  if (unit == "char") {
    moveOnce();
  } else if (unit == "column") {
    moveOnce(true);
  } else if (unit == "word" || unit == "group") {
    var sawType = null,
        group = unit == "group";
    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");

    for (var first = true;; first = false) {
      if (dir < 0 && !moveOnce(!first)) break;
      var cur = lineObj.text.charAt(pos.ch) || "\n";
      var type = (0, _misc.isWordChar)(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
      if (group && !first && !type) type = "s";

      if (sawType && sawType != type) {
        if (dir < 0) {
          dir = 1;
          moveOnce();
          pos.sticky = "after";
        }

        break;
      }

      if (type) sawType = type;
      if (dir > 0 && !moveOnce(!first)) break;
    }
  }

  var result = (0, _selection_updates.skipAtomic)(doc, pos, oldPos, origDir, true);
  if ((0, _pos.equalCursorPos)(oldPos, result)) result.hitSide = true;
  return result;
} // For relative vertical movement. Dir may be -1 or 1. Unit can be
// "page" or "line". The resulting position will have a hitSide=true
// property if it reached the end of the document.


function _findPosV(cm, pos, dir, unit) {
  var doc = cm.doc,
      x = pos.left,
      y;

  if (unit == "page") {
    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
    var moveAmount = Math.max(pageSize - .5 * (0, _position_measurement.textHeight)(cm.display), 3);
    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
  } else if (unit == "line") {
    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
  }

  var target;

  for (;;) {
    target = (0, _position_measurement.coordsChar)(cm, x, y);
    if (!target.outside) break;

    if (dir < 0 ? y <= 0 : y >= doc.height) {
      target.hitSide = true;
      break;
    }

    y += dir * 5;
  }

  return target;
}