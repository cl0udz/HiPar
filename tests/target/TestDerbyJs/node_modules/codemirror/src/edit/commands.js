"use strict";

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.anchor");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commands = void 0;

var _deleteNearSelection = require("./deleteNearSelection.js");

var _operations = require("../display/operations.js");

var _scrolling = require("../display/scrolling.js");

var _movement = require("../input/movement.js");

var _pos = require("../line/pos.js");

var _spans = require("../line/spans.js");

var _utils_line = require("../line/utils_line.js");

var _selection = require("../model/selection.js");

var _selection_updates = require("../model/selection_updates.js");

var _misc = require("../util/misc.js");

var _bidi = require("../util/bidi.js");

var commands = {
  selectAll: _selection_updates.selectAll,
  singleSelection: function singleSelection(cm) {
    return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), _misc.sel_dontScroll);
  },
  killLine: function killLine(cm) {
    return (0, _deleteNearSelection.deleteNearSelection)(cm, function (range) {
      if (range.empty()) {
        var len = (0, _utils_line.getLine)(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine()) return {
          from: range.head,
          to: (0, _pos.Pos)(range.head.line + 1, 0)
        };else return {
          from: range.head,
          to: (0, _pos.Pos)(range.head.line, len)
        };
      } else {
        return {
          from: range.from(),
          to: range.to()
        };
      }
    });
  },
  deleteLine: function deleteLine(cm) {
    return (0, _deleteNearSelection.deleteNearSelection)(cm, function (range) {
      return {
        from: (0, _pos.Pos)(range.from().line, 0),
        to: (0, _pos.clipPos)(cm.doc, (0, _pos.Pos)(range.to().line + 1, 0))
      };
    });
  },
  delLineLeft: function delLineLeft(cm) {
    return (0, _deleteNearSelection.deleteNearSelection)(cm, function (range) {
      return {
        from: (0, _pos.Pos)(range.from().line, 0),
        to: range.from()
      };
    });
  },
  delWrappedLineLeft: function delWrappedLineLeft(cm) {
    return (0, _deleteNearSelection.deleteNearSelection)(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({
        left: 0,
        top: top
      }, "div");
      return {
        from: leftPos,
        to: range.from()
      };
    });
  },
  delWrappedLineRight: function delWrappedLineRight(cm) {
    return (0, _deleteNearSelection.deleteNearSelection)(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({
        left: cm.display.lineDiv.offsetWidth + 100,
        top: top
      }, "div");
      return {
        from: range.from(),
        to: rightPos
      };
    });
  },
  undo: function undo(cm) {
    return cm.undo();
  },
  redo: function redo(cm) {
    return cm.redo();
  },
  undoSelection: function undoSelection(cm) {
    return cm.undoSelection();
  },
  redoSelection: function redoSelection(cm) {
    return cm.redoSelection();
  },
  goDocStart: function goDocStart(cm) {
    return cm.extendSelection((0, _pos.Pos)(cm.firstLine(), 0));
  },
  goDocEnd: function goDocEnd(cm) {
    return cm.extendSelection((0, _pos.Pos)(cm.lastLine()));
  },
  goLineStart: function goLineStart(cm) {
    return cm.extendSelectionsBy(function (range) {
      return lineStart(cm, range.head.line);
    }, {
      origin: "+move",
      bias: 1
    });
  },
  goLineStartSmart: function goLineStartSmart(cm) {
    return cm.extendSelectionsBy(function (range) {
      return lineStartSmart(cm, range.head);
    }, {
      origin: "+move",
      bias: 1
    });
  },
  goLineEnd: function goLineEnd(cm) {
    return cm.extendSelectionsBy(function (range) {
      return lineEnd(cm, range.head.line);
    }, {
      origin: "+move",
      bias: -1
    });
  },
  goLineRight: function goLineRight(cm) {
    return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({
        left: cm.display.lineDiv.offsetWidth + 100,
        top: top
      }, "div");
    }, _misc.sel_move);
  },
  goLineLeft: function goLineLeft(cm) {
    return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({
        left: 0,
        top: top
      }, "div");
    }, _misc.sel_move);
  },
  goLineLeftSmart: function goLineLeftSmart(cm) {
    return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({
        left: 0,
        top: top
      }, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
      return pos;
    }, _misc.sel_move);
  },
  goLineUp: function goLineUp(cm) {
    return cm.moveV(-1, "line");
  },
  goLineDown: function goLineDown(cm) {
    return cm.moveV(1, "line");
  },
  goPageUp: function goPageUp(cm) {
    return cm.moveV(-1, "page");
  },
  goPageDown: function goPageDown(cm) {
    return cm.moveV(1, "page");
  },
  goCharLeft: function goCharLeft(cm) {
    return cm.moveH(-1, "char");
  },
  goCharRight: function goCharRight(cm) {
    return cm.moveH(1, "char");
  },
  goColumnLeft: function goColumnLeft(cm) {
    return cm.moveH(-1, "column");
  },
  goColumnRight: function goColumnRight(cm) {
    return cm.moveH(1, "column");
  },
  goWordLeft: function goWordLeft(cm) {
    return cm.moveH(-1, "word");
  },
  goGroupRight: function goGroupRight(cm) {
    return cm.moveH(1, "group");
  },
  goGroupLeft: function goGroupLeft(cm) {
    return cm.moveH(-1, "group");
  },
  goWordRight: function goWordRight(cm) {
    return cm.moveH(1, "word");
  },
  delCharBefore: function delCharBefore(cm) {
    return cm.deleteH(-1, "char");
  },
  delCharAfter: function delCharAfter(cm) {
    return cm.deleteH(1, "char");
  },
  delWordBefore: function delWordBefore(cm) {
    return cm.deleteH(-1, "word");
  },
  delWordAfter: function delWordAfter(cm) {
    return cm.deleteH(1, "word");
  },
  delGroupBefore: function delGroupBefore(cm) {
    return cm.deleteH(-1, "group");
  },
  delGroupAfter: function delGroupAfter(cm) {
    return cm.deleteH(1, "group");
  },
  indentAuto: function indentAuto(cm) {
    return cm.indentSelection("smart");
  },
  indentMore: function indentMore(cm) {
    return cm.indentSelection("add");
  },
  indentLess: function indentLess(cm) {
    return cm.indentSelection("subtract");
  },
  insertTab: function insertTab(cm) {
    return cm.replaceSelection("\t");
  },
  insertSoftTab: function insertSoftTab(cm) {
    var spaces = [],
        ranges = cm.listSelections(),
        tabSize = cm.options.tabSize;

    for (var i = 0; i < ranges.length; i++) {
      var pos = ranges[i].from();
      var col = (0, _misc.countColumn)(cm.getLine(pos.line), pos.ch, tabSize);
      spaces.push((0, _misc.spaceStr)(tabSize - col % tabSize));
    }

    cm.replaceSelections(spaces);
  },
  defaultTab: function defaultTab(cm) {
    if (cm.somethingSelected()) cm.indentSelection("add");else cm.execCommand("insertTab");
  },
  // Swap the two chars left and right of each selection's head.
  // Move cursor behind the two swapped characters afterwards.
  //
  // Doesn't consider line feeds a character.
  // Doesn't scan more than one line above to find a character.
  // Doesn't do anything on an empty line.
  // Doesn't do anything with non-empty selections.
  transposeChars: function transposeChars(cm) {
    return (0, _operations.runInOp)(cm, function () {
      var ranges = cm.listSelections(),
          newSel = [];

      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) continue;
        var cur = ranges[i].head,
            line = (0, _utils_line.getLine)(cm.doc, cur.line).text;

        if (line) {
          if (cur.ch == line.length) cur = new _pos.Pos(cur.line, cur.ch - 1);

          if (cur.ch > 0) {
            cur = new _pos.Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), (0, _pos.Pos)(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = (0, _utils_line.getLine)(cm.doc, cur.line - 1).text;

            if (prev) {
              cur = new _pos.Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), (0, _pos.Pos)(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }

        newSel.push(new _selection.Range(cur, cur));
      }

      cm.setSelections(newSel);
    });
  },
  newlineAndIndent: function newlineAndIndent(cm) {
    return (0, _operations.runInOp)(cm, function () {
      var sels = cm.listSelections();

      for (var i = sels.length - 1; i >= 0; i--) {
        cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
      }

      sels = cm.listSelections();

      for (var _i = 0; _i < sels.length; _i++) {
        cm.indentLine(sels[_i].from().line, null, true);
      }

      (0, _scrolling.ensureCursorVisible)(cm);
    });
  },
  openLine: function openLine(cm) {
    return cm.replaceSelection("\n", "start");
  },
  toggleOverwrite: function toggleOverwrite(cm) {
    return cm.toggleOverwrite();
  }
};
exports.commands = commands;

function lineStart(cm, lineN) {
  var line = (0, _utils_line.getLine)(cm.doc, lineN);
  var visual = (0, _spans.visualLine)(line);
  if (visual != line) lineN = (0, _utils_line.lineNo)(visual);
  return (0, _movement.endOfLine)(true, cm, visual, lineN, 1);
}

function lineEnd(cm, lineN) {
  var line = (0, _utils_line.getLine)(cm.doc, lineN);
  var visual = (0, _spans.visualLineEnd)(line);
  if (visual != line) lineN = (0, _utils_line.lineNo)(visual);
  return (0, _movement.endOfLine)(true, cm, line, lineN, -1);
}

function lineStartSmart(cm, pos) {
  var start = lineStart(cm, pos.line);
  var line = (0, _utils_line.getLine)(cm.doc, start.line);
  var order = (0, _bidi.getOrder)(line, cm.doc.direction);

  if (!order || order[0].level == 0) {
    var firstNonWS = Math.max(0, line.text.search(/\S/));
    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
    return (0, _pos.Pos)(start.line, inWS ? 0 : firstNonWS, start.sticky);
  }

  return start;
}