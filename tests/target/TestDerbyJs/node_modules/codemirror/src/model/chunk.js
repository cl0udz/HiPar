"use strict";

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.splice");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafChunk = LeafChunk;
exports.BranchChunk = BranchChunk;

var _line_data = require("../line/line_data.js");

var _misc = require("../util/misc.js");

var _operation_group = require("../util/operation_group.js");

function LeafChunk(lines) {
  this.lines = lines;
  this.parent = null;
  var height = 0;

  for (var i = 0; i < lines.length; ++i) {
    lines[i].parent = this;
    height += lines[i].height;
  }

  this.height = height;
}

LeafChunk.prototype = {
  chunkSize: function chunkSize() {
    return this.lines.length;
  },
  // Remove the n lines at offset 'at'.
  removeInner: function removeInner(at, n) {
    for (var i = at, e = at + n; i < e; ++i) {
      var line = this.lines[i];
      this.height -= line.height;
      (0, _line_data.cleanUpLine)(line);
      (0, _operation_group.signalLater)(line, "delete");
    }

    this.lines.splice(at, n);
  },
  // Helper used to collapse a small branch into a single leaf.
  collapse: function collapse(lines) {
    lines.push.apply(lines, this.lines);
  },
  // Insert the given array of lines at offset 'at', count them as
  // having the given height.
  insertInner: function insertInner(at, lines, height) {
    this.height += height;
    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));

    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this;
    }
  },
  // Used to iterate over a part of the tree.
  iterN: function iterN(at, n, op) {
    for (var e = at + n; at < e; ++at) {
      if (op(this.lines[at])) return true;
    }
  }
};

function BranchChunk(children) {
  this.children = children;
  var size = 0,
      height = 0;

  for (var i = 0; i < children.length; ++i) {
    var ch = children[i];
    size += ch.chunkSize();
    height += ch.height;
    ch.parent = this;
  }

  this.size = size;
  this.height = height;
  this.parent = null;
}

BranchChunk.prototype = {
  chunkSize: function chunkSize() {
    return this.size;
  },
  removeInner: function removeInner(at, n) {
    this.size -= n;

    for (var i = 0; i < this.children.length; ++i) {
      var child = this.children[i],
          sz = child.chunkSize();

      if (at < sz) {
        var rm = Math.min(n, sz - at),
            oldHeight = child.height;
        child.removeInner(at, rm);
        this.height -= oldHeight - child.height;

        if (sz == rm) {
          this.children.splice(i--, 1);
          child.parent = null;
        }

        if ((n -= rm) == 0) break;
        at = 0;
      } else at -= sz;
    } // If the result is smaller than 25 lines, ensure that it is a
    // single leaf node.


    if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
      var lines = [];
      this.collapse(lines);
      this.children = [new LeafChunk(lines)];
      this.children[0].parent = this;
    }
  },
  collapse: function collapse(lines) {
    for (var i = 0; i < this.children.length; ++i) {
      this.children[i].collapse(lines);
    }
  },
  insertInner: function insertInner(at, lines, height) {
    this.size += lines.length;
    this.height += height;

    for (var i = 0; i < this.children.length; ++i) {
      var child = this.children[i],
          sz = child.chunkSize();

      if (at <= sz) {
        child.insertInner(at, lines, height);

        if (child.lines && child.lines.length > 50) {
          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
          var remaining = child.lines.length % 25 + 25;

          for (var pos = remaining; pos < child.lines.length;) {
            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
            child.height -= leaf.height;
            this.children.splice(++i, 0, leaf);
            leaf.parent = this;
          }

          child.lines = child.lines.slice(0, remaining);
          this.maybeSpill();
        }

        break;
      }

      at -= sz;
    }
  },
  // When a node has grown, check whether it should be split.
  maybeSpill: function maybeSpill() {
    if (this.children.length <= 10) return;
    var me = this;

    do {
      var spilled = me.children.splice(me.children.length - 5, 5);
      var sibling = new BranchChunk(spilled);

      if (!me.parent) {
        // Become the parent node
        var copy = new BranchChunk(me.children);
        copy.parent = me;
        me.children = [copy, sibling];
        me = copy;
      } else {
        me.size -= sibling.size;
        me.height -= sibling.height;
        var myIndex = (0, _misc.indexOf)(me.parent.children, me);
        me.parent.children.splice(myIndex + 1, 0, sibling);
      }

      sibling.parent = me.parent;
    } while (me.children.length > 10);

    me.parent.maybeSpill();
  },
  iterN: function iterN(at, n, op) {
    for (var i = 0; i < this.children.length; ++i) {
      var child = this.children[i],
          sz = child.chunkSize();

      if (at < sz) {
        var used = Math.min(n, sz - at);
        if (child.iterN(at, used, op)) return true;
        if ((n -= used) == 0) break;
        at = 0;
      } else at -= sz;
    }
  }
};