"use strict";

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.slice");

require("core-js/modules/web.timers");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pushOperation = pushOperation;
exports.finishOperation = finishOperation;
exports.signalLater = signalLater;

var _event = require("./event.js");

var operationGroup = null;

function pushOperation(op) {
  if (operationGroup) {
    operationGroup.ops.push(op);
  } else {
    op.ownsGroup = operationGroup = {
      ops: [op],
      delayedCallbacks: []
    };
  }
}

function fireCallbacksForOps(group) {
  // Calls delayed callbacks and cursorActivity handlers until no
  // new ones appear
  var callbacks = group.delayedCallbacks,
      i = 0;

  do {
    for (; i < callbacks.length; i++) {
      callbacks[i].call(null);
    }

    for (var j = 0; j < group.ops.length; j++) {
      var op = group.ops[j];
      if (op.cursorActivityHandlers) while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
        op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
      }
    }
  } while (i < callbacks.length);
}

function finishOperation(op, endCb) {
  var group = op.ownsGroup;
  if (!group) return;

  try {
    fireCallbacksForOps(group);
  } finally {
    operationGroup = null;
    endCb(group);
  }
}

var orphanDelayedCallbacks = null; // Often, we want to signal events at a point where we are in the
// middle of some work, but don't want the handler to start calling
// other methods on the editor, which might be in an inconsistent
// state or simply not expect any other events to happen.
// signalLater looks whether there are any handlers, and schedules
// them to be executed when the last operation ends, or, if no
// operation is active, when a timeout fires.

function signalLater(emitter, type
/*, values...*/
) {
  var arr = (0, _event.getHandlers)(emitter, type);
  if (!arr.length) return;
  var args = Array.prototype.slice.call(arguments, 2),
      list;

  if (operationGroup) {
    list = operationGroup.delayedCallbacks;
  } else if (orphanDelayedCallbacks) {
    list = orphanDelayedCallbacks;
  } else {
    list = orphanDelayedCallbacks = [];
    setTimeout(fireOrphanDelayed, 0);
  }

  var _loop = function _loop(i) {
    list.push(function () {
      return arr[i].apply(null, args);
    });
  };

  for (var i = 0; i < arr.length; ++i) {
    _loop(i);
  }
}

function fireOrphanDelayed() {
  var delayed = orphanDelayedCallbacks;
  orphanDelayedCallbacks = null;

  for (var i = 0; i < delayed.length; ++i) {
    delayed[i]();
  }
}