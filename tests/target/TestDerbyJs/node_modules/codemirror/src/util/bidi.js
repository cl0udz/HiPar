"use strict";

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iterateBidiSections = iterateBidiSections;
exports.getBidiPartAt = getBidiPartAt;
exports.getOrder = getOrder;
exports.bidiOther = void 0;

var _misc = require("./misc.js");

function iterateBidiSections(order, from, to, f) {
  if (!order) return f(from, to, "ltr", 0);
  var found = false;

  for (var i = 0; i < order.length; ++i) {
    var part = order[i];

    if (part.from < to && part.to > from || from == to && part.to == from) {
      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
      found = true;
    }
  }

  if (!found) f(from, to, "ltr");
}

var bidiOther = null;
exports.bidiOther = bidiOther;

function getBidiPartAt(order, ch, sticky) {
  var found;
  exports.bidiOther = bidiOther = null;

  for (var i = 0; i < order.length; ++i) {
    var cur = order[i];
    if (cur.from < ch && cur.to > ch) return i;

    if (cur.to == ch) {
      if (cur.from != cur.to && sticky == "before") found = i;else exports.bidiOther = bidiOther = i;
    }

    if (cur.from == ch) {
      if (cur.from != cur.to && sticky != "before") found = i;else exports.bidiOther = bidiOther = i;
    }
  }

  return found != null ? found : bidiOther;
} // Bidirectional ordering algorithm
// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
// that this (partially) implements.
// One-char codes used for character types:
// L (L):   Left-to-Right
// R (R):   Right-to-Left
// r (AL):  Right-to-Left Arabic
// 1 (EN):  European Number
// + (ES):  European Number Separator
// % (ET):  European Number Terminator
// n (AN):  Arabic Number
// , (CS):  Common Number Separator
// m (NSM): Non-Spacing Mark
// b (BN):  Boundary Neutral
// s (B):   Paragraph Separator
// t (S):   Segment Separator
// w (WS):  Whitespace
// N (ON):  Other Neutrals
// Returns null if characters are ordered as they appear
// (left-to-right), or an array of sections ({from, to, level}
// objects) in the order in which they occur visually.


var bidiOrdering = function () {
  // Character types for codepoints 0 to 0xff
  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"; // Character types for codepoints 0x600 to 0x6f9

  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";

  function charType(code) {
    if (code <= 0xf7) return lowTypes.charAt(code);else if (0x590 <= code && code <= 0x5f4) return "R";else if (0x600 <= code && code <= 0x6f9) return arabicTypes.charAt(code - 0x600);else if (0x6ee <= code && code <= 0x8ac) return "r";else if (0x2000 <= code && code <= 0x200b) return "w";else if (code == 0x200c) return "b";else return "L";
  }

  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  var isNeutral = /[stwN]/,
      isStrong = /[LRr]/,
      countsAsLeft = /[Lb1n]/,
      countsAsNum = /[1n]/;

  function BidiSpan(level, from, to) {
    this.level = level;
    this.from = from;
    this.to = to;
  }

  return function (str, direction) {
    var outerType = direction == "ltr" ? "L" : "R";
    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) return false;
    var len = str.length,
        types = [];

    for (var i = 0; i < len; ++i) {
      types.push(charType(str.charCodeAt(i)));
    } // W1. Examine each non-spacing mark (NSM) in the level run, and
    // change the type of the NSM to the type of the previous
    // character. If the NSM is at the start of the level run, it will
    // get the type of sor.


    for (var _i = 0, prev = outerType; _i < len; ++_i) {
      var type = types[_i];
      if (type == "m") types[_i] = prev;else prev = type;
    } // W2. Search backwards from each instance of a European number
    // until the first strong type (R, L, AL, or sor) is found. If an
    // AL is found, change the type of the European number to Arabic
    // number.
    // W3. Change all ALs to R.


    for (var _i2 = 0, cur = outerType; _i2 < len; ++_i2) {
      var _type = types[_i2];
      if (_type == "1" && cur == "r") types[_i2] = "n";else if (isStrong.test(_type)) {
        cur = _type;
        if (_type == "r") types[_i2] = "R";
      }
    } // W4. A single European separator between two European numbers
    // changes to a European number. A single common separator between
    // two numbers of the same type changes to that type.


    for (var _i3 = 1, _prev = types[0]; _i3 < len - 1; ++_i3) {
      var _type2 = types[_i3];
      if (_type2 == "+" && _prev == "1" && types[_i3 + 1] == "1") types[_i3] = "1";else if (_type2 == "," && _prev == types[_i3 + 1] && (_prev == "1" || _prev == "n")) types[_i3] = _prev;
      _prev = _type2;
    } // W5. A sequence of European terminators adjacent to European
    // numbers changes to all European numbers.
    // W6. Otherwise, separators and terminators change to Other
    // Neutral.


    for (var _i4 = 0; _i4 < len; ++_i4) {
      var _type3 = types[_i4];
      if (_type3 == ",") types[_i4] = "N";else if (_type3 == "%") {
        var end = void 0;

        for (end = _i4 + 1; end < len && types[end] == "%"; ++end) {}

        var replace = _i4 && types[_i4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";

        for (var j = _i4; j < end; ++j) {
          types[j] = replace;
        }

        _i4 = end - 1;
      }
    } // W7. Search backwards from each instance of a European number
    // until the first strong type (R, L, or sor) is found. If an L is
    // found, then change the type of the European number to L.


    for (var _i5 = 0, _cur = outerType; _i5 < len; ++_i5) {
      var _type4 = types[_i5];
      if (_cur == "L" && _type4 == "1") types[_i5] = "L";else if (isStrong.test(_type4)) _cur = _type4;
    } // N1. A sequence of neutrals takes the direction of the
    // surrounding strong text if the text on both sides has the same
    // direction. European and Arabic numbers act as if they were R in
    // terms of their influence on neutrals. Start-of-level-run (sor)
    // and end-of-level-run (eor) are used at level run boundaries.
    // N2. Any remaining neutrals take the embedding direction.


    for (var _i6 = 0; _i6 < len; ++_i6) {
      if (isNeutral.test(types[_i6])) {
        var _end = void 0;

        for (_end = _i6 + 1; _end < len && isNeutral.test(types[_end]); ++_end) {}

        var before = (_i6 ? types[_i6 - 1] : outerType) == "L";
        var after = (_end < len ? types[_end] : outerType) == "L";

        var _replace = before == after ? before ? "L" : "R" : outerType;

        for (var _j = _i6; _j < _end; ++_j) {
          types[_j] = _replace;
        }

        _i6 = _end - 1;
      }
    } // Here we depart from the documented algorithm, in order to avoid
    // building up an actual levels array. Since there are only three
    // levels (0, 1, 2) in an implementation that doesn't take
    // explicit embedding into account, we can build up the order on
    // the fly, without following the level-based algorithm.


    var order = [],
        m;

    for (var _i7 = 0; _i7 < len;) {
      if (countsAsLeft.test(types[_i7])) {
        var start = _i7;

        for (++_i7; _i7 < len && countsAsLeft.test(types[_i7]); ++_i7) {}

        order.push(new BidiSpan(0, start, _i7));
      } else {
        var pos = _i7,
            at = order.length;

        for (++_i7; _i7 < len && types[_i7] != "L"; ++_i7) {}

        for (var _j2 = pos; _j2 < _i7;) {
          if (countsAsNum.test(types[_j2])) {
            if (pos < _j2) order.splice(at, 0, new BidiSpan(1, pos, _j2));
            var nstart = _j2;

            for (++_j2; _j2 < _i7 && countsAsNum.test(types[_j2]); ++_j2) {}

            order.splice(at, 0, new BidiSpan(2, nstart, _j2));
            pos = _j2;
          } else ++_j2;
        }

        if (pos < _i7) order.splice(at, 0, new BidiSpan(1, pos, _i7));
      }
    }

    if (direction == "ltr") {
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }

      if ((0, _misc.lst)(order).level == 1 && (m = str.match(/\s+$/))) {
        (0, _misc.lst)(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
    }

    return direction == "rtl" ? order.reverse() : order;
  };
}(); // Get the bidi ordering for the given line (and cache it). Returns
// false for lines that are fully left-to-right, and an array of
// BidiSpan objects otherwise.


function getOrder(line, direction) {
  var order = line.order;
  if (order == null) order = line.order = bidiOrdering(line.text, direction);
  return order;
}