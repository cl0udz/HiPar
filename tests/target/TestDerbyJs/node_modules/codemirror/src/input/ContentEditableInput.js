"use strict";

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.timers");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _operations = require("../display/operations.js");

var _selection = require("../display/selection.js");

var _view_tracking = require("../display/view_tracking.js");

var _input = require("./input.js");

var _pos = require("../line/pos.js");

var _utils_line = require("../line/utils_line.js");

var _position_measurement = require("../measurement/position_measurement.js");

var _changes = require("../model/changes.js");

var _selection2 = require("../model/selection.js");

var _selection_updates = require("../model/selection_updates.js");

var _bidi = require("../util/bidi.js");

var _browser = require("../util/browser.js");

var _dom = require("../util/dom.js");

var _event = require("../util/event.js");

var _misc = require("../util/misc.js");

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var ContentEditableInput =
/*#__PURE__*/
function () {
  function ContentEditableInput(cm) {
    _classCallCheck(this, ContentEditableInput);

    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new _misc.Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  }

  _createClass(ContentEditableInput, [{
    key: "init",
    value: function init(display) {
      var _this = this;

      var input = this,
          cm = input.cm;
      var div = input.div = display.lineDiv;
      (0, _input.disableBrowserMagic)(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
      (0, _event.on)(div, "paste", function (e) {
        if ((0, _event.signalDOMEvent)(cm, e) || (0, _input.handlePaste)(e, cm)) return; // IE doesn't fire input events, so we schedule a read for the pasted content in this way

        if (_browser.ie_version <= 11) setTimeout((0, _operations.operation)(cm, function () {
          return _this.updateFromDOM();
        }), 20);
      });
      (0, _event.on)(div, "compositionstart", function (e) {
        _this.composing = {
          data: e.data,
          done: false
        };
      });
      (0, _event.on)(div, "compositionupdate", function (e) {
        if (!_this.composing) _this.composing = {
          data: e.data,
          done: false
        };
      });
      (0, _event.on)(div, "compositionend", function (e) {
        if (_this.composing) {
          if (e.data != _this.composing.data) _this.readFromDOMSoon();
          _this.composing.done = true;
        }
      });
      (0, _event.on)(div, "touchstart", function () {
        return input.forceCompositionEnd();
      });
      (0, _event.on)(div, "input", function () {
        if (!_this.composing) _this.readFromDOMSoon();
      });

      function onCopyCut(e) {
        if ((0, _event.signalDOMEvent)(cm, e)) return;

        if (cm.somethingSelected()) {
          (0, _input.setLastCopied)({
            lineWise: false,
            text: cm.getSelections()
          });
          if (e.type == "cut") cm.replaceSelection("", null, "cut");
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = (0, _input.copyableRanges)(cm);
          (0, _input.setLastCopied)({
            lineWise: true,
            text: ranges.text
          });

          if (e.type == "cut") {
            cm.operation(function () {
              cm.setSelections(ranges.ranges, 0, _misc.sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }

        if (e.clipboardData) {
          e.clipboardData.clearData();

          var content = _input.lastCopied.text.join("\n"); // iOS exposes the clipboard API, but seems to discard content inserted into it


          e.clipboardData.setData("Text", content);

          if (e.clipboardData.getData("Text") == content) {
            e.preventDefault();
            return;
          }
        } // Old-fashioned briefly-focus-a-textarea hack


        var kludge = (0, _input.hiddenTextarea)(),
            te = kludge.firstChild;
        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
        te.value = _input.lastCopied.text.join("\n");
        var hadFocus = document.activeElement;
        (0, _dom.selectInput)(te);
        setTimeout(function () {
          cm.display.lineSpace.removeChild(kludge);
          hadFocus.focus();
          if (hadFocus == div) input.showPrimarySelection();
        }, 50);
      }

      (0, _event.on)(div, "copy", onCopyCut);
      (0, _event.on)(div, "cut", onCopyCut);
    }
  }, {
    key: "prepareSelection",
    value: function prepareSelection() {
      var result = (0, _selection.prepareSelection)(this.cm, false);
      result.focus = this.cm.state.focused;
      return result;
    }
  }, {
    key: "showSelection",
    value: function showSelection(info, takeFocus) {
      if (!info || !this.cm.display.view.length) return;
      if (info.focus || takeFocus) this.showPrimarySelection();
      this.showMultipleSelections(info);
    }
  }, {
    key: "getSelection",
    value: function getSelection() {
      return this.cm.display.wrapper.ownerDocument.getSelection();
    }
  }, {
    key: "showPrimarySelection",
    value: function showPrimarySelection() {
      var sel = this.getSelection(),
          cm = this.cm,
          prim = cm.doc.sel.primary();
      var from = prim.from(),
          to = prim.to();

      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
        sel.removeAllRanges();
        return;
      }

      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && (0, _pos.cmp)((0, _pos.minPos)(curAnchor, curFocus), from) == 0 && (0, _pos.cmp)((0, _pos.maxPos)(curAnchor, curFocus), to) == 0) return;
      var view = cm.display.view;
      var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
        node: view[0].measure.map[2],
        offset: 0
      };
      var end = to.line < cm.display.viewTo && posToDOM(cm, to);

      if (!end) {
        var measure = view[view.length - 1].measure;
        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {
          node: map[map.length - 1],
          offset: map[map.length - 2] - map[map.length - 3]
        };
      }

      if (!start || !end) {
        sel.removeAllRanges();
        return;
      }

      var old = sel.rangeCount && sel.getRangeAt(0),
          rng;

      try {
        rng = (0, _dom.range)(start.node, start.offset, end.offset, end.node);
      } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible


      if (rng) {
        if (!_browser.gecko && cm.state.focused) {
          sel.collapse(start.node, start.offset);

          if (!rng.collapsed) {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }

        if (old && sel.anchorNode == null) sel.addRange(old);else if (_browser.gecko) this.startGracePeriod();
      }

      this.rememberSelection();
    }
  }, {
    key: "startGracePeriod",
    value: function startGracePeriod() {
      var _this2 = this;

      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function () {
        _this2.gracePeriod = false;
        if (_this2.selectionChanged()) _this2.cm.operation(function () {
          return _this2.cm.curOp.selectionChanged = true;
        });
      }, 20);
    }
  }, {
    key: "showMultipleSelections",
    value: function showMultipleSelections(info) {
      (0, _dom.removeChildrenAndAdd)(this.cm.display.cursorDiv, info.cursors);
      (0, _dom.removeChildrenAndAdd)(this.cm.display.selectionDiv, info.selection);
    }
  }, {
    key: "rememberSelection",
    value: function rememberSelection() {
      var sel = this.getSelection();
      this.lastAnchorNode = sel.anchorNode;
      this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode;
      this.lastFocusOffset = sel.focusOffset;
    }
  }, {
    key: "selectionInEditor",
    value: function selectionInEditor() {
      var sel = this.getSelection();
      if (!sel.rangeCount) return false;
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return (0, _dom.contains)(this.div, node);
    }
  }, {
    key: "focus",
    value: function focus() {
      if (this.cm.options.readOnly != "nocursor") {
        if (!this.selectionInEditor()) this.showSelection(this.prepareSelection(), true);
        this.div.focus();
      }
    }
  }, {
    key: "blur",
    value: function blur() {
      this.div.blur();
    }
  }, {
    key: "getField",
    value: function getField() {
      return this.div;
    }
  }, {
    key: "supportsTouch",
    value: function supportsTouch() {
      return true;
    }
  }, {
    key: "receivedFocus",
    value: function receivedFocus() {
      var input = this;
      if (this.selectionInEditor()) this.pollSelection();else (0, _operations.runInOp)(this.cm, function () {
        return input.cm.curOp.selectionChanged = true;
      });

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }

      this.polling.set(this.cm.options.pollInterval, poll);
    }
  }, {
    key: "selectionChanged",
    value: function selectionChanged() {
      var sel = this.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    }
  }, {
    key: "pollSelection",
    value: function pollSelection() {
      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) return;
      var sel = this.getSelection(),
          cm = this.cm; // On Android Chrome (version 56, at least), backspacing into an
      // uneditable block element will put the cursor in that element,
      // and then, because it's not editable, hide the virtual keyboard.
      // Because Android doesn't allow us to actually detect backspace
      // presses in a sane way, this code checks for when that happens
      // and simulates a backspace press in this case.

      if (_browser.android && _browser.chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
        this.cm.triggerOnKeyDown({
          type: "keydown",
          keyCode: 8,
          preventDefault: Math.abs
        });
        this.blur();
        this.focus();
        return;
      }

      if (this.composing) return;
      this.rememberSelection();
      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var head = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (anchor && head) (0, _operations.runInOp)(cm, function () {
        (0, _selection_updates.setSelection)(cm.doc, (0, _selection2.simpleSelection)(anchor, head), _misc.sel_dontScroll);
        if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
      });
    }
  }, {
    key: "pollContent",
    value: function pollContent() {
      if (this.readDOMTimeout != null) {
        clearTimeout(this.readDOMTimeout);
        this.readDOMTimeout = null;
      }

      var cm = this.cm,
          display = cm.display,
          sel = cm.doc.sel.primary();
      var from = sel.from(),
          to = sel.to();
      if (from.ch == 0 && from.line > cm.firstLine()) from = (0, _pos.Pos)(from.line - 1, (0, _utils_line.getLine)(cm.doc, from.line - 1).length);
      if (to.ch == (0, _utils_line.getLine)(cm.doc, to.line).text.length && to.line < cm.lastLine()) to = (0, _pos.Pos)(to.line + 1, 0);
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;
      var fromIndex, fromLine, fromNode;

      if (from.line == display.viewFrom || (fromIndex = (0, _position_measurement.findViewIndex)(cm, from.line)) == 0) {
        fromLine = (0, _utils_line.lineNo)(display.view[0].line);
        fromNode = display.view[0].node;
      } else {
        fromLine = (0, _utils_line.lineNo)(display.view[fromIndex].line);
        fromNode = display.view[fromIndex - 1].node.nextSibling;
      }

      var toIndex = (0, _position_measurement.findViewIndex)(cm, to.line);
      var toLine, toNode;

      if (toIndex == display.view.length - 1) {
        toLine = display.viewTo - 1;
        toNode = display.lineDiv.lastChild;
      } else {
        toLine = (0, _utils_line.lineNo)(display.view[toIndex + 1].line) - 1;
        toNode = display.view[toIndex + 1].node.previousSibling;
      }

      if (!fromNode) return false;
      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = (0, _utils_line.getBetween)(cm.doc, (0, _pos.Pos)(fromLine, 0), (0, _pos.Pos)(toLine, (0, _utils_line.getLine)(cm.doc, toLine).text.length));

      while (newText.length > 1 && oldText.length > 1) {
        if ((0, _misc.lst)(newText) == (0, _misc.lst)(oldText)) {
          newText.pop();
          oldText.pop();
          toLine--;
        } else if (newText[0] == oldText[0]) {
          newText.shift();
          oldText.shift();
          fromLine++;
        } else break;
      }

      var cutFront = 0,
          cutEnd = 0;
      var newTop = newText[0],
          oldTop = oldText[0],
          maxCutFront = Math.min(newTop.length, oldTop.length);

      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
        ++cutFront;
      }

      var newBot = (0, _misc.lst)(newText),
          oldBot = (0, _misc.lst)(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));

      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        ++cutEnd;
      } // Try to move start of change to start of selection if ambiguous


      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          cutFront--;
          cutEnd++;
        }
      }

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
      var chFrom = (0, _pos.Pos)(fromLine, cutFront);
      var chTo = (0, _pos.Pos)(toLine, oldText.length ? (0, _misc.lst)(oldText).length - cutEnd : 0);

      if (newText.length > 1 || newText[0] || (0, _pos.cmp)(chFrom, chTo)) {
        (0, _changes.replaceRange)(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    }
  }, {
    key: "ensurePolled",
    value: function ensurePolled() {
      this.forceCompositionEnd();
    }
  }, {
    key: "reset",
    value: function reset() {
      this.forceCompositionEnd();
    }
  }, {
    key: "forceCompositionEnd",
    value: function forceCompositionEnd() {
      if (!this.composing) return;
      clearTimeout(this.readDOMTimeout);
      this.composing = null;
      this.updateFromDOM();
      this.div.blur();
      this.div.focus();
    }
  }, {
    key: "readFromDOMSoon",
    value: function readFromDOMSoon() {
      var _this3 = this;

      if (this.readDOMTimeout != null) return;
      this.readDOMTimeout = setTimeout(function () {
        _this3.readDOMTimeout = null;

        if (_this3.composing) {
          if (_this3.composing.done) _this3.composing = null;else return;
        }

        _this3.updateFromDOM();
      }, 80);
    }
  }, {
    key: "updateFromDOM",
    value: function updateFromDOM() {
      var _this4 = this;

      if (this.cm.isReadOnly() || !this.pollContent()) (0, _operations.runInOp)(this.cm, function () {
        return (0, _view_tracking.regChange)(_this4.cm);
      });
    }
  }, {
    key: "setUneditable",
    value: function setUneditable(node) {
      node.contentEditable = "false";
    }
  }, {
    key: "onKeyPress",
    value: function onKeyPress(e) {
      if (e.charCode == 0 || this.composing) return;
      e.preventDefault();
      if (!this.cm.isReadOnly()) (0, _operations.operation)(this.cm, _input.applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    }
  }, {
    key: "readOnlyChanged",
    value: function readOnlyChanged(val) {
      this.div.contentEditable = String(val != "nocursor");
    }
  }, {
    key: "onContextMenu",
    value: function onContextMenu() {}
  }, {
    key: "resetPosition",
    value: function resetPosition() {}
  }]);

  return ContentEditableInput;
}();

exports["default"] = ContentEditableInput;
ContentEditableInput.prototype.needsContentAttribute = true;

function posToDOM(cm, pos) {
  var view = (0, _position_measurement.findViewForLine)(cm, pos.line);
  if (!view || view.hidden) return null;
  var line = (0, _utils_line.getLine)(cm.doc, pos.line);
  var info = (0, _position_measurement.mapFromLineView)(view, line, pos.line);
  var order = (0, _bidi.getOrder)(line, cm.doc.direction),
      side = "left";

  if (order) {
    var partPos = (0, _bidi.getBidiPartAt)(order, pos.ch);
    side = partPos % 2 ? "right" : "left";
  }

  var result = (0, _position_measurement.nodeAndOffsetInLineMap)(info.map, pos.ch, side);
  result.offset = result.collapse == "right" ? result.end : result.start;
  return result;
}

function isInGutter(node) {
  for (var scan = node; scan; scan = scan.parentNode) {
    if (/CodeMirror-gutter-wrapper/.test(scan.className)) return true;
  }

  return false;
}

function badPos(pos, bad) {
  if (bad) pos.bad = true;
  return pos;
}

function domTextBetween(cm, from, to, fromLine, toLine) {
  var text = "",
      closing = false,
      lineSep = cm.doc.lineSeparator(),
      extraLinebreak = false;

  function recognizeMarker(id) {
    return function (marker) {
      return marker.id == id;
    };
  }

  function close() {
    if (closing) {
      text += lineSep;
      if (extraLinebreak) text += lineSep;
      closing = extraLinebreak = false;
    }
  }

  function addText(str) {
    if (str) {
      close();
      text += str;
    }
  }

  function walk(node) {
    if (node.nodeType == 1) {
      var cmText = node.getAttribute("cm-text");

      if (cmText) {
        addText(cmText);
        return;
      }

      var markerID = node.getAttribute("cm-marker"),
          _range;

      if (markerID) {
        var found = cm.findMarks((0, _pos.Pos)(fromLine, 0), (0, _pos.Pos)(toLine + 1, 0), recognizeMarker(+markerID));
        if (found.length && (_range = found[0].find(0))) addText((0, _utils_line.getBetween)(cm.doc, _range.from, _range.to).join(lineSep));
        return;
      }

      if (node.getAttribute("contenteditable") == "false") return;
      var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
      if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) return;
      if (isBlock) close();

      for (var i = 0; i < node.childNodes.length; i++) {
        walk(node.childNodes[i]);
      }

      if (/^(pre|p)$/i.test(node.nodeName)) extraLinebreak = true;
      if (isBlock) closing = true;
    } else if (node.nodeType == 3) {
      addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
    }
  }

  for (;;) {
    walk(from);
    if (from == to) break;
    from = from.nextSibling;
    extraLinebreak = false;
  }

  return text;
}

function domToPos(cm, node, offset) {
  var lineNode;

  if (node == cm.display.lineDiv) {
    lineNode = cm.display.lineDiv.childNodes[offset];
    if (!lineNode) return badPos(cm.clipPos((0, _pos.Pos)(cm.display.viewTo - 1)), true);
    node = null;
    offset = 0;
  } else {
    for (lineNode = node;; lineNode = lineNode.parentNode) {
      if (!lineNode || lineNode == cm.display.lineDiv) return null;
      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
    }
  }

  for (var i = 0; i < cm.display.view.length; i++) {
    var lineView = cm.display.view[i];
    if (lineView.node == lineNode) return locateNodeInLineView(lineView, node, offset);
  }
}

function locateNodeInLineView(lineView, node, offset) {
  var wrapper = lineView.text.firstChild,
      bad = false;
  if (!node || !(0, _dom.contains)(wrapper, node)) return badPos((0, _pos.Pos)((0, _utils_line.lineNo)(lineView.line), 0), true);

  if (node == wrapper) {
    bad = true;
    node = wrapper.childNodes[offset];
    offset = 0;

    if (!node) {
      var line = lineView.rest ? (0, _misc.lst)(lineView.rest) : lineView.line;
      return badPos((0, _pos.Pos)((0, _utils_line.lineNo)(line), line.text.length), bad);
    }
  }

  var textNode = node.nodeType == 3 ? node : null,
      topNode = node;

  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
    textNode = node.firstChild;
    if (offset) offset = textNode.nodeValue.length;
  }

  while (topNode.parentNode != wrapper) {
    topNode = topNode.parentNode;
  }

  var measure = lineView.measure,
      maps = measure.maps;

  function find(textNode, topNode, offset) {
    for (var i = -1; i < (maps ? maps.length : 0); i++) {
      var map = i < 0 ? measure.map : maps[i];

      for (var j = 0; j < map.length; j += 3) {
        var curNode = map[j + 2];

        if (curNode == textNode || curNode == topNode) {
          var _line = (0, _utils_line.lineNo)(i < 0 ? lineView.line : lineView.rest[i]);

          var ch = map[j] + offset;
          if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
          return (0, _pos.Pos)(_line, ch);
        }
      }
    }
  }

  var found = find(textNode, topNode, offset);
  if (found) return badPos(found, bad); // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems

  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
    found = find(after, after.firstChild, 0);
    if (found) return badPos((0, _pos.Pos)(found.line, found.ch - dist), bad);else dist += after.textContent.length;
  }

  for (var before = topNode.previousSibling, _dist = offset; before; before = before.previousSibling) {
    found = find(before, before.firstChild, -1);
    if (found) return badPos((0, _pos.Pos)(found.line, found.ch + _dist), bad);else _dist += before.textContent.length;
  }
}