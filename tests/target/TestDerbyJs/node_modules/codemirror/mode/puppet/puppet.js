"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof10(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof10 = function _typeof10(obj) { return typeof obj; }; } else { _typeof10 = function _typeof10(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof10(obj); }

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof9(obj) {
  if (typeof Symbol === "function" && _typeof10(Symbol.iterator) === "symbol") {
    _typeof9 = function _typeof9(obj) {
      return _typeof10(obj);
    };
  } else {
    _typeof9 = function _typeof9(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof10(obj);
    };
  }

  return _typeof9(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof8(obj) {
  if (typeof Symbol === "function" && _typeof9(Symbol.iterator) === "symbol") {
    _typeof8 = function _typeof8(obj) {
      return _typeof9(obj);
    };
  } else {
    _typeof8 = function _typeof8(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof9(obj);
    };
  }

  return _typeof8(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof7(obj) {
  if (typeof Symbol === "function" && _typeof8(Symbol.iterator) === "symbol") {
    _typeof7 = function _typeof7(obj) {
      return _typeof8(obj);
    };
  } else {
    _typeof7 = function _typeof7(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof8(obj);
    };
  }

  return _typeof7(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof6(obj) {
  if (typeof Symbol === "function" && _typeof7(Symbol.iterator) === "symbol") {
    _typeof6 = function _typeof6(obj) {
      return _typeof7(obj);
    };
  } else {
    _typeof6 = function _typeof6(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof7(obj);
    };
  }

  return _typeof6(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof5(obj) {
  if (typeof Symbol === "function" && _typeof6(Symbol.iterator) === "symbol") {
    _typeof5 = function _typeof5(obj) {
      return _typeof6(obj);
    };
  } else {
    _typeof5 = function _typeof5(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof6(obj);
    };
  }

  return _typeof5(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof4(obj) {
  if (typeof Symbol === "function" && _typeof5(Symbol.iterator) === "symbol") {
    _typeof4 = function _typeof4(obj) {
      return _typeof5(obj);
    };
  } else {
    _typeof4 = function _typeof4(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof5(obj);
    };
  }

  return _typeof4(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof3(obj) {
  if (typeof Symbol === "function" && _typeof4(Symbol.iterator) === "symbol") {
    _typeof3 = function _typeof3(obj) {
      return _typeof4(obj);
    };
  } else {
    _typeof3 = function _typeof3(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof4(obj);
    };
  }

  return _typeof3(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
} // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE


(function (mod) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) == "object" && (typeof module === "undefined" ? "undefined" : _typeof(module)) == "object") // CommonJS
    mod(require("../../lib/codemirror"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("puppet", function () {
    // Stores the words from the define method
    var words = {}; // Taken, mostly, from the Puppet official variable standards regex

    var variable_regex = /({)?([a-z][a-z0-9_]*)?((::[a-z][a-z0-9_]*)*::)?[a-zA-Z0-9_]+(})?/; // Takes a string of words separated by spaces and adds them as
    // keys with the value of the first argument 'style'

    function define(style, string) {
      var split = string.split(' ');

      for (var i = 0; i < split.length; i++) {
        words[split[i]] = style;
      }
    } // Takes commonly known puppet types/words and classifies them to a style


    define('keyword', 'class define site node include import inherits');
    define('keyword', 'case if else in and elsif default or');
    define('atom', 'false true running present absent file directory undef');
    define('builtin', 'action augeas burst chain computer cron destination dport exec ' + 'file filebucket group host icmp iniface interface jump k5login limit log_level ' + 'log_prefix macauthorization mailalias maillist mcx mount nagios_command ' + 'nagios_contact nagios_contactgroup nagios_host nagios_hostdependency ' + 'nagios_hostescalation nagios_hostextinfo nagios_hostgroup nagios_service ' + 'nagios_servicedependency nagios_serviceescalation nagios_serviceextinfo ' + 'nagios_servicegroup nagios_timeperiod name notify outiface package proto reject ' + 'resources router schedule scheduled_task selboolean selmodule service source ' + 'sport ssh_authorized_key sshkey stage state table tidy todest toports tosource ' + 'user vlan yumrepo zfs zone zpool'); // After finding a start of a string ('|") this function attempts to find the end;
    // If a variable is encountered along the way, we display it differently when it
    // is encapsulated in a double-quoted string.

    function tokenString(stream, state) {
      var current,
          prev,
          found_var = false;

      while (!stream.eol() && (current = stream.next()) != state.pending) {
        if (current === '$' && prev != '\\' && state.pending == '"') {
          found_var = true;
          break;
        }

        prev = current;
      }

      if (found_var) {
        stream.backUp(1);
      }

      if (current == state.pending) {
        state.continueString = false;
      } else {
        state.continueString = true;
      }

      return "string";
    } // Main function


    function tokenize(stream, state) {
      // Matches one whole word
      var word = stream.match(/[\w]+/, false); // Matches attributes (i.e. ensure => present ; 'ensure' would be matched)

      var attribute = stream.match(/(\s+)?\w+\s+=>.*/, false); // Matches non-builtin resource declarations
      // (i.e. "apache::vhost {" or "mycustomclasss {" would be matched)

      var resource = stream.match(/(\s+)?[\w:_]+(\s+)?{/, false); // Matches virtual and exported resources (i.e. @@user { ; and the like)

      var special_resource = stream.match(/(\s+)?[@]{1,2}[\w:_]+(\s+)?{/, false); // Finally advance the stream

      var ch = stream.next(); // Have we found a variable?

      if (ch === '$') {
        if (stream.match(variable_regex)) {
          // If so, and its in a string, assign it a different color
          return state.continueString ? 'variable-2' : 'variable';
        } // Otherwise return an invalid variable


        return "error";
      } // Should we still be looking for the end of a string?


      if (state.continueString) {
        // If so, go through the loop again
        stream.backUp(1);
        return tokenString(stream, state);
      } // Are we in a definition (class, node, define)?


      if (state.inDefinition) {
        // If so, return def (i.e. for 'class myclass {' ; 'myclass' would be matched)
        if (stream.match(/(\s+)?[\w:_]+(\s+)?/)) {
          return 'def';
        } // Match the rest it the next time around


        stream.match(/\s+{/);
        state.inDefinition = false;
      } // Are we in an 'include' statement?


      if (state.inInclude) {
        // Match and return the included class
        stream.match(/(\s+)?\S+(\s+)?/);
        state.inInclude = false;
        return 'def';
      } // Do we just have a function on our hands?
      // In 'ensure_resource("myclass")', 'ensure_resource' is matched


      if (stream.match(/(\s+)?\w+\(/)) {
        stream.backUp(1);
        return 'def';
      } // Have we matched the prior attribute regex?


      if (attribute) {
        stream.match(/(\s+)?\w+/);
        return 'tag';
      } // Do we have Puppet specific words?


      if (word && words.hasOwnProperty(word)) {
        // Negates the initial next()
        stream.backUp(1); // rs move the stream

        stream.match(/[\w]+/); // We want to process these words differently
        // do to the importance they have in Puppet

        if (stream.match(/\s+\S+\s+{/, false)) {
          state.inDefinition = true;
        }

        if (word == 'include') {
          state.inInclude = true;
        } // Returns their value as state in the prior define methods


        return words[word];
      } // Is there a match on a reference?


      if (/(^|\s+)[A-Z][\w:_]+/.test(word)) {
        // Negate the next()
        stream.backUp(1); // Match the full reference

        stream.match(/(^|\s+)[A-Z][\w:_]+/);
        return 'def';
      } // Have we matched the prior resource regex?


      if (resource) {
        stream.match(/(\s+)?[\w:_]+/);
        return 'def';
      } // Have we matched the prior special_resource regex?


      if (special_resource) {
        stream.match(/(\s+)?[@]{1,2}/);
        return 'special';
      } // Match all the comments. All of them.


      if (ch == "#") {
        stream.skipToEnd();
        return "comment";
      } // Have we found a string?


      if (ch == "'" || ch == '"') {
        // Store the type (single or double)
        state.pending = ch; // Perform the looping function to find the end

        return tokenString(stream, state);
      } // Match all the brackets


      if (ch == '{' || ch == '}') {
        return 'bracket';
      } // Match characters that we are going to assume
      // are trying to be regex


      if (ch == '/') {
        stream.match(/.*?\//);
        return 'variable-3';
      } // Match all the numbers


      if (ch.match(/[0-9]/)) {
        stream.eatWhile(/[0-9]+/);
        return 'number';
      } // Match the '=' and '=>' operators


      if (ch == '=') {
        if (stream.peek() == '>') {
          stream.next();
        }

        return "operator";
      } // Keep advancing through all the rest


      stream.eatWhile(/[\w-]/); // Return a blank line for everything else

      return null;
    } // Start it all


    return {
      startState: function startState() {
        var state = {};
        state.inDefinition = false;
        state.inInclude = false;
        state.continueString = false;
        state.pending = false;
        return state;
      },
      token: function token(stream, state) {
        // Strip the spaces, but regex will account for them eitherway
        if (stream.eatSpace()) return null; // Go through the main process

        return tokenize(stream, state);
      }
    };
  });
  CodeMirror.defineMIME("text/x-puppet", "puppet");
});