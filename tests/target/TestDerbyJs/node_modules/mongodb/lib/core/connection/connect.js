'use strict';

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

var net = require('net');

var tls = require('tls');

var Connection = require('./connection');

var Query = require('./commands').Query;

var MongoError = require('../error').MongoError;

var MongoNetworkError = require('../error').MongoNetworkError;

var defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;

var WIRE_CONSTANTS = require('../wireprotocol/constants');

var makeClientMetadata = require('../utils').makeClientMetadata;

var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
var AUTH_PROVIDERS;

function connect(options, cancellationToken, callback) {
  if (typeof cancellationToken === 'function') {
    callback = cancellationToken;
    cancellationToken = undefined;
  }

  var ConnectionType = options && options.connectionType ? options.connectionType : Connection;

  if (AUTH_PROVIDERS == null) {
    AUTH_PROVIDERS = defaultAuthProviders(options.bson);
  }

  var family = options.family !== void 0 ? options.family : 0;
  makeConnection(family, options, cancellationToken, function (err, socket) {
    if (err) {
      callback(err, socket); // in the error case, `socket` is the originating error event name

      return;
    }

    performInitialHandshake(new ConnectionType(socket, options), options, callback);
  });
}

function isModernConnectionType(conn) {
  return typeof conn.command === 'function';
}

function getSaslSupportedMechs(options) {
  if (!(options && options.credentials)) {
    return {};
  }

  var credentials = options.credentials; // TODO: revisit whether or not items like `options.user` and `options.dbName` should be checked here

  var authMechanism = credentials.mechanism;
  var authSource = credentials.source || options.dbName || 'admin';
  var user = credentials.username || options.user;

  if (typeof authMechanism === 'string' && authMechanism.toUpperCase() !== 'DEFAULT') {
    return {};
  }

  if (!user) {
    return {};
  }

  return {
    saslSupportedMechs: "".concat(authSource, ".").concat(user)
  };
}

function checkSupportedServer(ismaster, options) {
  var serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === 'number' && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;
  var serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === 'number' && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;

  if (serverVersionHighEnough) {
    if (serverVersionLowEnough) {
      return null;
    }

    var _message = "Server at ".concat(options.host, ":").concat(options.port, " reports minimum wire version ").concat(ismaster.minWireVersion, ", but this version of the Node.js Driver requires at most ").concat(MAX_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(MAX_SUPPORTED_SERVER_VERSION, ")");

    return new MongoError(_message);
  }

  var message = "Server at ".concat(options.host, ":").concat(options.port, " reports maximum wire version ").concat(ismaster.maxWireVersion || 0, ", but this version of the Node.js Driver requires at least ").concat(MIN_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(MIN_SUPPORTED_SERVER_VERSION, ")");
  return new MongoError(message);
}

function performInitialHandshake(conn, options, _callback) {
  var callback = function callback(err, ret) {
    if (err && conn) {
      conn.destroy();
    }

    _callback(err, ret);
  };

  var compressors = [];

  if (options.compression && options.compression.compressors) {
    compressors = options.compression.compressors;
  }

  var handshakeDoc = Object.assign({
    ismaster: true,
    client: options.metadata || makeClientMetadata(options),
    compression: compressors
  }, getSaslSupportedMechs(options));
  var handshakeOptions = Object.assign({}, options); // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS

  if (options.connectTimeoutMS || options.connectionTimeout) {
    handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;
  }

  var start = new Date().getTime();
  runCommand(conn, 'admin.$cmd', handshakeDoc, handshakeOptions, function (err, ismaster) {
    if (err) {
      callback(err);
      return;
    }

    if (ismaster.ok === 0) {
      callback(new MongoError(ismaster));
      return;
    }

    var supportedServerErr = checkSupportedServer(ismaster, options);

    if (supportedServerErr) {
      callback(supportedServerErr);
      return;
    }

    if (!isModernConnectionType(conn)) {
      // resolve compression
      if (ismaster.compression) {
        var agreedCompressors = compressors.filter(function (compressor) {
          return ismaster.compression.indexOf(compressor) !== -1;
        });

        if (agreedCompressors.length) {
          conn.agreedCompressor = agreedCompressors[0];
        }

        if (options.compression && options.compression.zlibCompressionLevel) {
          conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;
        }
      }
    } // NOTE: This is metadata attached to the connection while porting away from
    //       handshake being done in the `Server` class. Likely, it should be
    //       relocated, or at very least restructured.


    conn.ismaster = ismaster;
    conn.lastIsMasterMS = new Date().getTime() - start;
    var credentials = options.credentials;

    if (!ismaster.arbiterOnly && credentials) {
      credentials.resolveAuthMechanism(ismaster);
      authenticate(conn, credentials, callback);
      return;
    }

    callback(undefined, conn);
  });
}

var LEGAL_SSL_SOCKET_OPTIONS = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve', 'secureProtocol', 'secureContext', 'session', 'minDHSize', 'crl', 'rejectUnauthorized'];

function parseConnectOptions(family, options) {
  var host = typeof options.host === 'string' ? options.host : 'localhost';

  if (host.indexOf('/') !== -1) {
    return {
      path: host
    };
  }

  var result = {
    family: family,
    host: host,
    port: typeof options.port === 'number' ? options.port : 27017,
    rejectUnauthorized: false
  };
  return result;
}

function parseSslOptions(family, options) {
  var result = parseConnectOptions(family, options); // Merge in valid SSL options

  for (var name in options) {
    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {
      result[name] = options[name];
    }
  } // Override checkServerIdentity behavior


  if (options.checkServerIdentity === false) {
    // Skip the identiy check by retuning undefined as per node documents
    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback
    result.checkServerIdentity = function () {
      return undefined;
    };
  } else if (typeof options.checkServerIdentity === 'function') {
    result.checkServerIdentity = options.checkServerIdentity;
  } // Set default sni servername to be the same as host


  if (result.servername == null) {
    result.servername = result.host;
  }

  return result;
}

var SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);

function makeConnection(family, options, cancellationToken, _callback) {
  var useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;
  var keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;
  var keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;
  var noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;
  var connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 30000;
  var socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;
  var rejectUnauthorized = typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;

  if (keepAliveInitialDelay > socketTimeout) {
    keepAliveInitialDelay = Math.round(socketTimeout / 2);
  }

  var socket;

  var callback = function callback(err, ret) {
    if (err && socket) {
      socket.destroy();
    }

    _callback(err, ret);
  };

  try {
    if (useSsl) {
      socket = tls.connect(parseSslOptions(family, options));

      if (typeof socket.disableRenegotiation === 'function') {
        socket.disableRenegotiation();
      }
    } else {
      socket = net.createConnection(parseConnectOptions(family, options));
    }
  } catch (err) {
    return callback(err);
  }

  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
  socket.setTimeout(connectionTimeout);
  socket.setNoDelay(noDelay);
  var connectEvent = useSsl ? 'secureConnect' : 'connect';
  var cancellationHandler;

  function errorHandler(eventName) {
    return function (err) {
      SOCKET_ERROR_EVENTS.forEach(function (event) {
        return socket.removeAllListeners(event);
      });

      if (cancellationHandler) {
        cancellationToken.removeListener('cancel', cancellationHandler);
      }

      socket.removeListener(connectEvent, connectHandler);
      callback(connectionFailureError(eventName, err));
    };
  }

  function connectHandler() {
    SOCKET_ERROR_EVENTS.forEach(function (event) {
      return socket.removeAllListeners(event);
    });

    if (cancellationHandler) {
      cancellationToken.removeListener('cancel', cancellationHandler);
    }

    if (socket.authorizationError && rejectUnauthorized) {
      return callback(socket.authorizationError);
    }

    socket.setTimeout(socketTimeout);
    callback(null, socket);
  }

  SOCKET_ERROR_EVENTS.forEach(function (event) {
    return socket.once(event, errorHandler(event));
  });

  if (cancellationToken) {
    cancellationHandler = errorHandler('cancel');
    cancellationToken.once('cancel', cancellationHandler);
  }

  socket.once(connectEvent, connectHandler);
}

var CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];

function runCommand(conn, ns, command, options, callback) {
  if (typeof options === 'function') callback = options, options = {}; // are we using the new connection type? if so, no need to simulate a rpc `command` method

  if (isModernConnectionType(conn)) {
    conn.command(ns, command, options, function (err, result) {
      if (err) {
        callback(err);
        return;
      } // NODE-2382: raw wire protocol messages, or command results should not be used anymore


      callback(undefined, result.result);
    });
    return;
  }

  var socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;
  var bson = conn.options.bson;
  var query = new Query(bson, ns, command, {
    numberToSkip: 0,
    numberToReturn: 1
  });

  var noop = function noop() {};

  function _callback(err, result) {
    callback(err, result);
    callback = noop;
  }

  function errorHandler(err) {
    conn.resetSocketTimeout();
    CONNECTION_ERROR_EVENTS.forEach(function (eventName) {
      return conn.removeListener(eventName, errorHandler);
    });
    conn.removeListener('message', messageHandler);

    if (err == null) {
      err = new MongoError("runCommand failed for connection to '".concat(conn.address, "'"));
    } // ignore all future errors


    conn.on('error', noop);

    _callback(err);
  }

  function messageHandler(msg) {
    if (msg.responseTo !== query.requestId) {
      return;
    }

    conn.resetSocketTimeout();
    CONNECTION_ERROR_EVENTS.forEach(function (eventName) {
      return conn.removeListener(eventName, errorHandler);
    });
    conn.removeListener('message', messageHandler);
    msg.parse({
      promoteValues: true
    });

    _callback(undefined, msg.documents[0]);
  }

  conn.setSocketTimeout(socketTimeout);
  CONNECTION_ERROR_EVENTS.forEach(function (eventName) {
    return conn.once(eventName, errorHandler);
  });
  conn.on('message', messageHandler);
  conn.write(query.toBin());
}

function authenticate(conn, credentials, callback) {
  var mechanism = credentials.mechanism;

  if (!AUTH_PROVIDERS[mechanism]) {
    callback(new MongoError("authMechanism '".concat(mechanism, "' not supported")));
    return;
  }

  var provider = AUTH_PROVIDERS[mechanism];
  provider.auth(runCommand, [conn], credentials, function (err) {
    if (err) return callback(err);
    callback(undefined, conn);
  });
}

function connectionFailureError(type, err) {
  switch (type) {
    case 'error':
      return new MongoNetworkError(err);

    case 'timeout':
      return new MongoNetworkError("connection timed out");

    case 'close':
      return new MongoNetworkError("connection closed");

    case 'cancel':
      return new MongoNetworkError("connection establishment was cancelled");

    default:
      return new MongoNetworkError("unknown network error");
  }
}

module.exports = connect;