"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

require("regenerator-runtime/runtime");

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.

var DLL =
/*#__PURE__*/
function () {
  function DLL() {
    _classCallCheck(this, DLL);

    this.head = this.tail = null;
    this.length = 0;
  }

  _createClass(DLL, [{
    key: "removeLink",
    value: function removeLink(node) {
      if (node.prev) node.prev.next = node.next;else this.head = node.next;
      if (node.next) node.next.prev = node.prev;else this.tail = node.prev;
      node.prev = node.next = null;
      this.length -= 1;
      return node;
    }
  }, {
    key: "empty",
    value: function empty() {
      while (this.head) {
        this.shift();
      }

      return this;
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(node, newNode) {
      newNode.prev = node;
      newNode.next = node.next;
      if (node.next) node.next.prev = newNode;else this.tail = newNode;
      node.next = newNode;
      this.length += 1;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(node, newNode) {
      newNode.prev = node.prev;
      newNode.next = node;
      if (node.prev) node.prev.next = newNode;else this.head = newNode;
      node.prev = newNode;
      this.length += 1;
    }
  }, {
    key: "unshift",
    value: function unshift(node) {
      if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);
    }
  }, {
    key: "push",
    value: function push(node) {
      if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);
    }
  }, {
    key: "shift",
    value: function shift() {
      return this.head && this.removeLink(this.head);
    }
  }, {
    key: "pop",
    value: function pop() {
      return this.tail && this.removeLink(this.tail);
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return _toConsumableArray(this);
    }
  }, {
    key: Symbol.iterator,
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function value() {
      var cur;
      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              cur = this.head;

            case 1:
              if (!cur) {
                _context.next = 7;
                break;
              }

              _context.next = 4;
              return cur.data;

            case 4:
              cur = cur.next;
              _context.next = 1;
              break;

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, value, this);
    })
  }, {
    key: "remove",
    value: function remove(testFn) {
      var curr = this.head;

      while (curr) {
        var _curr = curr,
            next = _curr.next;

        if (testFn(curr)) {
          this.removeLink(curr);
        }

        curr = next;
      }

      return this;
    }
  }]);

  return DLL;
}();

exports["default"] = DLL;

function setInitial(dll, node) {
  dll.length = 1;
  dll.head = dll.tail = node;
}

module.exports = exports["default"];