'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.bind");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/web.timers");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = require('events');

var crypto = require('crypto');

var https = require('https');

var http = require('http');

var url = require('url');

var PerMessageDeflate = require('./permessage-deflate');

var EventTarget = require('./event-target');

var extension = require('./extension');

var constants = require('./constants');

var Receiver = require('./receiver');

var Sender = require('./sender');

var readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
var protocolVersions = [8, 13];
var closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */

var WebSocket =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(WebSocket, _EventEmitter);

  /**
   * Create a new `WebSocket`.
   *
   * @param {String} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
  function WebSocket(address, protocols, options) {
    var _this;

    _classCallCheck(this, WebSocket);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebSocket).call(this));
    _this.readyState = WebSocket.CONNECTING;
    _this.protocol = '';
    _this._binaryType = constants.BINARY_TYPES[0];
    _this._finalize = _this.finalize.bind(_assertThisInitialized(_this));
    _this._closeFrameReceived = false;
    _this._closeFrameSent = false;
    _this._closeMessage = '';
    _this._closeTimer = null;
    _this._finalized = false;
    _this._closeCode = 1006;
    _this._extensions = {};
    _this._isServer = true;
    _this._receiver = null;
    _this._sender = null;
    _this._socket = null;
    _this._error = null;

    if (address !== null) {
      if (!protocols) {
        protocols = [];
      } else if (typeof protocols === 'string') {
        protocols = [protocols];
      } else if (!Array.isArray(protocols)) {
        options = protocols;
        protocols = [];
      }

      initAsClient.call(_assertThisInitialized(_this), address, protocols, options);
    }

    return _this;
  }

  _createClass(WebSocket, [{
    key: "setSocket",

    /**
     * Set up the socket and the internal resources.
     *
     * @param {net.Socket} socket The network socket between the server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Number} maxPayload The maximum allowed message size
     * @private
     */
    value: function setSocket(socket, head, maxPayload) {
      var _this2 = this;

      socket.setTimeout(0);
      socket.setNoDelay();
      socket.on('close', this._finalize);
      socket.on('error', this._finalize);
      socket.on('end', this._finalize);
      this._receiver = new Receiver(this._extensions, maxPayload, this.binaryType);
      this._sender = new Sender(socket, this._extensions);
      this._socket = socket;
      if (head.length > 0) socket.unshift(head);
      socket.on('data', this._receiver.add);

      this._receiver.onmessage = function (data) {
        return _this2.emit('message', data);
      };

      this._receiver.onping = function (data) {
        _this2.pong(data, !_this2._isServer, constants.NOOP);

        _this2.emit('ping', data);
      };

      this._receiver.onpong = function (data) {
        return _this2.emit('pong', data);
      };

      this._receiver.onclose = function (code, reason) {
        //
        // Discard any additional data that is received on the socket.
        //
        _this2._socket.removeListener('data', _this2._receiver.add);

        _this2._closeFrameReceived = true;
        _this2._closeMessage = reason;
        _this2._closeCode = code;
        if (code === 1005) _this2.close();else _this2.close(code, reason);
      };

      this._receiver.onerror = function (error, code) {
        if (_this2._error) return;
        _this2._closeCode = code;
        if (!_this2._finalized) _this2.finalize(error);else _this2.emit('error', error);
      };

      this.readyState = WebSocket.OPEN;
      this.emit('open');
    }
    /**
     * Clean up internal resources and emit the `'close'` event.
     *
     * @param {(Boolean|Error)} error Indicates whether or not an error occurred
     * @private
     */

  }, {
    key: "finalize",
    value: function finalize(error) {
      var _this3 = this;

      if (this._finalized) return;
      this.readyState = WebSocket.CLOSING;
      this._finalized = true;

      if (!this._socket) {
        //
        // `error` is always an `Error` instance in this case.
        //
        this.emit('error', error);
        this.readyState = WebSocket.CLOSED;
        this.emit('close', this._closeCode, this._closeMessage);
        return;
      }

      clearTimeout(this._closeTimer);

      this._socket.removeListener('data', this._receiver.add);

      this._socket.removeListener('close', this._finalize);

      this._socket.removeListener('error', this._finalize);

      this._socket.removeListener('end', this._finalize);

      this._socket.on('error', constants.NOOP);

      if (error) {
        if (error !== true) this._error = error;

        this._socket.destroy();
      } else {
        this._socket.end();
      }

      this._receiver.cleanup(function () {
        var err = _this3._error;

        if (err) {
          _this3._error = null;

          _this3.emit('error', err);
        }

        _this3.readyState = WebSocket.CLOSED;

        if (_this3._extensions[PerMessageDeflate.extensionName]) {
          _this3._extensions[PerMessageDeflate.extensionName].cleanup();
        }

        _this3.emit('close', _this3._closeCode, _this3._closeMessage);
      });
    }
    /**
     * Start a closing handshake.
     *
     *            +----------+     +-----------+   +----------+
     *     + - - -|ws.close()|---->|close frame|-->|ws.close()|- - - -
     *            +----------+     +-----------+   +----------+       |
     *     |      +----------+     +-----------+         |
     *            |ws.close()|<----|close frame|<--------+            |
     *            +----------+     +-----------+         |
     *  CLOSING         |              +---+             |         CLOSING
     *                  |          +---|fin|<------------+
     *     |            |          |   +---+                          |
     *                  |          |   +---+      +-------------+
     *     |            +----------+-->|fin|----->|ws.finalize()| - - +
     *                             |   +---+      +-------------+
     *     |     +-------------+   |
     *      - - -|ws.finalize()|<--+
     *           +-------------+
     *
     * @param {Number} code Status code explaining why the connection is closing
     * @param {String} data A string explaining why the connection is closing
     * @public
     */

  }, {
    key: "close",
    value: function close(code, data) {
      var _this4 = this;

      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        this._req.abort();

        this.finalize(new Error('WebSocket was closed before the connection was established'));
        return;
      }

      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
        return;
      }

      this.readyState = WebSocket.CLOSING;

      this._sender.close(code, data, !this._isServer, function (err) {
        //
        // This error is handled by the `'error'` listener on the socket. We only
        // want to know if the close frame has been sent here.
        //
        if (err) return;
        _this4._closeFrameSent = true;

        if (!_this4._finalized) {
          if (_this4._closeFrameReceived) _this4._socket.end(); //
          // Ensure that the connection is cleaned up even when the closing
          // handshake fails.
          //

          _this4._closeTimer = setTimeout(_this4._finalize, closeTimeout, true);
        }
      });
    }
    /**
     * Send a ping.
     *
     * @param {*} data The data to send
     * @param {Boolean} mask Indicates whether or not to mask `data`
     * @param {Function} cb Callback which is executed when the ping is sent
     * @public
     */

  }, {
    key: "ping",
    value: function ping(data, mask, cb) {
      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (this.readyState !== WebSocket.OPEN) {
        var err = new Error("WebSocket is not open: readyState ".concat(this.readyState, " ") + "(".concat(readyStates[this.readyState], ")"));
        if (cb) return cb(err);
        throw err;
      }

      if (typeof data === 'number') data = data.toString();
      if (mask === undefined) mask = !this._isServer;

      this._sender.ping(data || constants.EMPTY_BUFFER, mask, cb);
    }
    /**
     * Send a pong.
     *
     * @param {*} data The data to send
     * @param {Boolean} mask Indicates whether or not to mask `data`
     * @param {Function} cb Callback which is executed when the pong is sent
     * @public
     */

  }, {
    key: "pong",
    value: function pong(data, mask, cb) {
      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (this.readyState !== WebSocket.OPEN) {
        var err = new Error("WebSocket is not open: readyState ".concat(this.readyState, " ") + "(".concat(readyStates[this.readyState], ")"));
        if (cb) return cb(err);
        throw err;
      }

      if (typeof data === 'number') data = data.toString();
      if (mask === undefined) mask = !this._isServer;

      this._sender.pong(data || constants.EMPTY_BUFFER, mask, cb);
    }
    /**
     * Send a data message.
     *
     * @param {*} data The message to send
     * @param {Object} options Options object
     * @param {Boolean} options.compress Specifies whether or not to compress `data`
     * @param {Boolean} options.binary Specifies whether `data` is binary or text
     * @param {Boolean} options.fin Specifies whether the fragment is the last one
     * @param {Boolean} options.mask Specifies whether or not to mask `data`
     * @param {Function} cb Callback which is executed when data is written out
     * @public
     */

  }, {
    key: "send",
    value: function send(data, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      if (this.readyState !== WebSocket.OPEN) {
        var err = new Error("WebSocket is not open: readyState ".concat(this.readyState, " ") + "(".concat(readyStates[this.readyState], ")"));
        if (cb) return cb(err);
        throw err;
      }

      if (typeof data === 'number') data = data.toString();
      var opts = Object.assign({
        binary: typeof data !== 'string',
        mask: !this._isServer,
        compress: true,
        fin: true
      }, options);

      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }

      this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);
    }
    /**
     * Forcibly close the connection.
     *
     * @public
     */

  }, {
    key: "terminate",
    value: function terminate() {
      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        this._req.abort();

        this.finalize(new Error('WebSocket was closed before the connection was established'));
        return;
      }

      this.finalize(true);
    }
  }, {
    key: "CONNECTING",
    get: function get() {
      return WebSocket.CONNECTING;
    }
  }, {
    key: "CLOSING",
    get: function get() {
      return WebSocket.CLOSING;
    }
  }, {
    key: "CLOSED",
    get: function get() {
      return WebSocket.CLOSED;
    }
  }, {
    key: "OPEN",
    get: function get() {
      return WebSocket.OPEN;
    }
    /**
     * This deviates from the WHATWG interface since ws doesn't support the required
     * default "blob" type (instead we define a custom "nodebuffer" type).
     *
     * @type {String}
     */

  }, {
    key: "binaryType",
    get: function get() {
      return this._binaryType;
    },
    set: function set(type) {
      if (constants.BINARY_TYPES.indexOf(type) < 0) return;
      this._binaryType = type; //
      // Allow to change `binaryType` on the fly.
      //

      if (this._receiver) this._receiver._binaryType = type;
    }
    /**
     * @type {Number}
     */

  }, {
    key: "bufferedAmount",
    get: function get() {
      if (!this._socket) return 0; //
      // `socket.bufferSize` is `undefined` if the socket is closed.
      //

      return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
    }
    /**
     * @type {String}
     */

  }, {
    key: "extensions",
    get: function get() {
      return Object.keys(this._extensions).join();
    }
  }]);

  return WebSocket;
}(EventEmitter);

readyStates.forEach(function (readyState, i) {
  WebSocket[readyStates[i]] = i;
}); //
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//

['open', 'error', 'close', 'message'].forEach(function (method) {
  Object.defineProperty(WebSocket.prototype, "on".concat(method), {
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get: function get() {
      var listeners = this.listeners(method);

      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }
    },

    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set: function set(listener) {
      var listeners = this.listeners(method);

      for (var i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }

      this.addEventListener(method, listener);
    }
  });
});
WebSocket.prototype.addEventListener = EventTarget.addEventListener;
WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;
module.exports = WebSocket;
/**
 * Initialize a WebSocket client.
 *
 * @param {String} address The URL to which to connect
 * @param {String[]} protocols The list of subprotocols
 * @param {Object} options Connection options
 * @param {String} options.protocol Value of the `Sec-WebSocket-Protocol` header
 * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate
 * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request
 * @param {String} options.localAddress Local interface to bind for network connections
 * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header
 * @param {Object} options.headers An object containing request headers
 * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header
 * @param {http.Agent} options.agent Use the specified Agent
 * @param {String} options.host Value of the `Host` header
 * @param {Number} options.family IP address family to use during hostname lookup (4 or 6).
 * @param {Function} options.checkServerIdentity A function to validate the server hostname
 * @param {Boolean} options.rejectUnauthorized Verify or not the server certificate
 * @param {String} options.passphrase The passphrase for the private key or pfx
 * @param {String} options.ciphers The ciphers to use or exclude
 * @param {String} options.ecdhCurve The curves for ECDH key agreement to use or exclude
 * @param {(String|String[]|Buffer|Buffer[])} options.cert The certificate key
 * @param {(String|String[]|Buffer|Buffer[])} options.key The private key
 * @param {(String|Buffer)} options.pfx The private key, certificate, and CA certs
 * @param {(String|String[]|Buffer|Buffer[])} options.ca Trusted certificates
 * @private
 */

function initAsClient(address, protocols, options) {
  var _this5 = this;

  options = Object.assign({
    protocolVersion: protocolVersions[1],
    protocol: protocols.join(','),
    perMessageDeflate: true,
    handshakeTimeout: null,
    localAddress: null,
    headers: null,
    family: null,
    origin: null,
    agent: null,
    host: null,
    //
    // SSL options.
    //
    checkServerIdentity: null,
    rejectUnauthorized: null,
    passphrase: null,
    ciphers: null,
    ecdhCurve: null,
    cert: null,
    key: null,
    pfx: null,
    ca: null
  }, options);

  if (protocolVersions.indexOf(options.protocolVersion) === -1) {
    throw new RangeError("Unsupported protocol version: ".concat(options.protocolVersion, " ") + "(supported versions: ".concat(protocolVersions.join(', '), ")"));
  }

  this._isServer = false;
  this.url = address;
  var serverUrl = url.parse(address);
  var isUnixSocket = serverUrl.protocol === 'ws+unix:';

  if (!serverUrl.host && (!isUnixSocket || !serverUrl.path)) {
    throw new Error("Invalid URL: ".concat(address));
  }

  var isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';
  var key = crypto.randomBytes(16).toString('base64');
  var httpObj = isSecure ? https : http;
  var perMessageDeflate;
  var requestOptions = {
    port: serverUrl.port || (isSecure ? 443 : 80),
    host: serverUrl.hostname,
    path: '/',
    headers: {
      'Sec-WebSocket-Version': options.protocolVersion,
      'Sec-WebSocket-Key': key,
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };
  if (options.headers) Object.assign(requestOptions.headers, options.headers);

  if (options.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(options.perMessageDeflate !== true ? options.perMessageDeflate : {}, false);
    requestOptions.headers['Sec-WebSocket-Extensions'] = extension.format(_defineProperty({}, PerMessageDeflate.extensionName, perMessageDeflate.offer()));
  }

  if (options.protocol) {
    requestOptions.headers['Sec-WebSocket-Protocol'] = options.protocol;
  }

  if (options.origin) {
    if (options.protocolVersion < 13) {
      requestOptions.headers['Sec-WebSocket-Origin'] = options.origin;
    } else {
      requestOptions.headers.Origin = options.origin;
    }
  }

  if (options.host) requestOptions.headers.Host = options.host;
  if (serverUrl.auth) requestOptions.auth = serverUrl.auth;
  if (options.localAddress) requestOptions.localAddress = options.localAddress;
  if (options.family) requestOptions.family = options.family;

  if (isUnixSocket) {
    var parts = serverUrl.path.split(':');
    requestOptions.socketPath = parts[0];
    requestOptions.path = parts[1];
  } else if (serverUrl.path) {
    //
    // Make sure that path starts with `/`.
    //
    if (serverUrl.path.charAt(0) !== '/') {
      requestOptions.path = "/".concat(serverUrl.path);
    } else {
      requestOptions.path = serverUrl.path;
    }
  }

  var agent = options.agent; //
  // A custom agent is required for these options.
  //

  if (options.rejectUnauthorized != null || options.checkServerIdentity || options.passphrase || options.ciphers || options.ecdhCurve || options.cert || options.key || options.pfx || options.ca) {
    if (options.passphrase) requestOptions.passphrase = options.passphrase;
    if (options.ciphers) requestOptions.ciphers = options.ciphers;
    if (options.ecdhCurve) requestOptions.ecdhCurve = options.ecdhCurve;
    if (options.cert) requestOptions.cert = options.cert;
    if (options.key) requestOptions.key = options.key;
    if (options.pfx) requestOptions.pfx = options.pfx;
    if (options.ca) requestOptions.ca = options.ca;

    if (options.checkServerIdentity) {
      requestOptions.checkServerIdentity = options.checkServerIdentity;
    }

    if (options.rejectUnauthorized != null) {
      requestOptions.rejectUnauthorized = options.rejectUnauthorized;
    }

    if (!agent) agent = new httpObj.Agent(requestOptions);
  }

  if (agent) requestOptions.agent = agent;
  this._req = httpObj.get(requestOptions);

  if (options.handshakeTimeout) {
    this._req.setTimeout(options.handshakeTimeout, function () {
      _this5._req.abort();

      _this5.finalize(new Error('Opening handshake has timed out'));
    });
  }

  this._req.on('error', function (error) {
    if (_this5._req.aborted) return;
    _this5._req = null;

    _this5.finalize(error);
  });

  this._req.on('response', function (res) {
    if (!_this5.emit('unexpected-response', _this5._req, res)) {
      _this5._req.abort();

      _this5.finalize(new Error("Unexpected server response: ".concat(res.statusCode)));
    }
  });

  this._req.on('upgrade', function (res, socket, head) {
    _this5.emit('upgrade', res); //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //


    if (_this5.readyState !== WebSocket.CONNECTING) return;
    _this5._req = null;
    var digest = crypto.createHash('sha1').update(key + constants.GUID, 'binary').digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      socket.destroy();
      return _this5.finalize(new Error('Invalid Sec-WebSocket-Accept header'));
    }

    var serverProt = res.headers['sec-websocket-protocol'];
    var protList = (options.protocol || '').split(/, */);
    var protError;

    if (!options.protocol && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (options.protocol && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && protList.indexOf(serverProt) === -1) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      socket.destroy();
      return _this5.finalize(new Error(protError));
    }

    if (serverProt) _this5.protocol = serverProt;

    if (perMessageDeflate) {
      try {
        var extensions = extension.parse(res.headers['sec-websocket-extensions']);

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          _this5._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        socket.destroy();

        _this5.finalize(new Error('Invalid Sec-WebSocket-Extensions header'));

        return;
      }
    }

    _this5.setSocket(socket, head, 0);
  });
}