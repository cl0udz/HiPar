"use strict";

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

var assert = require('assert');

var nock = require('nock');

var CoinbasePro = require('../index.js');

var key = 'key';
var secret = 'secret';
var passphrase = 'passphrase';
var EXCHANGE_API_URL = 'https://api.pro.coinbase.com';
var authClient = new CoinbasePro.AuthenticatedClient(key, secret, passphrase);
suite('AuthenticatedClient', function () {
  afterEach(function () {
    return nock.cleanAll();
  });
  test('._getSignature()', function () {
    var method = 'PUT';
    var relativeURI = '/orders';
    var opts = {
      method: 'PUT',
      uri: 'https://api.pro.coinbase.com/orders'
    };

    var sig = authClient._getSignature(method, relativeURI, opts);

    assert.equal(sig['CB-ACCESS-KEY'], key);
    assert.equal(sig['CB-ACCESS-PASSPHRASE'], passphrase);
    assert(sig['CB-ACCESS-TIMESTAMP']);
    assert(sig['CB-ACCESS-SIGN']);
  });
  test('.getCoinbaseAccounts()', function (done) {
    var expectedResponse = [{
      id: 'fc3a8a57-7142-542d-8436-95a3d82e1622',
      name: 'ETH Wallet',
      balance: '0.00000000',
      currency: 'ETH',
      type: 'wallet',
      primary: false,
      active: true
    }];
    nock(EXCHANGE_API_URL).get('/coinbase-accounts').times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      return authClient.getCoinbaseAccounts(function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.getCoinbaseAccounts().then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.getAccount()', function (done) {
    var expectedResponse = {
      id: 'a1b2c3d4',
      balance: '1.100',
      holds: '0.100',
      available: '1.00',
      currency: 'USD'
    };
    nock(EXCHANGE_API_URL).get('/accounts/test-id').times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      return authClient.getAccount('test-id', function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.getAccount('test-id').then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.getAccounts()', function (done) {
    var expectedResponse = [{
      id: 'a1b2c3d4',
      balance: '1.100',
      holds: '0.100',
      available: '1.00',
      currency: 'USD'
    }];
    nock(EXCHANGE_API_URL).get('/accounts').times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      return authClient.getAccounts(function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.getAccounts().then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.getAccountHistory()', function (done) {
    var expectedResponse = [{
      id: '100',
      created_at: '2014-11-07T08:19:27.028459Z',
      amount: '0.001',
      balance: '239.669',
      type: 'fee',
      details: {
        order_id: 'd50ec984-77a8-460a-b958-66f114b0de9b',
        trade_id: '74',
        product_id: 'BTC-USD'
      }
    }];
    nock(EXCHANGE_API_URL).get('/accounts/test-id/ledger').times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      return authClient.getAccountHistory('test-id', function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.getAccountHistory('test-id').then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.getAccountTransfers()', function (done) {
    var expectedResponse = [{
      id: '100',
      created_at: '2014-11-07T08:19:27.028459Z',
      amount: '0.001',
      balance: '239.669',
      type: 'fee',
      details: {
        order_id: 'd50ec984-77a8-460a-b958-66f114b0de9b',
        trade_id: '74',
        product_id: 'BTC-USD'
      }
    }];
    nock(EXCHANGE_API_URL).get('/accounts/test-id/transfers').times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      return authClient.getAccountTransfers('test-id', function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.getAccountTransfers('test-id').then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.getAccountHolds()', function (done) {
    var expectedResponse = [{
      id: '82dcd140-c3c7-4507-8de4-2c529cd1a28f',
      account_id: 'e0b3f39a-183d-453e-b754-0c13e5bab0b3',
      created_at: '2014-11-06T10:34:47.123456Z',
      updated_at: '2014-11-06T10:40:47.123456Z',
      amount: '4.23',
      type: 'order',
      ref: '0a205de4-dd35-4370-a285-fe8fc375a273'
    }];
    nock(EXCHANGE_API_URL).get('/accounts/test-id/holds').times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      authClient.getAccountHolds('test-id', function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.getAccountHolds('test-id').then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.placeOrder()', function (done) {
    var order = {
      side: 'buy',
      funds: '20.00',
      product_id: 'ETH-USD',
      type: 'market'
    };
    var expectedOrder = order;
    var expectedResponse = {
      id: '0428b97b-bec1-429e-a94c-59992926778d'
    };
    nock(EXCHANGE_API_URL).post('/orders', expectedOrder).reply(200, expectedResponse);
    authClient.placeOrder(order, function (err, resp, data) {
      assert.ifError(err);
      assert.deepEqual(data, expectedResponse);
      nock.cleanAll();
      done();
    });
  });
  test('.buy()', function (done) {
    var order = {
      size: '10',
      product_id: 'BTC-USD',
      price: '100'
    };
    var expectedOrder = order;
    expectedOrder.side = 'buy';
    var expectedResponse = {
      id: '0428b97b-bec1-429e-a94c-59992926778d'
    };
    nock(EXCHANGE_API_URL).post('/orders', expectedOrder).times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      authClient.buy(order, function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.buy(order).then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.buy() market order', function (done) {
    var order = {
      funds: '20.00',
      product_id: 'BTC-USD',
      type: 'market'
    };
    var expectedOrder = order;
    expectedOrder.side = 'buy';
    var expectedResponse = {
      id: '0428b97b-bec1-429e-a94c-59992926778d'
    };
    nock(EXCHANGE_API_URL).post('/orders', expectedOrder).reply(200, expectedResponse);
    authClient.buy(order, function (err, resp, data) {
      assert.ifError(err);
      assert.deepEqual(data, expectedResponse);
      nock.cleanAll();
      done();
    });
  });
  test('.sell()', function (done) {
    var order = {
      size: '10',
      product_id: 'BTC-USD',
      price: '100'
    };
    var expectedOrder = order;
    expectedOrder.side = 'sell';
    var expectedResponse = {
      id: '0428b97b-bec1-429e-a94c-59992926778d'
    };
    nock(EXCHANGE_API_URL).post('/orders', expectedOrder).times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      authClient.sell(order, function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.sell(order).then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  suite('.cancelAllOrders()', function () {
    test('cancels all orders', function () {
      var cancelledOrdersOne = ['deleted-id-1', 'deleted-id-2', 'deleted-id-3', 'deleted-id-4'];
      var cancelledOrdersTwo = ['deleted-id-5', 'deleted-id-6', 'deleted-id-7', 'deleted-id-8'];
      var totalExpectedDeleted = cancelledOrdersOne.concat(cancelledOrdersTwo);

      var nockSetup = function nockSetup() {
        // first list of Id's that just got cancelled
        nock(EXCHANGE_API_URL)["delete"]('/orders').reply(200, cancelledOrdersOne) // second list of Id's that just got cancelled
        ["delete"]('/orders').reply(200, cancelledOrdersTwo) // return empty array signalling the completion of all
        // orders having been cancelled
        ["delete"]('/orders').reply(200, []);
      };

      nockSetup();
      var cbtest = new Promise(function (resolve, reject) {
        var p = authClient.cancelAllOrders(function (err, resp, data) {
          if (err) {
            reject(err);
          } else {
            assert.deepEqual(data, totalExpectedDeleted);
          }

          resolve();
        });

        if (p !== undefined) {
          reject();
        }
      });
      return cbtest.then(function () {
        nockSetup();
        return authClient.cancelAllOrders();
      }).then(function (data) {
        return assert.deepEqual(data, totalExpectedDeleted);
      });
    });
    test('handles errors', function () {
      nock(EXCHANGE_API_URL)["delete"]('/orders').times(2).reply(400, {
        message: 'some error'
      });
      var cbtest = new Promise(function (resolve, reject) {
        authClient.cancelAllOrders(function (err) {
          if (err) {
            assert.equal(err.response.statusCode, 400);
            assert.equal(err.data.message, 'some error');
            resolve();
          } else {
            reject();
          }
        });
      });
      var promisetest = authClient.cancelAllOrders().then(function () {
        return assert.fail('should have thrown an error');
      })["catch"](function (err) {
        assert.equal(err.response.statusCode, 400);
        assert.equal(err.data.message, 'some error');
      });
      return Promise.all([cbtest, promisetest]);
    });
  });
  suite('.cancelOrder()', function () {
    test('requires orderID', function (done) {
      var cbtest = new Promise(function (resolve) {
        authClient.cancelOrder(function (err) {
          assert(err);
          resolve();
        })["catch"](function () {});
      });
      var promisetest = authClient.cancelOrder()["catch"](function (err) {
        return !assert(err) && true;
      }).then(function (val) {
        return assert.strictEqual(val, true);
      });
      Promise.all([cbtest, promisetest]).then(function () {
        return done();
      })["catch"](function (err) {
        return assert.ifError(err) || assert.fail();
      });
    });
    test('cancels order', function (done) {
      var expectedResponse = [{
        id: 'd50ec984-77a8-460a-b958-66f114b0de9b',
        size: '3.0',
        price: '100.23',
        product_id: 'BTC-USD',
        status: 'open',
        filled_size: '1.23',
        fill_fees: '0.001',
        settled: false,
        side: 'buy',
        created_at: '2014-11-14T06:39:55.189376Z'
      }];
      nock(EXCHANGE_API_URL).get('/orders').times(2).reply(200, expectedResponse);
      var cbtest = new Promise(function (resolve, reject) {
        authClient.getOrders(function (err, resp, data) {
          if (err) {
            reject(err);
          }

          assert.deepEqual(data, expectedResponse);
          resolve();
        });
      });
      var promisetest = authClient.getOrders().then(function (data) {
        return assert.deepEqual(data, expectedResponse);
      });
      Promise.all([cbtest, promisetest]).then(function () {
        return done();
      })["catch"](function (err) {
        return assert.ifError(err) || assert.fail();
      });
    });
  });
  test('.getFills()', function (done) {
    var expectedResponse = [{
      trade_id: 74,
      product_id: 'BTC-USD',
      price: '10.00',
      size: '0.01',
      order_id: 'd50ec984-77a8-460a-b958-66f114b0de9b',
      created_at: '2014-11-07T22:19:28.578544Z',
      liquidity: 'T',
      fee: '0.00025',
      settled: true,
      side: 'buy'
    }];
    nock(EXCHANGE_API_URL).get('/fills').times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      authClient.getFills(function (err, response, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.getFills().then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.getFundings()', function (done) {
    var expectedResponse = [{
      id: '280c0a56-f2fa-4d3b-a199-92df76fff5cd',
      order_id: '280c0a56-f2fa-4d3b-a199-92df76fff5cd',
      profile_id: 'd881e5a6-58eb-47cd-b8e2-8d9f2e3ec6f6',
      amount: '545.2400000000000000',
      status: 'outstanding',
      created_at: '2017-03-18T00:34:34.270484Z',
      currency: 'USD',
      repaid_amount: '532.7580047716682500'
    }];
    nock(EXCHANGE_API_URL).get('/funding').times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      authClient.getFundings(function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.getFundings();
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.repay()', function (done) {
    var params = {
      amount: 10000,
      currency: 'USD'
    };
    nock(EXCHANGE_API_URL).post('/funding/repay', params).reply(200, {});
    nock(EXCHANGE_API_URL).post('/funding/repay', params).reply(200, {});
    var cbtest = new Promise(function (resolve, reject) {
      authClient.repay(params, function (err) {
        if (err) {
          reject(err);
        }

        resolve();
      });
    });
    var promisetest = authClient.repay(params);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.marginTransfer()', function (done) {
    var params = {
      margin_profile_id: '45fa9e3b-00ba-4631-b907-8a98cbdf21be',
      type: 'deposit',
      currency: 'USD',
      amount: 2
    };
    var expectedResponse = {
      created_at: '2017-01-25T19:06:23.415126Z',
      id: '80bc6b74-8b1f-4c60-a089-c61f9810d4ab',
      user_id: '521c20b3d4ab09621f000011',
      profile_id: 'cda95996-ac59-45a3-a42e-30daeb061867',
      margin_profile_id: '45fa9e3b-00ba-4631-b907-8a98cbdf21be',
      type: 'deposit',
      amount: '2',
      currency: 'USD',
      account_id: '23035fc7-0707-4b59-b0d2-95d0c035f8f5',
      margin_account_id: 'e1d9862c-a259-4e83-96cd-376352a9d24d',
      margin_product_id: 'BTC-USD',
      status: 'completed',
      nonce: 25
    };
    nock(EXCHANGE_API_URL).post('/profiles/margin-transfer', params).times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      authClient.marginTransfer(params, function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.marginTransfer(params);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.closePosition()', function (done) {
    var params = {
      repay_only: false
    };
    nock(EXCHANGE_API_URL).post('/position/close', params).times(2).reply(200, {});
    var cbtest = new Promise(function (resolve, reject) {
      authClient.closePosition(params, function (err) {
        if (err) {
          reject(err);
        }

        resolve();
      });
    });
    var promisetest = authClient.closePosition(params);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.convert()', function (done) {
    var transfer = {
      from: 'USD',
      to: 'USDC',
      amount: '100'
    };
    var expectedTransfer = transfer;
    nock(EXCHANGE_API_URL).post('/conversions', expectedTransfer).times(2).reply(200, {});
    var cbtest = new Promise(function (resolve, reject) {
      authClient.convert(transfer, function (err) {
        if (err) {
          reject(err);
        }

        resolve();
      });
    });
    var promisetest = authClient.convert(transfer);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.deposit()', function (done) {
    var transfer = {
      amount: 10480,
      currency: 'USD',
      coinbase_account_id: 'test-id'
    };
    var expectedTransfer = transfer;
    nock(EXCHANGE_API_URL).post('/deposits/coinbase-account', expectedTransfer).times(2).reply(200, {});
    var cbtest = new Promise(function (resolve, reject) {
      authClient.deposit(transfer, function (err) {
        if (err) {
          reject(err);
        }

        resolve();
      });
    });
    var promisetest = authClient.deposit(transfer);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.depositPayment()', function (done) {
    var transfer = {
      amount: 10480,
      currency: 'USD',
      payment_method_id: 'test-id'
    };
    var expectedTransfer = transfer;
    nock(EXCHANGE_API_URL).post('/deposits/payment-method', expectedTransfer).times(2).reply(200, {});
    var cbtest = new Promise(function (resolve, reject) {
      authClient.depositPayment(transfer, function (err) {
        if (err) {
          reject(err);
        }

        resolve();
      });
    });
    var promisetest = authClient.depositPayment(transfer);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.depositCrypto()', function (done) {
    var params = {
      currency: 'BTC'
    };
    var expectedAccountsRespons = [{
      id: 'test-id',
      name: 'BTC Wallet',
      balance: '0.00000000',
      currency: 'BTC',
      type: 'wallet',
      primary: true,
      active: true
    }];
    var expectedAddressResponse = {
      id: 'test-id',
      address: 'test-address',
      name: 'New exchange deposit address',
      created_at: '2018-02-18T06:26:10Z',
      updated_at: '2018-02-18T06:26:10Z',
      network: 'bitcoin',
      uri_scheme: 'bitcoin',
      resource: 'address',
      resource_path: '/v2/accounts/test-account-id/addresses/test-id',
      warning_title: 'Only send Bitcoin (BTC) to this address',
      warning_details: 'Sending any other digital asset, including Bitcoin Cash (BCH), will result in permanent loss.',
      callback_url: null,
      exchange_deposit_address: true
    };
    nock(EXCHANGE_API_URL).get('/coinbase-accounts').times(2).reply(200, expectedAccountsRespons);
    nock(EXCHANGE_API_URL).post('/coinbase-accounts/test-id/addresses').times(2).reply(200, expectedAddressResponse);
    var cbtest = new Promise(function (resolve, reject) {
      authClient.depositCrypto(params, function (err) {
        if (err) {
          reject(err);
        }

        resolve();
      });
    });
    var promisetest = authClient.depositCrypto(params);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.withdraw()', function (done) {
    var transfer = {
      amount: 10480,
      currency: 'USD',
      coinbase_account_id: 'test-id'
    };
    var expectedTransfer = transfer;
    nock(EXCHANGE_API_URL).post('/withdrawals/coinbase-account', expectedTransfer).times(2).reply(200, {});
    var cbtest = new Promise(function (resolve, reject) {
      authClient.withdraw(transfer, function (err) {
        if (err) {
          reject(err);
        }

        resolve();
      });
    });
    var promisetest = authClient.withdraw(transfer);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.withdrawPayment()', function (done) {
    var transfer = {
      amount: 10480,
      currency: 'USD',
      payment_method_id: 'test-id'
    };
    var expectedTransfer = transfer;
    nock(EXCHANGE_API_URL).post('/withdrawals/payment-method', expectedTransfer).times(2).reply(200, {});
    var cbtest = new Promise(function (resolve, reject) {
      authClient.withdrawPayment(transfer, function (err) {
        if (err) {
          reject(err);
        }

        resolve();
      });
    });
    var promisetest = authClient.withdrawPayment(transfer);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.createReport()', function (done) {
    var params = {
      type: 'fills',
      start_date: '2014-11-01T00:00:00.000Z',
      end_date: '2014-11-30T23:59:59.000Z',
      product_id: 'BTC-USD',
      format: 'pdf'
    };
    var expectedResponse = {
      id: 'test-id',
      type: 'fills',
      status: 'pending',
      created_at: '2015-01-06T10:34:47.000Z',
      completed_at: 'undefined',
      expires_at: '2015-01-13T10:35:47.000Z',
      file_url: 'undefined',
      params: {
        start_date: '2014-11-01T00:00:00.000Z',
        end_date: '2014-11-30T23:59:59.000Z'
      }
    };
    nock(EXCHANGE_API_URL).post('/reports', params).times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      return authClient.createReport(params, function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.createReport(params).then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.getReportStatus()', function (done) {
    var expectedResponse = {
      id: 'test-id',
      type: 'fills',
      status: 'ready',
      created_at: '2015-01-06T10:34:47.000Z',
      completed_at: '2015-01-06T10:35:47.000Z',
      expires_at: '2015-01-13T10:35:47.000Z',
      file_url: 'https://example.com/0428b97b.../fills.pdf',
      params: {
        start_date: '2014-11-01T00:00:00.000Z',
        end_date: '2014-11-30T23:59:59.000Z'
      }
    };
    nock(EXCHANGE_API_URL).get('/reports/test-id').times(2).reply(200, expectedResponse);
    var cbtest = new Promise(function (resolve, reject) {
      return authClient.getReportStatus('test-id', function (err, resp, data) {
        if (err) {
          reject(err);
        }

        assert.deepEqual(data, expectedResponse);
        resolve();
      });
    });
    var promisetest = authClient.getReportStatus('test-id').then(function (data) {
      return assert.deepEqual(data, expectedResponse);
    });
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
  test('.withdrawCrypto()', function (done) {
    var withdrawParams = {
      amount: 10480,
      currency: 'BTC',
      crypto_address: 'test-address'
    };
    nock(EXCHANGE_API_URL).post('/withdrawals/crypto', withdrawParams).times(2).reply(200, {});
    var cbtest = new Promise(function (resolve, reject) {
      authClient.withdrawCrypto(withdrawParams, function (err) {
        if (err) {
          reject(err);
        }

        resolve();
      });
    });
    var promisetest = authClient.withdrawCrypto(withdrawParams);
    Promise.all([cbtest, promisetest]).then(function () {
      return done();
    })["catch"](function (err) {
      return assert.ifError(err) || assert.fail();
    });
  });
});