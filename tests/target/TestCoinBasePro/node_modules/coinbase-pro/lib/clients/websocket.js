"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.function.bind");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var Websocket = require('ws');

var Utils = require('../utilities.js');

var _require2 = require('../../lib/request_signer'),
    signRequest = _require2.signRequest;
/**
 * Create a new connection to a websocket feed
 * @param {String[]} [productIDs] - The Coinbase Pro products to listen to. Default: ['BTC-USD']
 * @param {String} [websocketURI] - Optional websocket URL. Default: The official Coinbase Pro feed.
 * @param {Object} [auth] - An optional object containing your API key details (key, secret & passphrase)
 */


var WebsocketClient =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(WebsocketClient, _EventEmitter);

  function WebsocketClient(productIDs) {
    var _this;

    var websocketURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'wss://ws-feed.pro.coinbase.com';
    var auth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref$channels = _ref.channels,
        channels = _ref$channels === void 0 ? null : _ref$channels;

    _classCallCheck(this, WebsocketClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebsocketClient).call(this));
    _this.productIDs = Utils.determineProductIDs(productIDs);
    _this.websocketURI = websocketURI;
    _this.auth = Utils.checkAuth(auth);
    _this.channels = channels || ['full'];

    if (!_this.channels.includes('heartbeat')) {
      _this.channels.push('heartbeat');
    }

    _this.connect();

    return _this;
  }

  _createClass(WebsocketClient, [{
    key: "connect",
    value: function connect() {
      if (this.socket) {
        this.socket.close();
      }

      this.socket = new Websocket(this.websocketURI);
      this.socket.on('message', this.onMessage.bind(this));
      this.socket.on('open', this.onOpen.bind(this));
      this.socket.on('close', this.onClose.bind(this));
      this.socket.on('error', this.onError.bind(this));
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (!this.socket) {
        throw new Error('Could not disconnect (not connected)');
      }

      this.socket.close();
      this.socket = null;
    }
  }, {
    key: "_sendSubscription",
    value: function _sendSubscription(type, _ref2) {
      var product_ids = _ref2.product_ids,
          channels = _ref2.channels;
      var message = {
        type: type
      };

      if (channels) {
        message.channels = channels;
      }

      if (product_ids) {
        message.product_ids = product_ids;
      } // Add Signature


      if (this.auth.secret) {
        var sig = signRequest(this.auth, 'GET', '/users/self/verify');
        Object.assign(message, sig);
      }

      this.socket.send(JSON.stringify(message));
    }
  }, {
    key: "subscribe",
    value: function subscribe(_ref3) {
      var product_ids = _ref3.product_ids,
          channels = _ref3.channels;

      this._sendSubscription('subscribe', {
        product_ids: product_ids,
        channels: channels
      });
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(_ref4) {
      var product_ids = _ref4.product_ids,
          channels = _ref4.channels;

      this._sendSubscription('unsubscribe', {
        product_ids: product_ids,
        channels: channels
      });
    }
  }, {
    key: "onOpen",
    value: function onOpen() {
      this.emit('open');
      this.subscribe({
        product_ids: this.productIDs,
        channels: this.channels
      });
    }
  }, {
    key: "onClose",
    value: function onClose() {
      this.socket = null;
      this.emit('close');
    }
  }, {
    key: "onMessage",
    value: function onMessage(data) {
      var message = JSON.parse(data);

      if (message.type === 'error') {
        this.onError(message);
      } else {
        this.emit('message', message);
      }
    }
  }, {
    key: "onError",
    value: function onError(err) {
      if (!err) {
        return;
      }

      if (err.message === 'unexpected server response (429)') {
        throw new Error('You are connecting too fast and are being throttled! Make sure you subscribe to multiple books on one connection.');
      }

      this.emit('error', err);
    }
  }]);

  return WebsocketClient;
}(EventEmitter);

module.exports = exports = WebsocketClient;