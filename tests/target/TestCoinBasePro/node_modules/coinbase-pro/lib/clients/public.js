"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/web.timers");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _request = require('request');

var _require = require('stream'),
    Readable = _require.Readable;

var DEFAULT_TIMEOUT = 10 * 1000; // 10 sec

var PublicClient =
/*#__PURE__*/
function () {
  function PublicClient() {
    var apiURI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'https://api.pro.coinbase.com';
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PublicClient);

    this.productID = 'BTC-USD';

    if (apiURI && !apiURI.startsWith('http')) {
      process.emitWarning('`new PublicClient()` no longer accepts a product ID as the first argument. ', 'DeprecationWarning');
      this.productID = apiURI;
      apiURI = arguments[1] || 'https://api.pro.coinbase.com';
    }

    this.apiURI = apiURI;
    this.API_LIMIT = 100;
    this.timeout = +options.timeout > 0 ? options.timeout : DEFAULT_TIMEOUT;
  }

  _createClass(PublicClient, [{
    key: "get",
    value: function get() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.request.apply(this, ['get'].concat(args));
    }
  }, {
    key: "put",
    value: function put() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this.request.apply(this, ['put'].concat(args));
    }
  }, {
    key: "post",
    value: function post() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.request.apply(this, ['post'].concat(args));
    }
  }, {
    key: "delete",
    value: function _delete() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this.request.apply(this, ['delete'].concat(args));
    }
  }, {
    key: "addHeaders",
    value: function addHeaders(obj, additional) {
      obj.headers = obj.headers || {};
      return Object.assign(obj.headers, {
        'User-Agent': 'coinbase-pro-node-client',
        Accept: 'application/json',
        'Content-Type': 'application/json'
      }, additional);
    }
  }, {
    key: "makeRelativeURI",
    value: function makeRelativeURI(parts) {
      return '/' + parts.join('/');
    }
  }, {
    key: "makeAbsoluteURI",
    value: function makeAbsoluteURI(relativeURI) {
      return this.apiURI + relativeURI;
    }
  }, {
    key: "makeRequestCallback",
    value: function makeRequestCallback(callback, resolve, reject) {
      return function (err, response, data) {
        try {
          data = JSON.parse(data);
        } catch (e) {
          data = null;
        }

        if (err) {
          err.response = response;
          err.data = data;
        } else if (response.statusCode > 299) {
          err = new Error("HTTP ".concat(response.statusCode, " Error: ").concat(data && data.message));
          err.response = response;
          err.data = data;
        } else if (data === null) {
          err = new Error('Response could not be parsed as JSON');
          err.response = response;
          err.data = data;
        }

        if (typeof callback === 'function') {
          if (err) {
            callback(err);
          } else {
            callback(null, response, data);
          }

          return;
        }

        if (err) {
          reject(err);
        } else {
          resolve(data);
        }
      };
    }
  }, {
    key: "request",
    value: function request(method, uriParts) {
      var _this = this;

      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;

      if (!callback && typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      Object.assign(opts, {
        method: method.toUpperCase(),
        uri: this.makeAbsoluteURI(this.makeRelativeURI(uriParts)),
        qsStringifyOptions: {
          arrayFormat: 'repeat'
        },
        timeout: this.timeout
      });
      this.addHeaders(opts);
      var p = new Promise(function (resolve, reject) {
        _request(opts, _this.makeRequestCallback(callback, resolve, reject));
      });

      if (callback) {
        p["catch"](function () {});
        return undefined;
      } else {
        return p;
      }
    }
  }, {
    key: "getProducts",
    value: function getProducts(callback) {
      return this.get(['products'], callback);
    }
  }, {
    key: "getProductOrderBook",
    value: function getProductOrderBook(productID, args, callback) {
      var _this$_normalizeProdu = this._normalizeProductArgs(productID, args, callback, 'getProductOrderBook');

      var _this$_normalizeProdu2 = _slicedToArray(_this$_normalizeProdu, 3);

      productID = _this$_normalizeProdu2[0];
      args = _this$_normalizeProdu2[1];
      callback = _this$_normalizeProdu2[2];
      var path = ['products', productID, 'book'];
      return this.get(path, {
        qs: args
      }, callback);
    }
  }, {
    key: "getProductTicker",
    value: function getProductTicker(productID, callback) {
      var _this$_normalizeProdu3 = this._normalizeProductArgs(productID, null, callback, 'getProductTicker');

      var _this$_normalizeProdu4 = _slicedToArray(_this$_normalizeProdu3, 3);

      productID = _this$_normalizeProdu4[0];
      callback = _this$_normalizeProdu4[2];
      var path = ['products', productID, 'ticker'];
      return this.get(path, callback);
    }
  }, {
    key: "getProductTrades",
    value: function getProductTrades(productID, args, callback) {
      var _this$_normalizeProdu5 = this._normalizeProductArgs(productID, args, callback, 'getProductTrades');

      var _this$_normalizeProdu6 = _slicedToArray(_this$_normalizeProdu5, 3);

      productID = _this$_normalizeProdu6[0];
      args = _this$_normalizeProdu6[1];
      callback = _this$_normalizeProdu6[2];
      var path = ['products', productID, 'trades'];
      return this.get(path, {
        qs: args
      }, callback);
    }
  }, {
    key: "getProductTradeStream",
    value: function getProductTradeStream(productID, tradesFrom, tradesTo) {
      var _this2 = this;

      if (!productID || typeof productID !== 'string') {
        var _Array$prototype$slic = Array.prototype.slice.call(arguments);

        var _Array$prototype$slic2 = _slicedToArray(_Array$prototype$slic, 2);

        tradesFrom = _Array$prototype$slic2[0];
        tradesTo = _Array$prototype$slic2[1];
      }

      var _this$_normalizeProdu7 = this._normalizeProductArgs(productID, null, null, 'getProductTradeStream');

      var _this$_normalizeProdu8 = _slicedToArray(_this$_normalizeProdu7, 1);

      productID = _this$_normalizeProdu8[0];
      var shouldStop = null;

      if (typeof tradesTo === 'function') {
        shouldStop = tradesTo;
        tradesTo = null;
      }

      var rs = new Readable({
        objectMode: true
      });
      var started = false;

      rs._read = function () {
        if (!started) {
          started = true;
          fetchTrades.call(_this2, rs, tradesFrom, tradesTo, shouldStop, 0);
        }
      };

      return rs;

      function fetchTrades(stream, tradesFrom, tradesTo, shouldStop) {
        var _this3 = this;

        var after = tradesFrom + this.API_LIMIT + 1;
        var loop = true;

        if (tradesTo && tradesTo <= after) {
          after = tradesTo;
          loop = false;
        }

        var opts = {
          before: tradesFrom,
          after: after,
          limit: this.API_LIMIT
        };
        this.getProductTrades(productID, opts, function (err, resp, data) {
          if (err) {
            stream.emit('error', err);
            return;
          }

          if (resp.statusCode === 429) {
            // rate-limited, try again
            setTimeout(function () {
              fetchTrades.call(_this3, stream, tradesFrom, tradesTo, shouldStop);
            }, 900);
            return;
          }

          if (resp.statusCode !== 200) {
            stream.emit('error', new Error('Encountered status code ' + resp.statusCode));
          }

          for (var i = data.length - 1; i >= 0; i--) {
            if (shouldStop && shouldStop(data[i])) {
              stream.push(null);
              return;
            }

            stream.push(data[i]);
          }

          if (!loop || data.length === 0) {
            stream.push(null);
            return;
          }

          fetchTrades.call(_this3, stream, tradesFrom + _this3.API_LIMIT, tradesTo, shouldStop);
        });
      }
    }
  }, {
    key: "getProductHistoricRates",
    value: function getProductHistoricRates(productID, args, callback) {
      var _this$_normalizeProdu9 = this._normalizeProductArgs(productID, args, callback, 'getProductHistoricRates');

      var _this$_normalizeProdu10 = _slicedToArray(_this$_normalizeProdu9, 3);

      productID = _this$_normalizeProdu10[0];
      args = _this$_normalizeProdu10[1];
      callback = _this$_normalizeProdu10[2];
      var path = ['products', productID, 'candles'];
      return this.get(path, {
        qs: args
      }, callback);
    }
  }, {
    key: "getProduct24HrStats",
    value: function getProduct24HrStats(productID, callback) {
      var _this$_normalizeProdu11 = this._normalizeProductArgs(productID, null, callback, 'getProduct24HrStats');

      var _this$_normalizeProdu12 = _slicedToArray(_this$_normalizeProdu11, 3);

      productID = _this$_normalizeProdu12[0];
      callback = _this$_normalizeProdu12[2];
      var path = ['products', productID, 'stats'];
      return this.get(path, callback);
    }
  }, {
    key: "getCurrencies",
    value: function getCurrencies(callback) {
      return this.get(['currencies'], callback);
    }
  }, {
    key: "getTime",
    value: function getTime(callback) {
      return this.get(['time'], callback);
    }
  }, {
    key: "_normalizeProductArgs",
    value: function _normalizeProductArgs(productID, args, callback, caller) {
      this._deprecationWarningIfProductIdMissing(productID, caller);

      callback = [callback, args, productID].find(byType('function'));
      args = [args, productID, {}].find(byType('object'));
      productID = [productID, this.productID].find(byType('string'));

      if (!productID) {
        throw new Error('No productID specified.');
      }

      return [productID, args, callback];
    }
  }, {
    key: "_deprecationWarningIfProductIdMissing",
    value: function _deprecationWarningIfProductIdMissing(productID, caller) {
      if (!productID || typeof productID !== 'string') {
        process.emitWarning("`".concat(caller, "()` now requires a product ID as the first argument. ") + "Attempting to use PublicClient#productID (".concat(this.productID, ") instead."), 'DeprecationWarning');
      }
    }
  }]);

  return PublicClient;
}();

var byType = function byType(type) {
  return function (o) {
    return o !== null && _typeof(o) === type;
  };
};

module.exports = exports = PublicClient;