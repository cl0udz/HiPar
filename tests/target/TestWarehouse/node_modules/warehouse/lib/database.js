'use strict';

require("core-js/modules/es.object.assign");

require("regenerator-runtime/runtime");

var JSONStream = require('JSONStream');

var Promise = require('bluebird');

var fs = require('graceful-fs');

var Model = require('./model');

var Schema = require('./schema');

var SchemaType = require('./schematype');

var WarehouseError = require('./error');

var pkg = require('../package.json');

var uncorkAsync = function uncorkAsync(stream) {
  return new Promise(function (resolve) {
    process.nextTick(function () {
      stream.uncork();
      resolve();
    });
  });
};

var exportAsync = Promise.coroutine(
/*#__PURE__*/
regeneratorRuntime.mark(function _callee(database, path) {
  var stream, models, keys, length, writeAsync, i, key, modelExportPromise;
  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          stream = fs.createWriteStream(path); // Start body & Meta & Start models

          stream.write(`{"meta":${JSON.stringify({
            version: database.options.version,
            warehouse: pkg.version
          })},"models":{`);
          models = database._models;
          keys = Object.keys(models);
          length = keys.length; // support stream backpressure

          writeAsync = Promise.promisify(stream.write, {
            context: stream
          }); // models body

          i = 0;

        case 7:
          if (!(i < length)) {
            _context.next = 22;
            break;
          }

          key = keys[i];

          if (models[key]) {
            _context.next = 11;
            break;
          }

          return _context.abrupt("continue", 19);

        case 11:
          stream.cork();
          if (i) stream.write(',', 'ascii');
          stream.write(`"${key}":`);
          modelExportPromise = writeAsync(models[key]._export());
          _context.next = 17;
          return uncorkAsync(stream);

        case 17:
          _context.next = 19;
          return modelExportPromise;

        case 19:
          i++;
          _context.next = 7;
          break;

        case 22:
          // End models
          stream.end('}}', 'ascii');
          return _context.abrupt("return", new Promise(function (resolve, reject) {
            stream.on('error', reject).on('finish', resolve);
          }));

        case 24:
        case "end":
          return _context.stop();
      }
    }
  }, _callee);
}));

class Database {
  /**
   * Database constructor.
   *
   * @param {object} [options]
   *   @param {number} [options.version=0] Database version
   *   @param {string} [options.path] Database path
   *   @param {function} [options.onUpgrade] Triggered when the database is upgraded
   *   @param {function} [options.onDowngrade] Triggered when the database is downgraded
   */
  constructor(options) {
    this.options = Object.assign({
      version: 0,

      onUpgrade() {},

      onDowngrade() {}

    }, options);
    this._models = {};

    class _Model extends Model {}

    this.Model = _Model;
    _Model.prototype._database = this;
  }
  /**
   * Creates a new model.
   *
   * @param {string} name
   * @param {Schema|object} [schema]
   * @return {Model}
   */


  model(name, schema) {
    if (this._models[name]) {
      return this._models[name];
    }

    this._models[name] = new this.Model(name, schema);
    var model = this._models[name];
    return model;
  }
  /**
   * Loads database.
   *
   * @param {function} [callback]
   * @return {Promise}
   */


  load(callback) {
    var _this = this;

    var _this$options = this.options,
        path = _this$options.path,
        onUpgrade = _this$options.onUpgrade,
        onDowngrade = _this$options.onDowngrade,
        newVersion = _this$options.version;
    if (!path) throw new WarehouseError('options.path is required');
    var oldVersion = 0;

    var getMetaCallBack = function getMetaCallBack(data) {
      if (data.meta && data.meta.version) {
        oldVersion = data.meta.version;
      }
    }; // data event arg0 wrap key/value pair.


    var parseStream = JSONStream.parse('models.$*');
    parseStream.once('header', getMetaCallBack);
    parseStream.once('footer', getMetaCallBack);
    parseStream.on('data', function (data) {
      _this.model(data.key)._import(data.value);
    });
    var rs = fs.createReadStream(path, 'utf8');
    var promise = new Promise(function (resolve, reject) {
      parseStream.once('error', reject);
      parseStream.once('end', resolve);
      rs.once('error', reject);
    }).then(function () {
      if (newVersion > oldVersion) {
        return onUpgrade(oldVersion, newVersion);
      } else if (newVersion < oldVersion) {
        return onDowngrade(oldVersion, newVersion);
      }
    }).asCallback(callback);
    rs.pipe(parseStream);
    return promise;
  }
  /**
   * Saves database.
   *
   * @param {function} [callback]
   * @return {Promise}
   */


  save(callback) {
    var path = this.options.path;
    if (!path) throw new WarehouseError('options.path is required');
    return exportAsync(this, path).asCallback(callback);
  }

  toJSON() {
    var _this2 = this;

    var models = Object.keys(this._models).reduce(function (obj, key) {
      var value = _this2._models[key];
      if (value != null) obj[key] = value;
      return obj;
    }, {});
    return {
      meta: {
        version: this.options.version,
        warehouse: pkg.version
      },
      models
    };
  }

}

Database.prototype.Schema = Schema;
Database.Schema = Database.prototype.Schema;
Database.prototype.SchemaType = SchemaType;
Database.SchemaType = Database.prototype.SchemaType;
Database.version = pkg.version;
module.exports = Database;