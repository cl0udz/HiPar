'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof3 = function _typeof3(obj) { return typeof obj; }; } else { _typeof3 = function _typeof3(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof3(obj); }

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

var Busboy = require('busboy');

var fs = require('fs-extra');

var streamifier = require('streamifier');

var md5 = require('md5');

var ACCEPTABLE_MIME = /^(?:multipart\/.+)$/i;
var UNACCEPTABLE_METHODS = ['GET', 'HEAD'];

module.exports = function (options) {
  options = options || {};
  return function (req, res, next) {
    if (!hasBody(req) || !hasAcceptableMethod(req) || !hasAcceptableMime(req)) {
      return next();
    }

    processMultipart(options, req, res, next);
  };
};
/**
 * Processes multipart request
 * Builds a req.body object for fields
 * Builds a req.files object for files
 * @param  {Object}   options expressFileupload and Busboy options
 * @param  {Object}   req     Express request object
 * @param  {Object}   res     Express response object
 * @param  {Function} next    Express next method
 * @return {void}
 */


function processMultipart(options, req, res, next) {
  var busboyOptions = {};
  var busboy;
  req.files = null; // Build busboy config

  for (var k in options) {
    if (Object.prototype.hasOwnProperty.call(options, k)) {
      busboyOptions[k] = options[k];
    }
  } // Attach request headers to busboy config


  busboyOptions.headers = req.headers; // Init busboy instance

  busboy = new Busboy(busboyOptions); // Build multipart req.body fields

  busboy.on('field', function (fieldname, val, fieldnameTruncated, valTruncated, encoding, mime) {
    req.body = req.body || {};
    var prev = req.body[fieldname];

    if (!prev) {
      return req.body[fieldname] = val;
    }

    if (Array.isArray(prev)) {
      return prev.push(val);
    }

    req.body[fieldname] = [prev, val];
  }); // Build req.files fields

  busboy.on('file', function (fieldname, file, filename, encoding, mime) {
    var buffers = [];
    var safeFileNameRegex = /[^\w-]/g;
    file.on('limit', function () {
      if (options.abortOnLimit) {
        res.writeHead(413, {
          'Connection': 'close'
        });
        res.end('File size limit has been reached');
      }
    });
    file.on('data', function (data) {
      buffers.push(data);

      if (options.debug) {
        return console.log('Uploading %s -> %s', fieldname, filename);
      }
    });
    file.on('end', function () {
      if (!req.files) {
        req.files = {};
      }

      var buf = Buffer.concat(buffers); // see: https://github.com/richardgirges/express-fileupload/issues/14
      // firefox uploads empty file in case of cache miss when f5ing page.
      // resulting in unexpected behavior. if there is no file data, the file is invalid.

      if (!buf.length) {
        return;
      }

      if (options.safeFileNames) {
        var maxExtensionLength = 3;
        var extension = '';

        if (_typeof(options.safeFileNames) === 'object') {
          safeFileNameRegex = options.safeFileNames;
        }

        maxExtensionLength = parseInt(options.preserveExtension);

        if (options.preserveExtension || maxExtensionLength === 0) {
          if (isNaN(maxExtensionLength)) {
            maxExtensionLength = 3;
          } else {
            maxExtensionLength = Math.abs(maxExtensionLength);
          }

          var filenameParts = filename.split('.');
          var filenamePartsLen = filenameParts.length;

          if (filenamePartsLen > 1) {
            extension = filenameParts.pop();

            if (extension.length > maxExtensionLength && maxExtensionLength > 0) {
              filenameParts[filenameParts.length - 1] += '.' + extension.substr(0, extension.length - maxExtensionLength);
              extension = extension.substr(-maxExtensionLength);
            }

            extension = maxExtensionLength ? '.' + extension.replace(safeFileNameRegex, '') : '';
            filename = filenameParts.join('.');
          }
        }

        filename = filename.replace(safeFileNameRegex, '').concat(extension);
      }

      var newFile = {
        name: filename,
        data: buf,
        encoding: encoding,
        truncated: file.truncated,
        mimetype: mime,
        md5: md5(buf),
        mv: function mv(path, callback) {
          // Callback is passed in, use the callback API
          if (callback) {
            doMove(function () {
              callback(null);
            }, function (error) {
              callback(error);
            }); // Otherwise, return a promise
          } else {
            return new Promise(function (resolve, reject) {
              doMove(resolve, reject);
            });
          }
          /**
           * Local function that moves the file to a different location on the filesystem
           * Takes two function arguments to make it compatible w/ Promise or Callback APIs
           * @param {Function} successFunc
           * @param {Function} errorFunc
           */


          function doMove(successFunc, errorFunc) {
            var fstream = fs.createWriteStream(path);
            streamifier.createReadStream(buf).pipe(fstream);
            fstream.on('error', function (error) {
              errorFunc(error);
            });
            fstream.on('close', function () {
              successFunc();
            });
          }
        }
      }; // Non-array fields

      if (!req.files.hasOwnProperty(fieldname)) {
        req.files[fieldname] = newFile;
      } else {
        // Array fields
        if (req.files[fieldname] instanceof Array) {
          req.files[fieldname].push(newFile);
        } else {
          req.files[fieldname] = [req.files[fieldname], newFile];
        }
      }
    });
    file.on('error', next);
  });
  busboy.on('finish', next);
  busboy.on('error', next);
  req.pipe(busboy);
} // Methods below were copied from, or heavily inspired by the Connect and connect-busboy packages

/**
 * Ensures the request is not using a non-compliant multipart method
 * such as GET or HEAD
 * @param  {Object}  req Express req object
 * @return {Boolean}
 */


function hasAcceptableMethod(req) {
  return UNACCEPTABLE_METHODS.indexOf(req.method) < 0;
}
/**
 * Ensures that only multipart requests are processed by express-fileupload
 * @param  {Object}  req Express req object
 * @return {Boolean}
 */


function hasAcceptableMime(req) {
  var str = (req.headers['content-type'] || '').split(';')[0];
  return ACCEPTABLE_MIME.test(str);
}
/**
 * Ensures the request contains a content body
 * @param  {Object}  req Express req object
 * @return {Boolean}
 */


function hasBody(req) {
  return 'transfer-encoding' in req.headers || 'content-length' in req.headers && req.headers['content-length'] !== '0';
}