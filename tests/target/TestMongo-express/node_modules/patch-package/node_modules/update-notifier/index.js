'use strict';

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.join");

require("core-js/modules/es.date.now");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.join");

require("core-js/modules/es.date.now");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-property");

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var spawn = require('child_process').spawn;

var path = require('path');

var format = require('util').format;

var importLazy = require('import-lazy')(require);

var configstore = importLazy('configstore');
var chalk = importLazy('chalk');
var semverDiff = importLazy('semver-diff');
var latestVersion = importLazy('latest-version');
var isNpm = importLazy('is-npm');
var isInstalledGlobally = importLazy('is-installed-globally');
var boxen = importLazy('boxen');
var xdgBasedir = importLazy('xdg-basedir');
var isCi = importLazy('is-ci');
var ONE_DAY = 1000 * 60 * 60 * 24;

var UpdateNotifier =
/*#__PURE__*/
function () {
  function UpdateNotifier(options) {
    _classCallCheck(this, UpdateNotifier);

    options = options || {};
    this.options = options;
    options.pkg = options.pkg || {}; // Reduce pkg to the essential keys. with fallback to deprecated options
    // TODO: Remove deprecated options at some point far into the future

    options.pkg = {
      name: options.pkg.name || options.packageName,
      version: options.pkg.version || options.packageVersion
    };

    if (!options.pkg.name || !options.pkg.version) {
      throw new Error('pkg.name and pkg.version required');
    }

    this.packageName = options.pkg.name;
    this.packageVersion = options.pkg.version;
    this.updateCheckInterval = typeof options.updateCheckInterval === 'number' ? options.updateCheckInterval : ONE_DAY;
    this.hasCallback = typeof options.callback === 'function';

    this.callback = options.callback || function () {};

    this.disabled = 'NO_UPDATE_NOTIFIER' in process.env || process.argv.indexOf('--no-update-notifier') !== -1 || isCi();
    this.shouldNotifyInNpmScript = options.shouldNotifyInNpmScript;

    if (!this.disabled && !this.hasCallback) {
      try {
        var ConfigStore = configstore();
        this.config = new ConfigStore("update-notifier-".concat(this.packageName), {
          optOut: false,
          // Init with the current time so the first check is only
          // after the set interval, so not to bother users right away
          lastUpdateCheck: Date.now()
        });
      } catch (err) {
        // Expecting error code EACCES or EPERM
        var msg = chalk().yellow(format(' %s update check failed ', options.pkg.name)) + format('\n Try running with %s or get access ', chalk().cyan('sudo')) + '\n to the local update config store via \n' + chalk().cyan(format(' sudo chown -R $USER:$(id -gn $USER) %s ', xdgBasedir().config));
        process.on('exit', function () {
          console.error('\n' + boxen()(msg, {
            align: 'center'
          }));
        });
      }
    }
  }

  _createClass(UpdateNotifier, [{
    key: "check",
    value: function check() {
      var _this = this;

      if (this.hasCallback) {
        this.checkNpm().then(function (update) {
          return _this.callback(null, update);
        })["catch"](function (err) {
          return _this.callback(err);
        });
        return;
      }

      if (!this.config || this.config.get('optOut') || this.disabled) {
        return;
      }

      this.update = this.config.get('update');

      if (this.update) {
        this.config["delete"]('update');
      } // Only check for updates on a set interval


      if (Date.now() - this.config.get('lastUpdateCheck') < this.updateCheckInterval) {
        return;
      } // Spawn a detached process, passing the options as an environment property


      spawn(process.execPath, [path.join(__dirname, 'check.js'), JSON.stringify(this.options)], {
        detached: true,
        stdio: 'ignore'
      }).unref();
    }
  }, {
    key: "checkNpm",
    value: function checkNpm() {
      var _this2 = this;

      return latestVersion()(this.packageName).then(function (latestVersion) {
        return {
          latest: latestVersion,
          current: _this2.packageVersion,
          type: semverDiff()(_this2.packageVersion, latestVersion) || 'latest',
          name: _this2.packageName
        };
      });
    }
  }, {
    key: "notify",
    value: function notify(opts) {
      var suppressForNpm = !this.shouldNotifyInNpmScript && isNpm();

      if (!process.stdout.isTTY || suppressForNpm || !this.update) {
        return this;
      }

      opts = Object.assign({
        isGlobal: isInstalledGlobally()
      }, opts);
      opts.message = opts.message || 'Update available ' + chalk().dim(this.update.current) + chalk().reset(' â†’ ') + chalk().green(this.update.latest) + ' \nRun ' + chalk().cyan('npm i ' + (opts.isGlobal ? '-g ' : '') + this.packageName) + ' to update';
      opts.boxenOpts = opts.boxenOpts || {
        padding: 1,
        margin: 1,
        align: 'center',
        borderColor: 'yellow',
        borderStyle: 'round'
      };
      var message = '\n' + boxen()(opts.message, opts.boxenOpts);

      if (opts.defer === false) {
        console.error(message);
      } else {
        process.on('exit', function () {
          console.error(message);
        });
        process.on('SIGINT', function () {
          console.error('');
          process.exit();
        });
      }

      return this;
    }
  }]);

  return UpdateNotifier;
}();

module.exports = function (options) {
  var updateNotifier = new UpdateNotifier(options);
  updateNotifier.check();
  return updateNotifier;
};

module.exports.UpdateNotifier = UpdateNotifier;