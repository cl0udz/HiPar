"use strict";

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.bold");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.bold");

require("core-js/modules/web.dom-collections.for-each");

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var chalk_1 = __importDefault(require("chalk"));

var path_1 = require("./path");

var spawnSafe_1 = require("./spawnSafe");

var filterFiles_1 = require("./filterFiles");

var fs_extra_1 = require("fs-extra");

var rimraf_1 = require("rimraf");

var fs_extra_2 = require("fs-extra");

var tmp_1 = require("tmp");

var patchFs_1 = require("./patchFs");

var PackageDetails_1 = require("./PackageDetails");

var resolveRelativeFileDependencies_1 = require("./resolveRelativeFileDependencies");

var getPackageResolution_1 = require("./getPackageResolution");

var parse_1 = require("./patch/parse");

var zlib_1 = require("zlib");

function printNoPackageFoundError(packageName, packageJsonPath) {
  console.error("No such package " + packageName + "\n\n  File not found: " + packageJsonPath);
}

function makePatch(_a) {
  var _b;

  var packagePathSpecifier = _a.packagePathSpecifier,
      appPath = _a.appPath,
      packageManager = _a.packageManager,
      includePaths = _a.includePaths,
      excludePaths = _a.excludePaths,
      patchDir = _a.patchDir;
  var packageDetails = PackageDetails_1.getPatchDetailsFromCliString(packagePathSpecifier);

  if (!packageDetails) {
    console.error("No such package", packagePathSpecifier);
    return;
  }

  var appPackageJson = require(path_1.join(appPath, "package.json"));

  var packagePath = path_1.join(appPath, packageDetails.path);
  var packageJsonPath = path_1.join(packagePath, "package.json");

  if (!fs_extra_1.existsSync(packageJsonPath)) {
    printNoPackageFoundError(packagePathSpecifier, packageJsonPath);
    process.exit(1);
  }

  var tmpRepo = tmp_1.dirSync({
    unsafeCleanup: true
  });
  var tmpRepoPackagePath = path_1.join(tmpRepo.name, packageDetails.path);
  var tmpRepoNpmRoot = tmpRepoPackagePath.slice(0, -("/node_modules/" + packageDetails.name).length);
  var tmpRepoPackageJsonPath = path_1.join(tmpRepoNpmRoot, "package.json");

  try {
    var patchesDir = path_1.resolve(path_1.join(appPath, patchDir));
    console.info(chalk_1["default"].grey("•"), "Creating temporary folder"); // make a blank package.json

    fs_extra_1.mkdirpSync(tmpRepoNpmRoot);
    fs_extra_1.writeFileSync(tmpRepoPackageJsonPath, JSON.stringify({
      dependencies: (_b = {}, _b[packageDetails.name] = getPackageResolution_1.getPackageResolution({
        packageDetails: packageDetails,
        packageManager: packageManager,
        appPath: appPath
      }), _b),
      resolutions: resolveRelativeFileDependencies_1.resolveRelativeFileDependencies(appPath, appPackageJson.resolutions || {})
    }));

    var packageVersion = require(path_1.join(path_1.resolve(packageDetails.path), "package.json")).version; // copy .npmrc in case if packages are hosted in private registry


    var npmrcPath = path_1.join(appPath, ".npmrc");

    if (fs_extra_1.existsSync(npmrcPath)) {
      fs_extra_2.copySync(npmrcPath, path_1.join(tmpRepo.name, ".npmrc"));
    }

    if (packageManager === "yarn") {
      console.info(chalk_1["default"].grey("•"), "Installing " + packageDetails.name + "@" + packageVersion + " with yarn");

      try {
        // try first without ignoring scripts in case they are required
        // this works in 99.99% of cases
        spawnSafe_1.spawnSafeSync("yarn", ["install", "--ignore-engines"], {
          cwd: tmpRepoNpmRoot,
          logStdErrOnError: false
        });
      } catch (e) {
        // try again while ignoring scripts in case the script depends on
        // an implicit context which we havn't reproduced
        spawnSafe_1.spawnSafeSync("yarn", ["install", "--ignore-engines", "--ignore-scripts"], {
          cwd: tmpRepoNpmRoot
        });
      }
    } else {
      console.info(chalk_1["default"].grey("•"), "Installing " + packageDetails.name + "@" + packageVersion + " with npm");

      try {
        // try first without ignoring scripts in case they are required
        // this works in 99.99% of cases
        spawnSafe_1.spawnSafeSync("npm", ["i"], {
          cwd: tmpRepoNpmRoot,
          logStdErrOnError: false
        });
      } catch (e) {
        // try again while ignoring scripts in case the script depends on
        // an implicit context which we havn't reproduced
        spawnSafe_1.spawnSafeSync("npm", ["i", "--ignore-scripts"], {
          cwd: tmpRepoNpmRoot
        });
      }
    }

    var git = function git() {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      return spawnSafe_1.spawnSafeSync("git", args, {
        cwd: tmpRepo.name,
        env: {
          HOME: tmpRepo.name
        }
      });
    }; // remove nested node_modules just to be safe


    rimraf_1.sync(path_1.join(tmpRepoPackagePath, "node_modules")); // remove .git just to be safe

    rimraf_1.sync(path_1.join(tmpRepoPackagePath, "node_modules")); // commit the package

    console.info(chalk_1["default"].grey("•"), "Diffing your files with clean files");
    fs_extra_1.writeFileSync(path_1.join(tmpRepo.name, ".gitignore"), "!/node_modules\n\n");
    git("init");
    git("config", "--local", "user.name", "patch-package");
    git("config", "--local", "user.email", "patch@pack.age"); // remove ignored files first

    filterFiles_1.removeIgnoredFiles(tmpRepoPackagePath, includePaths, excludePaths);
    git("add", "-f", packageDetails.path);
    git("commit", "--allow-empty", "-m", "init"); // replace package with user's version

    rimraf_1.sync(tmpRepoPackagePath);
    fs_extra_2.copySync(packagePath, tmpRepoPackagePath); // remove nested node_modules just to be safe

    rimraf_1.sync(path_1.join(tmpRepoPackagePath, "node_modules")); // remove .git just to be safe

    rimraf_1.sync(path_1.join(tmpRepoPackagePath, "node_modules")); // also remove ignored files like before

    filterFiles_1.removeIgnoredFiles(tmpRepoPackagePath, includePaths, excludePaths); // stage all files

    git("add", "-f", packageDetails.path); // get diff of changes

    var diffResult = git("diff", "--cached", "--no-color", "--ignore-space-at-eol", "--no-ext-diff");

    if (diffResult.stdout.length === 0) {
      console.warn("\u2049\uFE0F  Not creating patch file for package '" + packagePathSpecifier + "'");
      console.warn("\u2049\uFE0F  There don't appear to be any changes.");
      process.exit(1);
      return;
    }

    try {
      parse_1.parsePatchFile(diffResult.stdout.toString());
    } catch (e) {
      if (e.message.includes("Unexpected file mode string: 120000")) {
        console.error("\n\u26D4\uFE0F " + chalk_1["default"].red.bold("ERROR") + "\n\n  Your changes involve creating symlinks. patch-package does not yet support\n  symlinks.\n  \n  \uFE0FPlease use " + chalk_1["default"].bold("--include") + " and/or " + chalk_1["default"].bold("--exclude") + " to narrow the scope of your patch if\n  this was unintentional.\n");
      } else {
        var outPath = "./patch-package-error.json.gz";
        fs_extra_1.writeFileSync(outPath, zlib_1.gzipSync(JSON.stringify({
          error: {
            message: e.message,
            stack: e.stack
          },
          patch: diffResult.stdout.toString()
        })));
        console.error("\n\u26D4\uFE0F " + chalk_1["default"].red.bold("ERROR") + "\n        \n  patch-package was unable to read the patch-file made by git. This should not\n  happen.\n  \n  A diagnostic file was written to\n  \n    " + outPath + "\n  \n  Please attach it to a github issue\n  \n    https://github.com/ds300/patch-package/issues/new?title=New+patch+parse+failed&body=Please+attach+the+diagnostic+file+by+dragging+it+into+here+\uD83D\uDE4F\n  \n  Note that this diagnostic file will contain code from the package you were\n  attempting to patch.\n\n");
      }

      process.exit(1);
      return;
    }

    var packageNames = packageDetails.packageNames.map(function (name) {
      return name.replace(/\//g, "+");
    }).join("++"); // maybe delete existing

    patchFs_1.getPatchFiles(patchDir).forEach(function (filename) {
      var deets = PackageDetails_1.getPackageDetailsFromPatchFilename(filename);

      if (deets && deets.path === packageDetails.path) {
        fs_extra_1.unlinkSync(path_1.join(patchDir, filename));
      }
    });
    var patchFileName = packageNames + "+" + packageVersion + ".patch";
    var patchPath = path_1.join(patchesDir, patchFileName);

    if (!fs_extra_1.existsSync(path_1.dirname(patchPath))) {
      // scoped package
      fs_extra_1.mkdirSync(path_1.dirname(patchPath));
    }

    fs_extra_1.writeFileSync(patchPath, diffResult.stdout);
    console.log(chalk_1["default"].green("✔") + " Created file " + path_1.join(patchDir, patchFileName));
  } catch (e) {
    console.error(e);
    throw e;
  } finally {
    tmpRepo.removeCallback();
  }
}

exports.makePatch = makePatch;