"use strict";

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.for-each");

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var fs_extra_1 = __importDefault(require("fs-extra"));

var path_1 = require("path");

var assertNever_1 = require("../assertNever");

exports.executeEffects = function (effects, _a) {
  var dryRun = _a.dryRun;
  effects.forEach(function (eff) {
    switch (eff.type) {
      case "file deletion":
        if (dryRun) {
          if (!fs_extra_1["default"].existsSync(eff.path)) {
            throw new Error("Trying to delete file that doesn't exist: " + eff.path);
          }
        } else {
          // TODO: integrity checks
          fs_extra_1["default"].unlinkSync(eff.path);
        }

        break;

      case "rename":
        if (dryRun) {
          // TODO: see what patch files look like if moving to exising path
          if (!fs_extra_1["default"].existsSync(eff.fromPath)) {
            throw new Error("Trying to move file that doesn't exist: " + eff.fromPath);
          }
        } else {
          fs_extra_1["default"].moveSync(eff.fromPath, eff.toPath);
        }

        break;

      case "file creation":
        if (dryRun) {
          if (fs_extra_1["default"].existsSync(eff.path)) {
            throw new Error("Trying to create file that already exists: " + eff.path);
          } // todo: check file contents matches

        } else {
          var fileContents = eff.hunk ? eff.hunk.parts[0].lines.join("\n") + (eff.hunk.parts[0].noNewlineAtEndOfFile ? "" : "\n") : "";
          fs_extra_1["default"].ensureDirSync(path_1.dirname(eff.path));
          fs_extra_1["default"].writeFileSync(eff.path, fileContents, {
            mode: eff.mode
          });
        }

        break;

      case "patch":
        applyPatch(eff, {
          dryRun: dryRun
        });
        break;

      case "mode change":
        var currentMode = fs_extra_1["default"].statSync(eff.path).mode;

        if ((isExecutable(eff.newMode) && isExecutable(currentMode) || !isExecutable(eff.newMode) && !isExecutable(currentMode)) && dryRun) {
          console.warn("Mode change is not required for file " + eff.path);
        }

        fs_extra_1["default"].chmodSync(eff.path, eff.newMode);
        break;

      default:
        assertNever_1.assertNever(eff);
    }
  });
};

function isExecutable(fileMode) {
  // tslint:disable-next-line:no-bitwise
  return (fileMode & 64) > 0;
}

var trimRight = function trimRight(s) {
  return s.replace(/\s+$/, "");
};

function linesAreEqual(a, b) {
  return trimRight(a) === trimRight(b);
}
/**
 * How does noNewLineAtEndOfFile work?
 *
 * if you remove the newline from a file that had one without editing other bits:
 *
 *    it creates an insertion/removal pair where the insertion has \ No new line at end of file
 *
 * if you edit a file that didn't have a new line and don't add one:
 *
 *    both insertion and deletion have \ No new line at end of file
 *
 * if you edit a file that didn't have a new line and add one:
 *
 *    deletion has \ No new line at end of file
 *    but not insertion
 *
 * if you edit a file that had a new line and leave it in:
 *
 *    neither insetion nor deletion have the annoation
 *
 */


function applyPatch(_a, _b) {
  var hunks = _a.hunks,
      path = _a.path;
  var dryRun = _b.dryRun; // modifying the file in place

  var fileContents = fs_extra_1["default"].readFileSync(path).toString();
  var mode = fs_extra_1["default"].statSync(path).mode;
  var fileLines = fileContents.split(/\n/);
  var result = [];

  for (var _i = 0, hunks_1 = hunks; _i < hunks_1.length; _i++) {
    var hunk = hunks_1[_i];
    var fuzzingOffset = 0;

    while (true) {
      var modifications = evaluateHunk(hunk, fileLines, fuzzingOffset);

      if (modifications) {
        result.push(modifications);
        break;
      }

      fuzzingOffset = fuzzingOffset < 0 ? fuzzingOffset * -1 : fuzzingOffset * -1 - 1;

      if (Math.abs(fuzzingOffset) > 20) {
        throw new Error("Cant apply hunk " + hunks.indexOf(hunk) + " for file " + path);
      }
    }
  }

  if (dryRun) {
    return;
  }

  var diffOffset = 0;

  for (var _c = 0, result_1 = result; _c < result_1.length; _c++) {
    var modifications = result_1[_c];

    for (var _d = 0, modifications_1 = modifications; _d < modifications_1.length; _d++) {
      var modification = modifications_1[_d];

      switch (modification.type) {
        case "splice":
          fileLines.splice.apply(fileLines, [modification.index + diffOffset, modification.numToDelete].concat(modification.linesToInsert));
          diffOffset += modification.linesToInsert.length - modification.numToDelete;
          break;

        case "pop":
          fileLines.pop();
          break;

        case "push":
          fileLines.push(modification.line);
          break;

        default:
          assertNever_1.assertNever(modification);
      }
    }
  }

  fs_extra_1["default"].writeFileSync(path, fileLines.join("\n"), {
    mode: mode
  });
}

function evaluateHunk(hunk, fileLines, fuzzingOffset) {
  var result = [];
  var contextIndex = hunk.header.original.start - 1 + fuzzingOffset; // do bounds checks for index

  if (contextIndex < 0) {
    return null;
  }

  if (fileLines.length - contextIndex < hunk.header.original.length) {
    return null;
  }

  for (var _i = 0, _a = hunk.parts; _i < _a.length; _i++) {
    var part = _a[_i];

    switch (part.type) {
      case "deletion":
      case "context":
        for (var _b = 0, _c = part.lines; _b < _c.length; _b++) {
          var line = _c[_b];
          var originalLine = fileLines[contextIndex];

          if (!linesAreEqual(originalLine, line)) {
            return null;
          }

          contextIndex++;
        }

        if (part.type === "deletion") {
          result.push({
            type: "splice",
            index: contextIndex - part.lines.length,
            numToDelete: part.lines.length,
            linesToInsert: []
          });

          if (part.noNewlineAtEndOfFile) {
            result.push({
              type: "push",
              line: ""
            });
          }
        }

        break;

      case "insertion":
        result.push({
          type: "splice",
          index: contextIndex,
          numToDelete: 0,
          linesToInsert: part.lines
        });

        if (part.noNewlineAtEndOfFile) {
          result.push({
            type: "pop"
          });
        }

        break;

      default:
        assertNever_1.assertNever(part.type);
    }
  }

  return result;
}