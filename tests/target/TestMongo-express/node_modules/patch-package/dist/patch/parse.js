"use strict";

require("core-js/modules/es.array.slice");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/es.string.trim");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/es.string.trim");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var assertNever_1 = require("../assertNever");

exports.parseHunkHeaderLine = function (headerLine) {
  var match = headerLine.trim().match(/^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@.*/);

  if (!match) {
    throw new Error("Bad header line: '" + headerLine + "'");
  }

  return {
    original: {
      start: Math.max(Number(match[1]), 1),
      length: Number(match[3] || 1)
    },
    patched: {
      start: Math.max(Number(match[4]), 1),
      length: Number(match[6] || 1)
    }
  };
};

exports.NON_EXECUTABLE_FILE_MODE = 420;
exports.EXECUTABLE_FILE_MODE = 493;

var emptyFilePatch = function emptyFilePatch() {
  return {
    diffLineFromPath: null,
    diffLineToPath: null,
    oldMode: null,
    newMode: null,
    deletedFileMode: null,
    newFileMode: null,
    renameFrom: null,
    renameTo: null,
    beforeHash: null,
    afterHash: null,
    fromPath: null,
    toPath: null,
    hunks: null
  };
};

var emptyHunk = function emptyHunk(headerLine) {
  return {
    header: exports.parseHunkHeaderLine(headerLine),
    parts: []
  };
};

var hunkLinetypes = {
  "@": "header",
  "-": "deletion",
  "+": "insertion",
  " ": "context",
  "\\": "pragma",
  // Treat blank lines as context
  undefined: "context"
};

function parsePatchLines(lines, _a) {
  var supportLegacyDiffs = _a.supportLegacyDiffs;
  var result = [];
  var currentFilePatch = emptyFilePatch();
  var state = "parsing header";
  var currentHunk = null;
  var currentHunkMutationPart = null;

  function commitHunk() {
    if (currentHunk) {
      if (currentHunkMutationPart) {
        currentHunk.parts.push(currentHunkMutationPart);
        currentHunkMutationPart = null;
      }

      currentFilePatch.hunks.push(currentHunk);
      currentHunk = null;
    }
  }

  function commitFilePatch() {
    commitHunk();
    result.push(currentFilePatch);
    currentFilePatch = emptyFilePatch();
  }

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];

    if (state === "parsing header") {
      if (line.startsWith("@@")) {
        state = "parsing hunks";
        currentFilePatch.hunks = [];
        i--;
      } else if (line.startsWith("diff --git ")) {
        if (currentFilePatch && currentFilePatch.diffLineFromPath) {
          commitFilePatch();
        }

        var match = line.match(/^diff --git a\/(.*?) b\/(.*?)\s*$/);

        if (!match) {
          throw new Error("Bad diff line: " + line);
        }

        currentFilePatch.diffLineFromPath = match[1];
        currentFilePatch.diffLineToPath = match[2];
      } else if (line.startsWith("old mode ")) {
        currentFilePatch.oldMode = line.slice("old mode ".length).trim();
      } else if (line.startsWith("new mode ")) {
        currentFilePatch.newMode = line.slice("new mode ".length).trim();
      } else if (line.startsWith("deleted file mode ")) {
        currentFilePatch.deletedFileMode = line.slice("deleted file mode ".length).trim();
      } else if (line.startsWith("new file mode ")) {
        currentFilePatch.newFileMode = line.slice("new file mode ".length).trim();
      } else if (line.startsWith("rename from ")) {
        currentFilePatch.renameFrom = line.slice("rename from ".length).trim();
      } else if (line.startsWith("rename to ")) {
        currentFilePatch.renameTo = line.slice("rename to ".length).trim();
      } else if (line.startsWith("index ")) {
        var match = line.match(/(\w+)\.\.(\w+)/);

        if (!match) {
          continue;
        }

        currentFilePatch.beforeHash = match[1];
        currentFilePatch.afterHash = match[2];
      } else if (line.startsWith("--- ")) {
        currentFilePatch.fromPath = line.slice("--- a/".length).trim();
      } else if (line.startsWith("+++ ")) {
        currentFilePatch.toPath = line.slice("+++ b/".length).trim();
      }
    } else {
      if (supportLegacyDiffs && line.startsWith("--- a/")) {
        state = "parsing header";
        commitFilePatch();
        i--;
        continue;
      } // parsing hunks


      var lineType = hunkLinetypes[line[0]] || null;

      switch (lineType) {
        case "header":
          commitHunk();
          currentHunk = emptyHunk(line);
          break;

        case null:
          // unrecognized, bail out
          state = "parsing header";
          commitFilePatch();
          i--;
          break;

        case "pragma":
          if (!line.startsWith("\\ No newline at end of file")) {
            throw new Error("Unrecognized pragma in patch file: " + line);
          }

          if (!currentHunkMutationPart) {
            throw new Error("Bad parser state: No newline at EOF pragma encountered without context");
          }

          currentHunkMutationPart.noNewlineAtEndOfFile = true;
          break;

        case "insertion":
        case "deletion":
        case "context":
          if (!currentHunk) {
            throw new Error("Bad parser state: Hunk lines encountered before hunk header");
          }

          if (currentHunkMutationPart && currentHunkMutationPart.type !== lineType) {
            currentHunk.parts.push(currentHunkMutationPart);
            currentHunkMutationPart = null;
          }

          if (!currentHunkMutationPart) {
            currentHunkMutationPart = {
              type: lineType,
              lines: [],
              noNewlineAtEndOfFile: false
            };
          }

          currentHunkMutationPart.lines.push(line.slice(1));
          break;

        default:
          // exhausitveness check
          assertNever_1.assertNever(lineType);
      }
    }
  }

  commitFilePatch();

  for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
    var hunks = result_1[_i].hunks;

    if (hunks) {
      for (var _b = 0, hunks_1 = hunks; _b < hunks_1.length; _b++) {
        var hunk = hunks_1[_b];
        verifyHunkIntegrity(hunk);
      }
    }
  }

  return result;
}

function interpretParsedPatchFile(files) {
  var result = [];

  for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
    var file = files_1[_i];
    var diffLineFromPath = file.diffLineFromPath,
        diffLineToPath = file.diffLineToPath,
        oldMode = file.oldMode,
        newMode = file.newMode,
        deletedFileMode = file.deletedFileMode,
        newFileMode = file.newFileMode,
        renameFrom = file.renameFrom,
        renameTo = file.renameTo,
        beforeHash = file.beforeHash,
        afterHash = file.afterHash,
        fromPath = file.fromPath,
        toPath = file.toPath,
        hunks = file.hunks;
    var type = renameFrom ? "rename" : deletedFileMode ? "file deletion" : newFileMode ? "file creation" : hunks && hunks.length > 0 ? "patch" : "mode change";
    var destinationFilePath = null;

    switch (type) {
      case "rename":
        if (!renameFrom || !renameTo) {
          throw new Error("Bad parser state: rename from & to not given");
        }

        result.push({
          type: "rename",
          fromPath: renameFrom,
          toPath: renameTo
        });
        destinationFilePath = renameTo;
        break;

      case "file deletion":
        {
          var path = diffLineFromPath || fromPath;

          if (!path) {
            throw new Error("Bad parse state: no path given for file deletion");
          }

          result.push({
            type: "file deletion",
            hunk: hunks && hunks[0] || null,
            path: path,
            mode: parseFileMode(deletedFileMode),
            hash: beforeHash
          });
          break;
        }

      case "file creation":
        {
          var path = diffLineToPath || toPath;

          if (!path) {
            throw new Error("Bad parse state: no path given for file creation");
          }

          result.push({
            type: "file creation",
            hunk: hunks && hunks[0] || null,
            path: path,
            mode: parseFileMode(newFileMode),
            hash: afterHash
          });
          break;
        }

      case "patch":
      case "mode change":
        destinationFilePath = toPath || diffLineToPath;
        break;

      default:
        assertNever_1.assertNever(type);
    }

    if (destinationFilePath && oldMode && newMode && oldMode !== newMode) {
      result.push({
        type: "mode change",
        path: destinationFilePath,
        oldMode: parseFileMode(oldMode),
        newMode: parseFileMode(newMode)
      });
    }

    if (destinationFilePath && hunks && hunks.length) {
      result.push({
        type: "patch",
        path: destinationFilePath,
        hunks: hunks,
        beforeHash: beforeHash,
        afterHash: afterHash
      });
    }
  }

  return result;
}

exports.interpretParsedPatchFile = interpretParsedPatchFile;

function parseFileMode(mode) {
  // tslint:disable-next-line:no-bitwise
  var parsedMode = parseInt(mode, 8) & 511;

  if (parsedMode !== exports.NON_EXECUTABLE_FILE_MODE && parsedMode !== exports.EXECUTABLE_FILE_MODE) {
    throw new Error("Unexpected file mode string: " + mode);
  }

  return parsedMode;
}

function parsePatchFile(file) {
  var lines = file.split(/\n/g);

  if (lines[lines.length - 1] === "") {
    lines.pop();
  }

  try {
    return interpretParsedPatchFile(parsePatchLines(lines, {
      supportLegacyDiffs: false
    }));
  } catch (e) {
    if (e instanceof Error && e.message === "hunk header integrity check failed") {
      return interpretParsedPatchFile(parsePatchLines(lines, {
        supportLegacyDiffs: true
      }));
    }

    throw e;
  }
}

exports.parsePatchFile = parsePatchFile;

function verifyHunkIntegrity(hunk) {
  // verify hunk integrity
  var originalLength = 0;
  var patchedLength = 0;

  for (var _i = 0, _a = hunk.parts; _i < _a.length; _i++) {
    var _b = _a[_i],
        type = _b.type,
        lines = _b.lines;

    switch (type) {
      case "context":
        patchedLength += lines.length;
        originalLength += lines.length;
        break;

      case "deletion":
        originalLength += lines.length;
        break;

      case "insertion":
        patchedLength += lines.length;
        break;

      default:
        assertNever_1.assertNever(type);
    }
  }

  if (originalLength !== hunk.header.original.length || patchedLength !== hunk.header.patched.length) {
    throw new Error("hunk header integrity check failed");
  }
}

exports.verifyHunkIntegrity = verifyHunkIntegrity;