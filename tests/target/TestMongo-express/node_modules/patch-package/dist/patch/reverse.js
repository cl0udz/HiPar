"use strict";

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var parse_1 = require("./parse");

var assertNever_1 = require("../assertNever");

function reverseHunk(hunk) {
  var header = {
    original: hunk.header.patched,
    patched: hunk.header.original
  };
  var parts = [];

  for (var _i = 0, _a = hunk.parts; _i < _a.length; _i++) {
    var part = _a[_i];

    switch (part.type) {
      case "context":
        parts.push(part);
        break;

      case "deletion":
        parts.push({
          type: "insertion",
          lines: part.lines,
          noNewlineAtEndOfFile: part.noNewlineAtEndOfFile
        });
        break;

      case "insertion":
        parts.push({
          type: "deletion",
          lines: part.lines,
          noNewlineAtEndOfFile: part.noNewlineAtEndOfFile
        });
        break;

      default:
        assertNever_1.assertNever(part.type);
    }
  } // swap insertions and deletions over so deletions always come first


  for (var i = 0; i < parts.length - 1; i++) {
    if (parts[i].type === "insertion" && parts[i + 1].type === "deletion") {
      var tmp = parts[i];
      parts[i] = parts[i + 1];
      parts[i + 1] = tmp;
      i += 1;
    }
  }

  var result = {
    header: header,
    parts: parts
  };
  parse_1.verifyHunkIntegrity(result);
  return result;
}

function reversePatchPart(part) {
  switch (part.type) {
    case "file creation":
      return {
        type: "file deletion",
        path: part.path,
        hash: part.hash,
        hunk: part.hunk && reverseHunk(part.hunk),
        mode: part.mode
      };

    case "file deletion":
      return {
        type: "file creation",
        path: part.path,
        hunk: part.hunk && reverseHunk(part.hunk),
        mode: part.mode,
        hash: part.hash
      };

    case "rename":
      return {
        type: "rename",
        fromPath: part.toPath,
        toPath: part.fromPath
      };

    case "patch":
      return {
        type: "patch",
        path: part.path,
        hunks: part.hunks.map(reverseHunk),
        beforeHash: part.afterHash,
        afterHash: part.beforeHash
      };

    case "mode change":
      return {
        type: "mode change",
        path: part.path,
        newMode: part.oldMode,
        oldMode: part.newMode
      };
  }
}

exports.reversePatch = function (patch) {
  return patch.map(reversePatchPart).reverse();
};