'use strict'; // most of this code was written by Andrew Kelley
// licensed under the BSD license: see
// https://github.com/andrewrk/node-mv/blob/master/package.json
// this needs a cleanup

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.link");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.link");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.link");

require("core-js/modules/web.timers");

var u = require('universalify').fromCallback;

var fs = require('graceful-fs');

var ncp = require('../copy/ncp');

var path = require('path');

var remove = require('../remove').remove;

var mkdirp = require('../mkdirs').mkdirs;

function move(src, dest, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  var overwrite = options.overwrite || options.clobber || false;
  isSrcSubdir(src, dest, function (err, itIs) {
    if (err) return callback(err);
    if (itIs) return callback(new Error("Cannot move '".concat(src, "' to a subdirectory of itself, '").concat(dest, "'.")));
    mkdirp(path.dirname(dest), function (err) {
      if (err) return callback(err);
      doRename();
    });
  });

  function doRename() {
    if (path.resolve(src) === path.resolve(dest)) {
      fs.access(src, callback);
    } else if (overwrite) {
      fs.rename(src, dest, function (err) {
        if (!err) return callback();

        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {
          remove(dest, function (err) {
            if (err) return callback(err);
            options.overwrite = false; // just overwriteed it, no need to do it again

            move(src, dest, options, callback);
          });
          return;
        } // weird Windows shit


        if (err.code === 'EPERM') {
          setTimeout(function () {
            remove(dest, function (err) {
              if (err) return callback(err);
              options.overwrite = false;
              move(src, dest, options, callback);
            });
          }, 200);
          return;
        }

        if (err.code !== 'EXDEV') return callback(err);
        moveAcrossDevice(src, dest, overwrite, callback);
      });
    } else {
      fs.link(src, dest, function (err) {
        if (err) {
          if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
            return moveAcrossDevice(src, dest, overwrite, callback);
          }

          return callback(err);
        }

        return fs.unlink(src, callback);
      });
    }
  }
}

function moveAcrossDevice(src, dest, overwrite, callback) {
  fs.stat(src, function (err, stat) {
    if (err) return callback(err);

    if (stat.isDirectory()) {
      moveDirAcrossDevice(src, dest, overwrite, callback);
    } else {
      moveFileAcrossDevice(src, dest, overwrite, callback);
    }
  });
}

function moveFileAcrossDevice(src, dest, overwrite, callback) {
  var flags = overwrite ? 'w' : 'wx';
  var ins = fs.createReadStream(src);
  var outs = fs.createWriteStream(dest, {
    flags: flags
  });
  ins.on('error', function (err) {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose); // may want to create a directory but `out` line above
    // creates an empty file for us: See #108
    // don't care about error here

    fs.unlink(dest, function () {
      // note: `err` here is from the input stream errror
      if (err.code === 'EISDIR' || err.code === 'EPERM') {
        moveDirAcrossDevice(src, dest, overwrite, callback);
      } else {
        callback(err);
      }
    });
  });
  outs.on('error', function (err) {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);
    callback(err);
  });
  outs.once('close', onClose);
  ins.pipe(outs);

  function onClose() {
    fs.unlink(src, callback);
  }
}

function moveDirAcrossDevice(src, dest, overwrite, callback) {
  var options = {
    overwrite: false
  };

  if (overwrite) {
    remove(dest, function (err) {
      if (err) return callback(err);
      startNcp();
    });
  } else {
    startNcp();
  }

  function startNcp() {
    ncp(src, dest, options, function (err) {
      if (err) return callback(err);
      remove(src, callback);
    });
  }
} // return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename


function isSrcSubdir(src, dest, cb) {
  fs.stat(src, function (err, st) {
    if (err) return cb(err);

    if (st.isDirectory()) {
      var baseDir = dest.split(path.dirname(src) + path.sep)[1];

      if (baseDir) {
        var destBasename = baseDir.split(path.sep)[0];
        if (destBasename) return cb(null, src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src));
        return cb(null, false);
      }

      return cb(null, false);
    }

    return cb(null, false);
  });
}

module.exports = {
  move: u(move)
};