"use strict";

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.for-each"); // This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors


var u = require('universalify').fromCallback;

var fs = require('graceful-fs');

var api = ['access', 'appendFile', 'chmod', 'chown', 'close', 'copyFile', 'fchmod', 'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'readFile', 'readdir', 'readlink', 'realpath', 'rename', 'rmdir', 'stat', 'symlink', 'truncate', 'unlink', 'utimes', 'writeFile'].filter(function (key) {
  // Some commands are not available on some systems. Ex:
  // fs.copyFile was added in Node.js v8.5.0
  // fs.mkdtemp was added in Node.js v5.10.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function';
}); // Export all keys:

Object.keys(fs).forEach(function (key) {
  exports[key] = fs[key];
}); // Universalify async methods:

api.forEach(function (method) {
  exports[method] = u(fs[method]);
}); // We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module

exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback);
  }

  return new Promise(function (resolve) {
    return fs.exists(filename, resolve);
  });
}; // fs.read() & fs.write need special treatment due to multiple callback args


exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback);
  }

  return new Promise(function (resolve, reject) {
    fs.read(fd, buffer, offset, length, position, function (err, bytesRead, buffer) {
      if (err) return reject(err);
      resolve({
        bytesRead: bytesRead,
        buffer: buffer
      });
    });
  });
}; // Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// so we need to handle both cases


exports.write = function (fd, buffer, a, b, c, callback) {
  if (typeof arguments[arguments.length - 1] === 'function') {
    return fs.write(fd, buffer, a, b, c, callback);
  } // Check for old, depricated fs.write(fd, string[, position[, encoding]], callback)


  if (typeof buffer === 'string') {
    return new Promise(function (resolve, reject) {
      fs.write(fd, buffer, a, b, function (err, bytesWritten, buffer) {
        if (err) return reject(err);
        resolve({
          bytesWritten: bytesWritten,
          buffer: buffer
        });
      });
    });
  }

  return new Promise(function (resolve, reject) {
    fs.write(fd, buffer, a, b, c, function (err, bytesWritten, buffer) {
      if (err) return reject(err);
      resolve({
        bytesWritten: bytesWritten,
        buffer: buffer
      });
    });
  });
};