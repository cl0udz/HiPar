'use strict';

var t = require('tap');

var test = t.test;

var FindMyWay = require('../');

test('Method should be a string', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();

  try {
    findMyWay.on(0, '/test', function () {});
    t.fail('method shoukd be a string');
  } catch (e) {
    t.is(e.message, 'Method should be a string');
  }
});
test('Method should be a string [ignoreTrailingSlash=true]', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay({
    ignoreTrailingSlash: true
  });

  try {
    findMyWay.on(0, '/test', function () {});
    t.fail('method shoukd be a string');
  } catch (e) {
    t.is(e.message, 'Method should be a string');
  }
});
test('Method should be a string (array)', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();

  try {
    findMyWay.on(['GET', 0], '/test', function () {});
    t.fail('method shoukd be a string');
  } catch (e) {
    t.is(e.message, 'Method should be a string');
  }
});
test('Method should be a string (array) [ignoreTrailingSlash=true]', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay({
    ignoreTrailingSlash: true
  });

  try {
    findMyWay.on(['GET', 0], '/test', function () {});
    t.fail('method shoukd be a string');
  } catch (e) {
    t.is(e.message, 'Method should be a string');
  }
});
test('Path should be a string', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();

  try {
    findMyWay.on('GET', 0, function () {});
    t.fail('path should be a string');
  } catch (e) {
    t.is(e.message, 'Path should be a string');
  }
});
test('Path should be a string [ignoreTrailingSlash=true]', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay({
    ignoreTrailingSlash: true
  });

  try {
    findMyWay.on('GET', 0, function () {});
    t.fail('path should be a string');
  } catch (e) {
    t.is(e.message, 'Path should be a string');
  }
});
test('The path could not be empty', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();

  try {
    findMyWay.on('GET', '', function () {});
    t.fail('The path could not be empty');
  } catch (e) {
    t.is(e.message, 'The path could not be empty');
  }
});
test('The path could not be empty [ignoreTrailingSlash=true]', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay({
    ignoreTrailingSlash: true
  });

  try {
    findMyWay.on('GET', '', function () {});
    t.fail('The path could not be empty');
  } catch (e) {
    t.is(e.message, 'The path could not be empty');
  }
});
test('The first character of a path should be `/` or `*`', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();

  try {
    findMyWay.on('GET', 'a', function () {});
    t.fail('The first character of a path should be `/` or `*`');
  } catch (e) {
    t.is(e.message, 'The first character of a path should be `/` or `*`');
  }
});
test('The first character of a path should be `/` or `*` [ignoreTrailingSlash=true]', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay({
    ignoreTrailingSlash: true
  });

  try {
    findMyWay.on('GET', 'a', function () {});
    t.fail('The first character of a path should be `/` or `*`');
  } catch (e) {
    t.is(e.message, 'The first character of a path should be `/` or `*`');
  }
});
test('Handler should be a function', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();

  try {
    findMyWay.on('GET', '/test', 0);
    t.fail('handler should be a function');
  } catch (e) {
    t.is(e.message, 'Handler should be a function');
  }
});
test('Method is not an http method.', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();

  try {
    findMyWay.on('GETT', '/test', function () {});
    t.fail('method is not a valid http method');
  } catch (e) {
    t.is(e.message, 'Method \'GETT\' is not an http method.');
  }
});
test('Method is not an http method. (array)', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();

  try {
    findMyWay.on(['POST', 'GETT'], '/test', function () {});
    t.fail('method is not a valid http method');
  } catch (e) {
    t.is(e.message, 'Method \'GETT\' is not an http method.');
  }
});
test('The default route must be a function', function (t) {
  t.plan(1);

  try {
    FindMyWay({
      defaultRoute: '/404'
    });
    t.fail('default route must be a function');
  } catch (e) {
    t.is(e.message, 'The default route must be a function');
  }
});
test('Method already declared', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();
  findMyWay.on('GET', '/test', function () {});

  try {
    findMyWay.on('GET', '/test', function () {});
    t.fail('method already declared');
  } catch (e) {
    t.is(e.message, "Method 'GET' already declared for route '/test'");
  }
});
test('Method already declared [ignoreTrailingSlash=true]', function (t) {
  t.plan(2);
  t.test('without trailing slash', function (t) {
    t.plan(2);
    var findMyWay = FindMyWay({
      ignoreTrailingSlash: true
    });
    findMyWay.on('GET', '/test', function () {});

    try {
      findMyWay.on('GET', '/test', function () {});
      t.fail('method already declared');
    } catch (e) {
      t.is(e.message, "Method 'GET' already declared for route '/test'");
    }

    try {
      findMyWay.on('GET', '/test/', function () {});
      t.fail('method already declared');
    } catch (e) {
      t.is(e.message, "Method 'GET' already declared for route '/test/'");
    }
  });
  t.test('with trailing slash', function (t) {
    t.plan(2);
    var findMyWay = FindMyWay({
      ignoreTrailingSlash: true
    });
    findMyWay.on('GET', '/test/', function () {});

    try {
      findMyWay.on('GET', '/test', function () {});
      t.fail('method already declared');
    } catch (e) {
      t.is(e.message, "Method 'GET' already declared for route '/test'");
    }

    try {
      findMyWay.on('GET', '/test/', function () {});
      t.fail('method already declared');
    } catch (e) {
      t.is(e.message, "Method 'GET' already declared for route '/test/'");
    }
  });
});
test('Method already declared nested route', function (t) {
  t.plan(1);
  var findMyWay = FindMyWay();
  findMyWay.on('GET', '/test', function () {});
  findMyWay.on('GET', '/test/hello', function () {});
  findMyWay.on('GET', '/test/world', function () {});

  try {
    findMyWay.on('GET', '/test/hello', function () {});
    t.fail('method already delcared in nested route');
  } catch (e) {
    t.is(e.message, "Method 'GET' already declared for route '/test/hello'");
  }
});
test('Method already declared nested route [ignoreTrailingSlash=true]', function (t) {
  t.plan(2);
  t.test('without trailing slash', function (t) {
    t.plan(2);
    var findMyWay = FindMyWay({
      ignoreTrailingSlash: true
    });
    findMyWay.on('GET', '/test', function () {});
    findMyWay.on('GET', '/test/hello', function () {});
    findMyWay.on('GET', '/test/world', function () {});

    try {
      findMyWay.on('GET', '/test/hello', function () {});
      t.fail('method already declared');
    } catch (e) {
      t.is(e.message, "Method 'GET' already declared for route '/test/hello'");
    }

    try {
      findMyWay.on('GET', '/test/hello/', function () {});
      t.fail('method already declared');
    } catch (e) {
      t.is(e.message, "Method 'GET' already declared for route '/test/hello/'");
    }
  });
  t.test('with trailing slash', function (t) {
    t.plan(2);
    var findMyWay = FindMyWay({
      ignoreTrailingSlash: true
    });
    findMyWay.on('GET', '/test/', function () {});
    findMyWay.on('GET', '/test/hello/', function () {});
    findMyWay.on('GET', '/test/world/', function () {});

    try {
      findMyWay.on('GET', '/test/hello', function () {});
      t.fail('method already declared');
    } catch (e) {
      t.is(e.message, "Method 'GET' already declared for route '/test/hello'");
    }

    try {
      findMyWay.on('GET', '/test/hello/', function () {});
      t.fail('method already declared');
    } catch (e) {
      t.is(e.message, "Method 'GET' already declared for route '/test/hello/'");
    }
  });
});