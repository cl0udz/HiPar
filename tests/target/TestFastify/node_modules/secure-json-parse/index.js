'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/web.dom-collections.iterator");

function _typeof3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof3 = function _typeof3(obj) { return typeof obj; }; } else { _typeof3 = function _typeof3(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof3(obj); }

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

var suspectRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;

function parse(text, reviver, options) {
  // Normalize arguments
  if (options == null) {
    if (reviver != null && _typeof(reviver) === 'object') {
      options = reviver;
      reviver = undefined;
    } else {
      options = {};
    }
  } // Parse normally, allowing exceptions


  var obj = JSON.parse(text, reviver); // options.protoAction: 'error' (default) / 'remove' / 'ignore'

  if (options.protoAction === 'ignore') {
    return obj;
  } // Ignore null and non-objects


  if (!obj || _typeof(obj) !== 'object') {
    return obj;
  } // Check original string for potential exploit


  if (!text.match(suspectRx)) {
    return obj;
  } // Scan result for proto keys


  scan(obj, options);
  return obj;
}

function scan(obj, options) {
  options = options || {};
  var next = [obj];

  while (next.length) {
    var nodes = next;
    next = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;

        if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {
          // Avoid calling node.hasOwnProperty directly
          if (options.protoAction !== 'remove') {
            throw new SyntaxError('Object contains forbidden prototype property');
          }

          delete node.__proto__; // eslint-disable-line
        }

        for (var key in node) {
          var value = node[key];

          if (value && _typeof(value) === 'object') {
            next.push(node[key]);
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
}

function safeParse(text, reviver) {
  try {
    return parse(text, reviver);
  } catch (ignoreError) {
    return null;
  }
}

module.exports = {
  parse: parse,
  scan: scan,
  safeParse: safeParse
};