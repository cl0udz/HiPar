'use strict';

var test = require('tap').test;

var build = require('..');

test('ref internal - properties', function (t) {
  t.plan(2);
  var schema = {
    title: 'object with $ref',
    definitions: {
      def: {
        type: 'object',
        properties: {
          str: {
            type: 'string'
          }
        }
      }
    },
    type: 'object',
    properties: {
      obj: {
        $ref: '#/definitions/def'
      }
    }
  };
  var object = {
    obj: {
      str: 'test'
    }
  };
  var stringify = build(schema);
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"obj":{"str":"test"}}');
});
test('ref internal - items', function (t) {
  t.plan(2);
  var schema = {
    title: 'array with $ref',
    definitions: {
      def: {
        type: 'object',
        properties: {
          str: {
            type: 'string'
          }
        }
      }
    },
    type: 'array',
    items: {
      $ref: '#/definitions/def'
    }
  };
  var array = [{
    str: 'test'
  }];
  var stringify = build(schema);
  var output = stringify(array);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '[{"str":"test"}]');
});
test('ref external - properties', function (t) {
  t.plan(2);
  var externalSchema = {
    first: require('./ref.json'),
    second: {
      definitions: {
        num: {
          type: 'object',
          properties: {
            "int": {
              type: 'integer'
            }
          }
        }
      }
    },
    third: {
      type: 'string'
    }
  };
  var schema = {
    title: 'object with $ref',
    type: 'object',
    properties: {
      obj: {
        $ref: 'first#/definitions/def'
      },
      num: {
        $ref: 'second#/definitions/num'
      },
      strPlain: {
        $ref: 'third'
      },
      strHash: {
        $ref: 'third#'
      }
    }
  };
  var object = {
    obj: {
      str: 'test'
    },
    num: {
      "int": 42
    },
    strPlain: 'test',
    strHash: 'test'
  };
  var stringify = build(schema, {
    schema: externalSchema
  });
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"obj":{"str":"test"},"num":{"int":42},"strPlain":"test","strHash":"test"}');
});
test('ref internal - patternProperties', function (t) {
  t.plan(2);
  var schema = {
    title: 'object with $ref',
    definitions: {
      def: {
        type: 'object',
        properties: {
          str: {
            type: 'string'
          }
        }
      }
    },
    type: 'object',
    properties: {},
    patternProperties: {
      obj: {
        $ref: '#/definitions/def'
      }
    }
  };
  var object = {
    obj: {
      str: 'test'
    }
  };
  var stringify = build(schema);
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"obj":{"str":"test"}}');
});
test('ref internal - additionalProperties', function (t) {
  t.plan(2);
  var schema = {
    title: 'object with $ref',
    definitions: {
      def: {
        type: 'object',
        properties: {
          str: {
            type: 'string'
          }
        }
      }
    },
    type: 'object',
    properties: {},
    additionalProperties: {
      $ref: '#/definitions/def'
    }
  };
  var object = {
    obj: {
      str: 'test'
    }
  };
  var stringify = build(schema);
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"obj":{"str":"test"}}');
});
test('ref internal - pattern-additional Properties', function (t) {
  t.plan(2);
  var schema = {
    title: 'object with $ref',
    definitions: {
      def: {
        type: 'object',
        properties: {
          str: {
            type: 'string'
          }
        }
      }
    },
    type: 'object',
    properties: {},
    patternProperties: {
      reg: {
        $ref: '#/definitions/def'
      }
    },
    additionalProperties: {
      $ref: '#/definitions/def'
    }
  };
  var object = {
    reg: {
      str: 'test'
    },
    obj: {
      str: 'test'
    }
  };
  var stringify = build(schema);
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"reg":{"str":"test"},"obj":{"str":"test"}}');
});
test('ref external - pattern-additional Properties', function (t) {
  t.plan(2);
  var externalSchema = {
    first: require('./ref.json'),
    second: {
      definitions: {
        num: {
          type: 'object',
          properties: {
            "int": {
              type: 'integer'
            }
          }
        }
      }
    }
  };
  var schema = {
    title: 'object with $ref',
    type: 'object',
    properties: {},
    patternProperties: {
      reg: {
        $ref: 'first#/definitions/def'
      }
    },
    additionalProperties: {
      $ref: 'second#/definitions/num'
    }
  };
  var object = {
    reg: {
      str: 'test'
    },
    obj: {
      "int": 42
    }
  };
  var stringify = build(schema, {
    schema: externalSchema
  });
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"reg":{"str":"test"},"obj":{"int":42}}');
});
test('ref internal - deepObject schema', function (t) {
  t.plan(2);
  var schema = {
    title: 'object with $ref',
    definitions: {
      def: {
        type: 'object',
        properties: {
          coming: {
            type: 'object',
            properties: {
              where: {
                type: 'string'
              }
            }
          }
        }
      }
    },
    type: 'object',
    properties: {
      winter: {
        type: 'object',
        properties: {
          is: {
            $ref: '#/definitions/def'
          }
        }
      }
    }
  };
  var object = {
    winter: {
      is: {
        coming: {
          where: 'to town'
        }
      }
    }
  };
  var stringify = build(schema);
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"winter":{"is":{"coming":{"where":"to town"}}}}');
});
test('ref internal - plain name fragment', function (t) {
  t.plan(2);
  var schema = {
    title: 'object with $ref',
    definitions: {
      def: {
        $id: '#uri',
        type: 'object',
        properties: {
          str: {
            type: 'string'
          }
        },
        required: ['str']
      }
    },
    type: 'object',
    properties: {
      obj: {
        $ref: '#uri'
      }
    }
  };
  var object = {
    obj: {
      str: 'test'
    }
  };
  var stringify = build(schema);
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"obj":{"str":"test"}}');
});
test('ref external - plain name fragment', function (t) {
  t.plan(2);
  var externalSchema = {
    first: {
      $id: '#first-schema',
      type: 'object',
      properties: {
        str: {
          type: 'string'
        }
      }
    },
    second: {
      definitions: {
        second: {
          $id: '#second-schema',
          type: 'object',
          properties: {
            "int": {
              type: 'integer'
            }
          }
        }
      }
    }
  };
  var schema = {
    title: 'object with $ref to external plain name fragment',
    type: 'object',
    properties: {
      first: {
        $ref: '#first-schema'
      },
      second: {
        $ref: '#second-schema'
      }
    }
  };
  var object = {
    first: {
      str: 'test'
    },
    second: {
      "int": 42
    }
  };
  var stringify = build(schema, {
    schema: externalSchema
  });
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"first":{"str":"test"},"second":{"int":42}}');
});
test('ref external - duplicate plain name fragment', function (t) {
  t.plan(2);
  var externalSchema = {
    external: {
      $id: '#duplicateSchema',
      type: 'object',
      properties: {
        prop: {
          type: 'boolean'
        }
      }
    },
    other: {
      $id: '#otherSchema',
      type: 'object',
      properties: {
        prop: {
          type: 'integer'
        }
      }
    }
  };
  var schema = {
    title: 'object with $ref to plain name fragment',
    type: 'object',
    definitions: {
      duplicate: {
        $id: '#duplicateSchema',
        type: 'object',
        properties: {
          prop: {
            type: 'string'
          }
        }
      }
    },
    properties: {
      local: {
        $ref: '#duplicateSchema'
      },
      external: {
        $ref: 'external#duplicateSchema'
      },
      other: {
        $ref: '#otherSchema'
      }
    }
  };
  var object = {
    local: {
      prop: 'test'
    },
    external: {
      prop: true
    },
    other: {
      prop: 42
    }
  };
  var stringify = build(schema, {
    schema: externalSchema
  });
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"local":{"prop":"test"},"external":{"prop":true},"other":{"prop":42}}');
});
test('ref external - explicit external plain name fragment must not fallback to other external schemas', function (t) {
  t.plan(1);
  var externalSchema = {
    first: {
      $id: '#target',
      type: 'object',
      properties: {
        prop: {
          type: 'string'
        }
      }
    },
    second: {
      $id: '#wrong',
      type: 'object',
      properties: {
        prop: {
          type: 'integer'
        }
      }
    }
  };
  var schema = {
    title: 'object with $ref to plain name fragment',
    type: 'object',
    definitions: {
      third: {
        $id: '#wrong',
        type: 'object',
        properties: {
          prop: {
            type: 'boolean'
          }
        }
      }
    },
    properties: {
      target: {
        $ref: 'first#wrong'
      }
    }
  };
  var object = {
    target: {
      prop: 'test'
    }
  };

  try {
    var stringify = build(schema, {
      schema: externalSchema
    });
    var output = stringify(object);
    JSON.parse(output);
    t.fail();
  } catch (e) {
    t.pass();
  }
});
test('ref internal - multiple $ref format', function (t) {
  t.plan(2);
  var schema = {
    type: 'object',
    definitions: {
      one: {
        type: 'string',
        definitions: {
          two: {
            $id: '#twos',
            type: 'string'
          }
        }
      }
    },
    properties: {
      zero: {
        $id: '#three',
        type: 'string'
      },
      a: {
        $ref: '#/definitions/one'
      },
      b: {
        $ref: '#three'
      },
      c: {
        $ref: '#/properties/zero'
      },
      d: {
        $ref: '#twos'
      },
      e: {
        $ref: '#/definitions/one/definitions/two'
      }
    }
  };
  var object = {
    zero: 'test',
    a: 'test',
    b: 'test',
    c: 'test',
    d: 'test',
    e: 'test'
  };
  var stringify = build(schema);
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"zero":"test","a":"test","b":"test","c":"test","d":"test","e":"test"}');
});
test('ref in root external', function (t) {
  t.plan(2);
  var externalSchema = {
    numbers: {
      $id: 'numbers',
      definitions: {
        num: {
          type: 'object',
          properties: {
            "int": {
              type: 'integer'
            }
          }
        }
      }
    }
  };
  var schema = {
    title: 'object with $ref in root schema',
    type: 'object',
    $ref: 'numbers#/definitions/num'
  };
  var object = {
    "int": 42
  };
  var stringify = build(schema, {
    schema: externalSchema
  });
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"int":42}');
});
test('ref in root external multiple times', function (t) {
  t.plan(2);
  var externalSchema = {
    numbers: {
      $id: 'numbers',
      $ref: 'subnumbers#/definitions/num'
    },
    subnumbers: {
      $id: 'subnumbers',
      definitions: {
        num: {
          type: 'object',
          properties: {
            "int": {
              type: 'integer'
            }
          }
        }
      }
    }
  };
  var schema = {
    title: 'object with $ref in root schema',
    type: 'object',
    $ref: 'numbers#/definitions/num'
  };
  var object = {
    "int": 42
  };
  var stringify = build(schema, {
    schema: externalSchema
  });
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"int":42}');
});
test('ref external to relative definition', function (t) {
  t.plan(2);
  var externalSchema = {
    'relative:to:local': {
      $id: 'relative:to:local',
      type: 'object',
      properties: {
        foo: {
          $ref: '#/definitions/foo'
        }
      },
      definitions: {
        foo: {
          type: 'string'
        }
      }
    }
  };
  var schema = {
    type: 'object',
    required: ['foo'],
    properties: {
      fooParent: {
        $ref: 'relative:to:local'
      }
    }
  };
  var object = {
    fooParent: {
      foo: 'bar'
    }
  };
  var stringify = build(schema, {
    schema: externalSchema
  });
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"fooParent":{"foo":"bar"}}');
});
test('ref to nested ref definition', function (t) {
  t.plan(2);
  var externalSchema = {
    'a:b:c1': {
      $id: 'a:b:c1',
      type: 'object',
      definitions: {
        foo: {
          $ref: 'a:b:c2#/definitions/foo'
        }
      }
    },
    'a:b:c2': {
      $id: 'a:b:c2',
      type: 'object',
      definitions: {
        foo: {
          type: 'string'
        }
      }
    }
  };
  var schema = {
    type: 'object',
    required: ['foo'],
    properties: {
      foo: {
        $ref: 'a:b:c1#/definitions/foo'
      }
    }
  };
  var object = {
    foo: 'foo'
  };
  var stringify = build(schema, {
    schema: externalSchema
  });
  var output = stringify(object);

  try {
    JSON.parse(output);
    t.pass();
  } catch (e) {
    t.fail();
  }

  t.equal(output, '{"foo":"foo"}');
});