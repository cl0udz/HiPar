'use strict';
/* eslint no-prototype-builtins: 0 */

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-iso-string");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Ajv = require('ajv');

var merge = require('deepmerge');

var util = require('util');

var validate = require('./schema-validator');

var uglify = null;
var isLong;

try {
  isLong = require('long').isLong;
} catch (e) {
  isLong = null;
}

var addComma = "\n  if (addComma) {\n    json += ','\n  }\n  addComma = true\n";

function isValidSchema(schema, name) {
  if (!validate(schema)) {
    if (name) {
      name = "\"".concat(name, "\" ");
    } else {
      name = '';
    }

    var first = validate.errors[0];
    var err = new Error("".concat(name, "schema is invalid: data").concat(first.dataPath, " ").concat(first.message));
    err.errors = isValidSchema.errors;
    throw err;
  }
}

function build(schema, options) {
  options = options || {};
  isValidSchema(schema);

  if (options.schema) {
    for (var _i = 0, _Object$keys = Object.keys(options.schema); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      isValidSchema(options.schema[key], key);
    }
  }
  /* eslint no-new-func: "off" */


  var code = "\n    'use strict'\n  ";
  code += "\n    ".concat($asString.toString(), "\n    ").concat($asStringNullable.toString(), "\n    ").concat($asStringSmall.toString(), "\n    ").concat($asNumber.toString(), "\n    ").concat($asNumberNullable.toString(), "\n    ").concat($asIntegerNullable.toString(), "\n    ").concat($asNull.toString(), "\n    ").concat($asBoolean.toString(), "\n    ").concat($asBooleanNullable.toString(), "\n  "); // only handle longs if the module is used

  if (isLong) {
    code += "\n      var isLong = ".concat(isLong.toString(), "\n      ").concat($asInteger.toString(), "\n    ");
  } else {
    code += "\n      var $asInteger = $asNumber\n    ";
  }

  if (schema.$ref) {
    schema = refFinder(schema.$ref, schema, options.schema);
  }

  if (schema.type === undefined) {
    schema.type = inferTypeByKeyword(schema);
  }

  var hasSchemaSomeIf = hasIf(schema);
  var main;

  switch (schema.type) {
    case 'object':
      main = '$main';
      code = buildObject(schema, code, main, options.schema, schema);
      break;

    case 'string':
      main = schema.nullable ? $asStringNullable.name : $asString.name;
      break;

    case 'integer':
      main = schema.nullable ? $asIntegerNullable.name : $asInteger.name;
      break;

    case 'number':
      main = schema.nullable ? $asNumberNullable.name : $asNumber.name;
      break;

    case 'boolean':
      main = schema.nullable ? $asBooleanNullable.name : $asBoolean.name;
      break;

    case 'null':
      main = $asNull.name;
      break;

    case 'array':
      main = '$main';
      code = buildArray(schema, code, main, options.schema, schema);
      break;

    default:
      throw new Error("".concat(schema.type, " unsupported"));
  }

  code += "\n    ;\n     return ".concat(main, "\n  ");

  if (options.uglify) {
    code = uglifyCode(code);
  }

  var dependencies = [];
  var dependenciesName = [];

  if (hasAnyOf(schema) || hasSchemaSomeIf) {
    dependencies.push(new Ajv(options.ajv));
    dependenciesName.push('ajv');
  }

  dependenciesName.push(code);
  return Function.apply(null, dependenciesName).apply(null, dependencies);
}

var objectKeywords = ['maxProperties', 'minProperties', 'required', 'properties', 'patternProperties', 'additionalProperties', 'dependencies'];
var arrayKeywords = ['items', 'additionalItems', 'maxItems', 'minItems', 'uniqueItems', 'contains'];
var stringKeywords = ['maxLength', 'minLength', 'pattern'];
var numberKeywords = ['multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum'];
/**
 * Infer type based on keyword in order to generate optimized code
 * https://json-schema.org/latest/json-schema-validation.html#rfc.section.6
 */

function inferTypeByKeyword(schema) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = objectKeywords[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var keyword = _step.value;
      if (keyword in schema) return 'object';
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = arrayKeywords[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _keyword = _step2.value;
      if (_keyword in schema) return 'array';
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = stringKeywords[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _keyword2 = _step3.value;
      if (_keyword2 in schema) return 'string';
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = numberKeywords[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _keyword3 = _step4.value;
      if (_keyword3 in schema) return 'number';
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return schema.type;
}

function hasAnyOf(schema) {
  if (!schema) {
    return false;
  }

  if ('anyOf' in schema) {
    return true;
  }

  var objectKeys = Object.keys(schema);

  for (var i = 0; i < objectKeys.length; i++) {
    var value = schema[objectKeys[i]];

    if (_typeof(value) === 'object') {
      if (hasAnyOf(value)) {
        return true;
      }
    }
  }

  return false;
}

function hasIf(schema) {
  var str = JSON.stringify(schema);
  return /"if":{/.test(str) && /"then":{/.test(str);
}

function $asNull() {
  return 'null';
}

function $asInteger(i) {
  if (isLong && isLong(i)) {
    return i.toString();
  } else {
    return $asNumber(i);
  }
}

function $asIntegerNullable(i) {
  return i === null ? null : $asInteger(i);
}

function $asNumber(i) {
  var num = Number(i);

  if (isNaN(num)) {
    return 'null';
  } else {
    return '' + num;
  }
}

function $asNumberNullable(i) {
  return i === null ? null : $asNumber(i);
}

function $asBoolean(bool) {
  return bool && 'true' || 'false'; // eslint-disable-line
}

function $asBooleanNullable(bool) {
  return bool === null ? null : $asBoolean(bool);
}

function $asString(str) {
  if (str instanceof Date) {
    return '"' + str.toISOString() + '"';
  } else if (str === null) {
    return '""';
  } else if (str instanceof RegExp) {
    str = str.source;
  } else if (typeof str !== 'string') {
    str = str.toString();
  }

  if (str.length < 42) {
    return $asStringSmall(str);
  } else {
    return JSON.stringify(str);
  }
}

function $asStringNullable(str) {
  return str === null ? null : $asString(str);
} // magically escape strings for json
// relying on their charCodeAt
// everything below 32 needs JSON.stringify()
// every string that contain surrogate needs JSON.stringify()
// 34 and 92 happens all the time, so we
// have a fast case for them


function $asStringSmall(str) {
  var result = '';
  var last = 0;
  var found = false;
  var surrogateFound = false;
  var l = str.length;
  var point = 255;

  for (var i = 0; i < l && point >= 32; i++) {
    point = str.charCodeAt(i);

    if (point >= 0xD800 && point <= 0xDFFF) {
      // The current character is a surrogate.
      surrogateFound = true;
    }

    if (point === 34 || point === 92) {
      result += str.slice(last, i) + '\\';
      last = i;
      found = true;
    }
  }

  if (!found) {
    result = str;
  } else {
    result += str.slice(last);
  }

  return point < 32 || surrogateFound === true ? JSON.stringify(str) : '"' + result + '"';
}

function addPatternProperties(schema, externalSchema, fullSchema) {
  var pp = schema.patternProperties;
  var code = "\n      var properties = ".concat(JSON.stringify(schema.properties), " || {}\n      var keys = Object.keys(obj)\n      for (var i = 0; i < keys.length; i++) {\n        if (properties[keys[i]]) continue\n  ");
  Object.keys(pp).forEach(function (regex, index) {
    if (pp[regex].$ref) {
      pp[regex] = refFinder(pp[regex].$ref, fullSchema, externalSchema);
    }

    var type = pp[regex].type;
    code += "\n        if (/".concat(regex.replace(/\\*\//g, '\\/'), "/.test(keys[i])) {\n    ");

    if (type === 'object') {
      code += buildObject(pp[regex], '', 'buildObjectPP' + index, externalSchema, fullSchema);
      code += "\n          ".concat(addComma, "\n          json += $asString(keys[i]) + ':' + buildObjectPP").concat(index, "(obj[keys[i]])\n      ");
    } else if (type === 'array') {
      code += buildArray(pp[regex], '', 'buildArrayPP' + index, externalSchema, fullSchema);
      code += "\n          ".concat(addComma, "\n          json += $asString(keys[i]) + ':' + buildArrayPP").concat(index, "(obj[keys[i]])\n      ");
    } else if (type === 'null') {
      code += "\n          ".concat(addComma, "\n          json += $asString(keys[i]) +':null'\n      ");
    } else if (type === 'string') {
      code += "\n          ".concat(addComma, "\n          json += $asString(keys[i]) + ':' + $asString(obj[keys[i]])\n      ");
    } else if (type === 'integer') {
      code += "\n          ".concat(addComma, "\n          json += $asString(keys[i]) + ':' + $asInteger(obj[keys[i]])\n      ");
    } else if (type === 'number') {
      code += "\n          ".concat(addComma, "\n          json += $asString(keys[i]) + ':' + $asNumber(obj[keys[i]])\n      ");
    } else if (type === 'boolean') {
      code += "\n          ".concat(addComma, "\n          json += $asString(keys[i]) + ':' + $asBoolean(obj[keys[i]])\n      ");
    } else {
      code += "\n        throw new Error('Cannot coerce ' + obj[keys[i]] + ' to ".concat(type, "')\n      ");
    }

    code += "\n          continue\n        }\n    ";
  });

  if (schema.additionalProperties) {
    code += additionalProperty(schema, externalSchema, fullSchema);
  }

  code += "\n      }\n  ";
  return code;
}

function additionalProperty(schema, externalSchema, fullSchema) {
  var ap = schema.additionalProperties;
  var code = '';

  if (ap === true) {
    return "\n        if (obj[keys[i]] !== undefined) {\n          ".concat(addComma, "\n          json += $asString(keys[i]) + ':' + JSON.stringify(obj[keys[i]])\n        }\n    ");
  }

  if (ap.$ref) {
    ap = refFinder(ap.$ref, fullSchema, externalSchema);
  }

  var type = ap.type;

  if (type === 'object') {
    code += buildObject(ap, '', 'buildObjectAP', externalSchema);
    code += "\n        ".concat(addComma, "\n        json += $asString(keys[i]) + ':' + buildObjectAP(obj[keys[i]])\n    ");
  } else if (type === 'array') {
    code += buildArray(ap, '', 'buildArrayAP', externalSchema, fullSchema);
    code += "\n        ".concat(addComma, "\n        json += $asString(keys[i]) + ':' + buildArrayAP(obj[keys[i]])\n    ");
  } else if (type === 'null') {
    code += "\n        ".concat(addComma, "\n        json += $asString(keys[i]) +':null'\n    ");
  } else if (type === 'string') {
    code += "\n        ".concat(addComma, "\n        json += $asString(keys[i]) + ':' + $asString(obj[keys[i]])\n    ");
  } else if (type === 'integer') {
    code += "\n        var t = Number(obj[keys[i]])\n    ";

    if (isLong) {
      code += "\n          if (isLong(obj[keys[i]]) || !isNaN(t)) {\n            ".concat(addComma, "\n            json += $asString(keys[i]) + ':' + $asInteger(obj[keys[i]])\n          }\n      ");
    } else {
      code += "\n          if (!isNaN(t)) {\n            ".concat(addComma, "\n            json += $asString(keys[i]) + ':' + t\n          }\n      ");
    }
  } else if (type === 'number') {
    code += "\n        var t = Number(obj[keys[i]])\n        if (!isNaN(t)) {\n          ".concat(addComma, "\n          json += $asString(keys[i]) + ':' + t\n        }\n    ");
  } else if (type === 'boolean') {
    code += "\n        ".concat(addComma, "\n        json += $asString(keys[i]) + ':' + $asBoolean(obj[keys[i]])\n    ");
  } else {
    code += "\n        throw new Error('Cannot coerce ' + obj[keys[i]] + ' to ".concat(type, "')\n    ");
  }

  return code;
}

function addAdditionalProperties(schema, externalSchema, fullSchema) {
  return "\n      var properties = ".concat(JSON.stringify(schema.properties), " || {}\n      var keys = Object.keys(obj)\n      for (var i = 0; i < keys.length; i++) {\n        if (properties[keys[i]]) continue\n        ").concat(additionalProperty(schema, externalSchema, fullSchema), "\n      }\n  ");
}

function idFinder(schema, searchedId) {
  var objSchema;

  var explore = function explore(schema, searchedId) {
    Object.keys(schema || {}).forEach(function (key, i, a) {
      if (key === '$id' && schema[key] === searchedId) {
        objSchema = schema;
      } else if (objSchema === undefined && _typeof(schema[key]) === 'object') {
        explore(schema[key], searchedId);
      }
    });
  };

  explore(schema, searchedId);
  return objSchema;
}

function refFinder(ref, schema, externalSchema) {
  // Split file from walk
  ref = ref.split('#'); // If external file

  if (ref[0]) {
    schema = externalSchema[ref[0]];

    if (schema.$ref) {
      return refFinder(schema.$ref, schema, externalSchema);
    }
  }

  var code = 'return schema'; // If it has a path

  if (ref[1]) {
    // ref[1] could contain a JSON pointer - ex: /definitions/num
    // or plain name fragment id without suffix # - ex: customId
    var walk = ref[1].split('/');

    if (walk.length === 1) {
      var targetId = "#".concat(ref[1]);
      var dereferenced = idFinder(schema, targetId);

      if (dereferenced === undefined && !ref[0]) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(externalSchema); _i2 < _Object$keys2.length; _i2++) {
          var key = _Object$keys2[_i2];
          dereferenced = idFinder(externalSchema[key], targetId);
          if (dereferenced !== undefined) break;
        }
      }

      return dereferenced;
    } else {
      for (var i = 1; i < walk.length; i++) {
        code += "['".concat(sanitizeKey(walk[i]), "']");
      }
    }
  }

  var result = new Function('schema', code)(schema);
  return result.$ref ? refFinder(result.$ref, schema, externalSchema) : result;
}

function sanitizeKey(key) {
  var rep = key.replace(/(\\*)'/g, function (match, p1) {
    var base = '';

    if (p1.length % 2 === 1) {
      base = p1.slice(2);
    } else {
      base = p1;
    }

    var rep = base + '\\\'';
    return rep;
  });
  return rep;
}

function buildCode(schema, code, laterCode, name, externalSchema, fullSchema) {
  Object.keys(schema.properties || {}).forEach(function (key, i, a) {
    if (schema.properties[key].$ref) {
      // if the schema object is deep in the tree, we must resolve the ref in the parent scope
      var isRelative = schema.definitions && schema.properties[key].$ref[0] === '#';
      schema.properties[key] = refFinder(schema.properties[key].$ref, isRelative ? schema : fullSchema, externalSchema);
    } // Using obj['key'] !== undefined instead of obj.hasOwnProperty(prop) for perf reasons,
    // see https://github.com/mcollina/fast-json-stringify/pull/3 for discussion.


    var type = schema.properties[key].type;
    var nullable = schema.properties[key].nullable;
    var sanitized = sanitizeKey(key);
    var asString = sanitizeKey($asString(key).replace(/\\/g, '\\\\'));

    if (nullable) {
      code += "\n        if (obj['".concat(sanitized, "'] === null) {\n          ").concat(addComma, "\n          json += '").concat(asString, ":null'\n          var rendered = true\n        } else {\n      ");
    }

    if (type === 'number') {
      code += "\n          var t = Number(obj['".concat(sanitized, "'])\n          if (!isNaN(t)) {\n            ").concat(addComma, "\n            json += '").concat(asString, ":' + t\n      ");
    } else if (type === 'integer') {
      code += "\n          var rendered = false\n      ";

      if (isLong) {
        code += "\n            if (isLong(obj['".concat(sanitized, "'])) {\n              ").concat(addComma, "\n              json += '").concat(asString, ":' + obj['").concat(sanitized, "'].toString()\n              rendered = true\n            } else {\n              var t = Number(obj['").concat(sanitized, "'])\n              if (!isNaN(t)) {\n                ").concat(addComma, "\n                json += '").concat(asString, ":' + t\n                rendered = true\n              }\n            }\n        ");
      } else {
        code += "\n            var t = Number(obj['".concat(sanitized, "'])\n            if (!isNaN(t)) {\n              ").concat(addComma, "\n              json += '").concat(asString, ":' + t\n              rendered = true\n            }\n        ");
      }

      code += "\n          if (rendered) {\n      ";
    } else {
      code += "\n        if (obj['".concat(sanitized, "'] !== undefined) {\n          ").concat(addComma, "\n          json += '").concat(asString, ":'\n        ");
      var result = nested(laterCode, name, key, schema.properties[key], externalSchema, fullSchema);
      code += result.code;
      laterCode = result.laterCode;
    }

    var defaultValue = schema.properties[key]["default"];

    if (defaultValue !== undefined) {
      code += "\n      } else {\n        ".concat(addComma, "\n        json += '").concat(asString, ":").concat(sanitizeKey(JSON.stringify(defaultValue).replace(/\\/g, '\\\\')), "'\n      ");
    } else if (schema.required && schema.required.indexOf(key) !== -1) {
      code += "\n      } else {\n        throw new Error('".concat(sanitized, " is required!')\n      ");
    }

    code += "\n      }\n    ";

    if (nullable) {
      code += "\n        }\n      ";
    }
  });
  return {
    code: code,
    laterCode: laterCode
  };
}

function buildCodeWithAllOfs(schema, code, laterCode, name, externalSchema, fullSchema) {
  if (schema.allOf) {
    schema.allOf.forEach(function (ss) {
      var builtCode = buildCodeWithAllOfs(ss, code, laterCode, name, externalSchema, fullSchema);
      code = builtCode.code;
      laterCode = builtCode.laterCode;
    });
  } else {
    var builtCode = buildCode(schema, code, laterCode, name, externalSchema, fullSchema);
    code = builtCode.code;
    laterCode = builtCode.laterCode;
  }

  return {
    code: code,
    laterCode: laterCode
  };
}

function buildInnerObject(schema, name, externalSchema, fullSchema) {
  var laterCode = '';
  var code = '';

  if (schema.patternProperties) {
    code += addPatternProperties(schema, externalSchema, fullSchema);
  } else if (schema.additionalProperties && !schema.patternProperties) {
    code += addAdditionalProperties(schema, externalSchema, fullSchema);
  }

  return buildCodeWithAllOfs(schema, code, laterCode, name, externalSchema, fullSchema);
}

function addIfThenElse(schema, name, externalSchema, fullSchema) {
  var code = '';
  var r;
  var laterCode = '';
  var innerR;
  var copy = merge({}, schema);
  var i = copy["if"];
  var then = copy.then;
  var e = copy["else"];
  delete copy["if"];
  delete copy.then;
  delete copy["else"];
  var merged = merge(copy, then);
  code += "\n    valid = ajv.validate(".concat(util.inspect(i, {
    depth: null
  }), ", obj)\n    if (valid) {\n  ");

  if (merged["if"] && merged.then) {
    innerR = addIfThenElse(merged, name + 'Then', externalSchema, fullSchema);
    code += innerR.code;
    laterCode = innerR.laterCode;
  }

  r = buildInnerObject(merged, name + 'Then', externalSchema, fullSchema);
  code += r.code;
  laterCode += r.laterCode;
  code += "\n    }\n  ";

  if (e) {
    merged = merge(copy, e);
    code += "\n      else {\n    ";

    if (merged["if"] && merged.then) {
      innerR = addIfThenElse(merged, name + 'Else', externalSchema, fullSchema);
      code += innerR.code;
      laterCode += innerR.laterCode;
    }

    r = buildInnerObject(merged, name + 'Else', externalSchema, fullSchema);
    code += r.code;
    laterCode += r.laterCode;
    code += "\n      }\n    ";
  }

  return {
    code: code,
    laterCode: laterCode
  };
}

function toJSON(variableName) {
  return "typeof ".concat(variableName, ".toJSON === 'function'\n    ? ").concat(variableName, ".toJSON()\n    : ").concat(variableName, "\n  ");
}

function buildObject(schema, code, name, externalSchema, fullSchema) {
  code += "\n    function ".concat(name, " (input) {\n  ");

  if (schema.nullable) {
    code += "\n      if(input === null) {\n        return '".concat($asNull(), "';\n      }\n  ");
  }

  code += "\n      var obj = ".concat(toJSON('input'), "\n      var json = '{'\n      var addComma = false\n  ");
  var laterCode = '';
  var r;

  if (schema["if"] && schema.then) {
    code += "\n      var valid\n    ";
    r = addIfThenElse(schema, name, externalSchema, fullSchema);
  } else {
    r = buildInnerObject(schema, name, externalSchema, fullSchema);
  }

  code += r.code;
  laterCode = r.laterCode; // Removes the comma if is the last element of the string (in case there are not properties)

  code += "\n      json += '}'\n      return json\n    }\n  ";
  code += laterCode;
  return code;
}

function buildArray(schema, code, name, externalSchema, fullSchema) {
  code += "\n    function ".concat(name, " (obj) {\n  ");

  if (schema.nullable) {
    code += "\n      if(obj === null) {\n        return '".concat($asNull(), "';\n      }\n    ");
  }

  code += "\n      var json = '['\n  ";
  var laterCode = '';

  if (schema.items.$ref) {
    schema.items = refFinder(schema.items.$ref, fullSchema, externalSchema);
  }

  var result = {
    code: '',
    laterCode: ''
  };

  if (Array.isArray(schema.items)) {
    result = schema.items.reduce(function (res, item, i) {
      var accessor = '[i]';
      var tmpRes = nested(laterCode, name, accessor, item, externalSchema, fullSchema, i);
      var condition = "i === ".concat(i, " && ").concat(buildArrayTypeCondition(item.type, accessor));
      return {
        code: "".concat(res.code, "\n        ").concat(i > 0 ? 'else' : '', " if (").concat(condition, ") {\n          ").concat(tmpRes.code, "\n        }"),
        laterCode: "".concat(res.laterCode, "\n        ").concat(tmpRes.laterCode)
      };
    }, result);
    result.code += "\n    else {\n      throw new Error(`Item at ${i} does not match schema definition.`)\n    }\n    ";
  } else {
    result = nested(laterCode, name, '[i]', schema.items, externalSchema, fullSchema);
  }

  code += "\n    var l = obj.length\n    var w = l - 1\n    for (var i = 0; i < l; i++) {\n      if (i > 0) {\n        json += ','\n      }\n      ".concat(result.code, "\n    }\n  ");
  laterCode = result.laterCode;
  code += "\n      json += ']'\n      return json\n    }\n  ";
  code += laterCode;
  return code;
}

function buildArrayTypeCondition(type, accessor) {
  var condition;

  switch (type) {
    case 'null':
      condition = "obj".concat(accessor, " === null");
      break;

    case 'string':
      condition = "typeof obj".concat(accessor, " === 'string'");
      break;

    case 'integer':
      condition = "Number.isInteger(obj".concat(accessor, ")");
      break;

    case 'number':
      condition = "Number.isFinite(obj".concat(accessor, ")");
      break;

    case 'boolean':
      condition = "typeof obj".concat(accessor, " === 'boolean'");
      break;

    case 'object':
      condition = "obj".concat(accessor, " && typeof obj").concat(accessor, " === 'object' && obj").concat(accessor, ".constructor === Object");
      break;

    case 'array':
      condition = "Array.isArray(obj".concat(accessor, ")");
      break;

    default:
      if (Array.isArray(type)) {
        var conditions = type.map(function (subType) {
          return buildArrayTypeCondition(subType, accessor);
        });
        condition = "(".concat(conditions.join(' || '), ")");
      } else {
        throw new Error("".concat(type, " unsupported"));
      }

  }

  return condition;
}

function nested(laterCode, name, key, schema, externalSchema, fullSchema, subKey) {
  var code = '';
  var funcName;
  subKey = subKey || '';

  if (schema.type === undefined) {
    var inferedType = inferTypeByKeyword(schema);

    if (inferedType) {
      schema.type = inferedType;
    }
  }

  var type = schema.type;
  var nullable = schema.nullable === true;
  var accessor = key.indexOf('[') === 0 ? sanitizeKey(key) : "['".concat(sanitizeKey(key), "']");

  switch (type) {
    case 'null':
      code += "\n        json += $asNull()\n      ";
      break;

    case 'string':
      code += nullable ? "json += obj".concat(accessor, " === null ? null : $asString(obj").concat(accessor, ")") : "json += $asString(obj".concat(accessor, ")");
      break;

    case 'integer':
      code += nullable ? "json += obj".concat(accessor, " === null ? null : $asInteger(obj").concat(accessor, ")") : "json += $asInteger(obj".concat(accessor, ")");
      break;

    case 'number':
      code += nullable ? "json += obj".concat(accessor, " === null ? null : $asNumber(obj").concat(accessor, ")") : "json += $asNumber(obj".concat(accessor, ")");
      break;

    case 'boolean':
      code += nullable ? "json += obj".concat(accessor, " === null ? null : $asBoolean(obj").concat(accessor, ")") : "json += $asBoolean(obj".concat(accessor, ")");
      break;

    case 'object':
      funcName = (name + key + subKey).replace(/[-.\[\] ]/g, ''); // eslint-disable-line

      laterCode = buildObject(schema, laterCode, funcName, externalSchema, fullSchema);
      code += "\n        json += ".concat(funcName, "(obj").concat(accessor, ")\n      ");
      break;

    case 'array':
      funcName = '$arr' + (name + key + subKey).replace(/[-.\[\] ]/g, ''); // eslint-disable-line

      laterCode = buildArray(schema, laterCode, funcName, externalSchema, fullSchema);
      code += "\n        json += ".concat(funcName, "(obj").concat(accessor, ")\n      ");
      break;

    case undefined:
      if ('anyOf' in schema) {
        schema.anyOf.forEach(function (s, index) {
          var nestedResult = nested(laterCode, name, key, s, externalSchema, fullSchema, subKey !== '' ? subKey : 'i' + index);
          code += "\n            ".concat(index === 0 ? 'if' : 'else if', "(ajv.validate(").concat(require('util').inspect(s, {
            depth: null
          }), ", obj").concat(accessor, "))\n              ").concat(nestedResult.code, "\n          ");
          laterCode = nestedResult.laterCode;
        });
        code += "\n          else json+= null\n        ";
      } else if (isEmpty(schema)) {
        code += "\n          json += JSON.stringify(obj".concat(accessor, ")\n        ");
      } else {
        throw new Error("".concat(schema.type, " unsupported"));
      }

      break;

    default:
      if (Array.isArray(type)) {
        var nullIndex = type.indexOf('null');
        var sortedTypes = nullIndex !== -1 ? [type[nullIndex]].concat(type.slice(0, nullIndex)).concat(type.slice(nullIndex + 1)) : type;
        sortedTypes.forEach(function (type, index) {
          var tempSchema = Object.assign({}, schema, {
            type: type
          });
          var nestedResult = nested(laterCode, name, key, tempSchema, externalSchema, fullSchema, subKey);

          if (type === 'string') {
            code += "\n              ".concat(index === 0 ? 'if' : 'else if', "(typeof obj").concat(accessor, " === \"").concat(type, "\" || obj").concat(accessor, " instanceof Date || obj").concat(accessor, " instanceof RegExp)\n                ").concat(nestedResult.code, "\n            ");
          } else if (type === 'null') {
            code += "\n              ".concat(index === 0 ? 'if' : 'else if', "(obj").concat(accessor, " == null)\n              ").concat(nestedResult.code, "\n            ");
          } else if (type === 'array') {
            code += "\n              ".concat(index === 0 ? 'if' : 'else if', "(Array.isArray(obj").concat(accessor, "))\n              ").concat(nestedResult.code, "\n            ");
          } else if (type === 'integer') {
            code += "\n              ".concat(index === 0 ? 'if' : 'else if', "(Number.isInteger(obj").concat(accessor, ") || obj").concat(accessor, " === null)\n              ").concat(nestedResult.code, "\n            ");
          } else if (type === 'number') {
            code += "\n              ".concat(index === 0 ? 'if' : 'else if', "(isNaN(obj").concat(accessor, ") === false)\n              ").concat(nestedResult.code, "\n            ");
          } else {
            code += "\n              ".concat(index === 0 ? 'if' : 'else if', "(typeof obj").concat(accessor, " === \"").concat(type, "\")\n              ").concat(nestedResult.code, "\n            ");
          }

          laterCode = nestedResult.laterCode;
        });
        code += "\n          else json+= null\n        ";
      } else {
        throw new Error("".concat(type, " unsupported"));
      }

  }

  return {
    code: code,
    laterCode: laterCode
  };
}

function uglifyCode(code) {
  if (!uglify) {
    loadUglify();
  }

  var uglified = uglify.minify(code, {
    parse: {
      bare_returns: true
    }
  });

  if (uglified.error) {
    throw uglified.error;
  }

  return uglified.code;
}

function loadUglify() {
  try {
    uglify = require('uglify-es');

    var uglifyVersion = require('uglify-es/package.json').version;

    if (uglifyVersion[0] !== '3') {
      throw new Error('Only version 3 of uglify-es is supported');
    }
  } catch (e) {
    uglify = null;

    if (e.code === 'MODULE_NOT_FOUND') {
      throw new Error('In order to use uglify, you have to manually install `uglify-es`');
    }

    throw e;
  }
}

function isEmpty(schema) {
  for (var key in schema) {
    if (schema.hasOwnProperty(key)) return false;
  }

  return true;
}

module.exports = build;