'use strict';

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.fill");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.join");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/web.immediate");

require("core-js/modules/web.timers");

var _require = require('tap'),
    test = _require.test,
    tearDown = _require.tearDown;

var _require2 = require('path'),
    join = _require2.join;

var _require3 = require('child_process'),
    fork = _require3.fork;

var fs = require('fs');

var os = require('os');

var path = require('path');

var proxyquire = require('proxyquire');

var SonicBoom = require('.');

var files = [];
var count = 0;

function file() {
  var file = path.join(os.tmpdir(), "sonic-boom-".concat(process.pid, "-").concat(process.hrtime().toString(), "-").concat(count++));
  files.push(file);
  return file;
}

tearDown(function () {
  files.forEach(function (file) {
    try {
      fs.unlinkSync(file);
    } catch (e) {
      console.log(e);
    }
  });
});
test('sync false', function (t) {
  buildTests(t.test, false);
  t.end();
});
test('sync true', function (t) {
  buildTests(t.test, true);
  t.end();
});

function buildTests(test, sync) {
  test('write things to a file descriptor', function (t) {
    t.plan(6);
    var dest = file();
    var fd = fs.openSync(dest, 'w');
    var stream = new SonicBoom(fd, 0, sync);
    stream.on('ready', function () {
      t.pass('ready emitted');
    });
    t.ok(stream.write('hello world\n'));
    t.ok(stream.write('something else\n'));
    stream.end();
    stream.on('finish', function () {
      fs.readFile(dest, 'utf8', function (err, data) {
        t.error(err);
        t.equal(data, 'hello world\nsomething else\n');
      });
    });
    stream.on('close', function () {
      t.pass('close emitted');
    });
  });
  test('write things in a streaming fashion', function (t) {
    t.plan(8);
    var dest = file();
    var fd = fs.openSync(dest, 'w');
    var stream = new SonicBoom(fd, 0, sync);
    t.ok(stream.write('hello world\n'));
    stream.once('drain', function () {
      fs.readFile(dest, 'utf8', function (err, data) {
        t.error(err);
        t.equal(data, 'hello world\n');
        t.ok(stream.write('something else\n'));
      });
      stream.once('drain', function () {
        fs.readFile(dest, 'utf8', function (err, data) {
          t.error(err);
          t.equal(data, 'hello world\nsomething else\n');
          stream.end();
        });
      });
    });
    stream.on('finish', function () {
      t.pass('finish emitted');
    });
    stream.on('close', function () {
      t.pass('close emitted');
    });
  });
  test('can be piped into', function (t) {
    t.plan(4);
    var dest = file();
    var fd = fs.openSync(dest, 'w');
    var stream = new SonicBoom(fd, 0, sync);
    var source = fs.createReadStream(__filename);
    source.pipe(stream);
    stream.on('finish', function () {
      fs.readFile(__filename, 'utf8', function (err, expected) {
        t.error(err);
        fs.readFile(dest, 'utf8', function (err, data) {
          t.error(err);
          t.equal(data, expected);
        });
      });
    });
    stream.on('close', function () {
      t.pass('close emitted');
    });
  });
  test('write things to a file', function (t) {
    t.plan(6);
    var dest = file();
    var stream = new SonicBoom(dest, 0, sync);
    stream.on('ready', function () {
      t.pass('ready emitted');
    });
    t.ok(stream.write('hello world\n'));
    t.ok(stream.write('something else\n'));
    stream.end();
    stream.on('finish', function () {
      fs.readFile(dest, 'utf8', function (err, data) {
        t.error(err);
        t.equal(data, 'hello world\nsomething else\n');
      });
    });
    stream.on('close', function () {
      t.pass('close emitted');
    });
  });
  test('flushSync', function (t) {
    t.plan(4);
    var dest = file();
    var fd = fs.openSync(dest, 'w');
    var stream = new SonicBoom(fd, 4096, sync);
    t.ok(stream.write('hello world\n'));
    t.ok(stream.write('something else\n'));
    stream.flushSync(); // let the file system settle down things

    setImmediate(function () {
      stream.end();
      var data = fs.readFileSync(dest, 'utf8');
      t.equal(data, 'hello world\nsomething else\n');
      stream.on('close', function () {
        t.pass('close emitted');
      });
    });
  });
  test('destroy', function (t) {
    t.plan(5);
    var dest = file();
    var fd = fs.openSync(dest, 'w');
    var stream = new SonicBoom(fd, 0, sync);
    t.ok(stream.write('hello world\n'));
    stream.destroy();
    t["throws"](function () {
      stream.write('hello world\n');
    });
    fs.readFile(dest, 'utf8', function (err, data) {
      t.error(err);
      t.equal(data, 'hello world\n');
    });
    stream.on('finish', function () {
      t.fail('finish emitted');
    });
    stream.on('close', function () {
      t.pass('close emitted');
    });
  });
  test('destroy while opening', function (t) {
    t.plan(1);
    var dest = file();
    var stream = new SonicBoom(dest);
    stream.destroy();
    stream.on('close', function () {
      t.pass('close emitted');
    });
  });
  test('minLength', function (t) {
    t.plan(8);
    var dest = file();
    var stream = new SonicBoom(dest, 4096, sync);
    stream.on('ready', function () {
      t.pass('ready emitted');
    });
    t.ok(stream.write('hello world\n'));
    t.ok(stream.write('something else\n'));
    var fail = t.fail;
    stream.on('drain', fail); // bad use of timer
    // TODO refactor

    setTimeout(function () {
      fs.readFile(dest, 'utf8', function (err, data) {
        t.error(err);
        t.equal(data, '');
        stream.end();
        stream.on('finish', function () {
          fs.readFile(dest, 'utf8', function (err, data) {
            t.error(err);
            t.equal(data, 'hello world\nsomething else\n');
          });
        });
      });
    }, 100);
    stream.on('close', function () {
      t.pass('close emitted');
    });
  });
  test('flush', function (t) {
    t.plan(5);
    var dest = file();
    var fd = fs.openSync(dest, 'w');
    var stream = new SonicBoom(fd, 4096, sync);
    stream.on('ready', function () {
      t.pass('ready emitted');
    });
    t.ok(stream.write('hello world\n'));
    t.ok(stream.write('something else\n'));
    stream.flush();
    stream.on('drain', function () {
      fs.readFile(dest, 'utf8', function (err, data) {
        t.error(err);
        t.equal(data, 'hello world\nsomething else\n');
        stream.end();
      });
    });
  });
  test('reopen', function (t) {
    t.plan(9);
    var dest = file();
    var stream = new SonicBoom(dest, 0, sync);
    t.ok(stream.write('hello world\n'));
    t.ok(stream.write('something else\n'));
    var after = dest + '-moved';
    stream.once('drain', function () {
      t.pass('drain emitted');
      fs.renameSync(dest, after);
      stream.reopen();
      stream.once('ready', function () {
        t.pass('ready emitted');
        t.ok(stream.write('after reopen\n'));
        stream.on('drain', function () {
          fs.readFile(after, 'utf8', function (err, data) {
            t.error(err);
            t.equal(data, 'hello world\nsomething else\n');
            fs.readFile(dest, 'utf8', function (err, data) {
              t.error(err);
              t.equal(data, 'after reopen\n');
              stream.end();
            });
          });
        });
      });
    });
  });
  test('reopen with buffer', function (t) {
    t.plan(9);
    var dest = file();
    var stream = new SonicBoom(dest, 4096, sync);
    t.ok(stream.write('hello world\n'));
    t.ok(stream.write('something else\n'));
    var after = dest + '-moved';
    stream.once('ready', function () {
      t.pass('drain emitted');
      stream.flush();
      fs.renameSync(dest, after);
      stream.reopen();
      stream.once('ready', function () {
        t.pass('ready emitted');
        t.ok(stream.write('after reopen\n'));
        stream.flush();
        stream.on('drain', function () {
          fs.readFile(after, 'utf8', function (err, data) {
            t.error(err);
            t.equal(data, 'hello world\nsomething else\n');
            fs.readFile(dest, 'utf8', function (err, data) {
              t.error(err);
              t.equal(data, 'after reopen\n');
              stream.end();
            });
          });
        });
      });
    });
  });
  test('reopen if not open', function (t) {
    t.plan(3);
    var dest = file();
    var stream = new SonicBoom(dest, 0, sync);
    t.ok(stream.write('hello world\n'));
    t.ok(stream.write('something else\n'));
    stream.reopen();
    stream.end();
    stream.on('close', function () {
      t.pass('ended');
    });
  });
  test('end after reopen', function (t) {
    t.plan(4);
    var dest = file();
    var stream = new SonicBoom(dest, 4096, sync);
    stream.once('ready', function () {
      t.pass('ready emitted');
      var after = dest + '-moved';
      stream.reopen(after);
      stream.write('after reopen\n');
      stream.on('finish', function () {
        t.pass('finish emitted');
        fs.readFile(after, 'utf8', function (err, data) {
          t.error(err);
          t.equal(data, 'after reopen\n');
        });
      });
      stream.end();
    });
  });
  test('end after 2x reopen', function (t) {
    t.plan(4);
    var dest = file();
    var stream = new SonicBoom(dest, 4096, sync);
    stream.once('ready', function () {
      t.pass('ready emitted');
      stream.reopen(dest + '-moved');
      var after = dest + '-moved-moved';
      stream.reopen(after);
      stream.write('after reopen\n');
      stream.on('finish', function () {
        t.pass('finish emitted');
        fs.readFile(after, 'utf8', function (err, data) {
          t.error(err);
          t.equal(data, 'after reopen\n');
        });
      });
      stream.end();
    });
  });
  test('end if not ready', function (t) {
    t.plan(3);
    var dest = file();
    var stream = new SonicBoom(dest, 4096, sync);
    var after = dest + '-moved';
    stream.reopen(after);
    stream.write('after reopen\n');
    stream.on('finish', function () {
      t.pass('finish emitted');
      fs.readFile(after, 'utf8', function (err, data) {
        t.error(err);
        t.equal(data, 'after reopen\n');
      });
    });
    stream.end();
  });
  test('reopen with file', function (t) {
    t.plan(9);
    var dest = file();
    var stream = new SonicBoom(dest, 0, sync);
    t.ok(stream.write('hello world\n'));
    t.ok(stream.write('something else\n'));
    var after = dest + '-new';
    stream.once('drain', function () {
      t.pass('drain emitted');
      stream.reopen(after);
      stream.once('ready', function () {
        t.pass('ready emitted');
        t.ok(stream.write('after reopen\n'));
        stream.on('drain', function () {
          fs.readFile(dest, 'utf8', function (err, data) {
            t.error(err);
            t.equal(data, 'hello world\nsomething else\n');
            fs.readFile(after, 'utf8', function (err, data) {
              t.error(err);
              t.equal(data, 'after reopen\n');
              stream.end();
            });
          });
        });
      });
    });
  });
  test('chunk data accordingly', function (t) {
    t.plan(2);
    var child = fork(join(__dirname, 'fixtures', 'firehose.js'), {
      silent: true
    });
    var str = Buffer.alloc(10000).fill('a').toString();
    var data = '';
    child.stdout.on('data', function (chunk) {
      data += chunk.toString();
    });
    child.stdout.on('end', function () {
      t.is(data, str);
    });
    child.on('close', function (code) {
      t.is(code, 0);
    });
  });
}

test('retry on EAGAIN', function (t) {
  t.plan(7);
  var fakeFs = Object.create(fs);

  fakeFs.write = function (fd, buf, enc, cb) {
    t.pass('fake fs.write called');
    fakeFs.write = fs.write;
    var err = new Error('EAGAIN');
    err.code = 'EAGAIN';
    process.nextTick(cb, err);
  };

  var SonicBoom = proxyquire('.', {
    fs: fakeFs
  });
  var dest = file();
  var fd = fs.openSync(dest, 'w');
  var stream = new SonicBoom(fd, 0, false);
  stream.on('ready', function () {
    t.pass('ready emitted');
  });
  t.ok(stream.write('hello world\n'));
  t.ok(stream.write('something else\n'));
  stream.end();
  stream.on('finish', function () {
    fs.readFile(dest, 'utf8', function (err, data) {
      t.error(err);
      t.equal(data, 'hello world\nsomething else\n');
    });
  });
  stream.on('close', function () {
    t.pass('close emitted');
  });
});
test('write buffers that are not totally written', function (t) {
  t.plan(9);
  var fakeFs = Object.create(fs);

  fakeFs.write = function (fd, buf, enc, cb) {
    t.pass('fake fs.write called');

    fakeFs.write = function (fd, buf, enc, cb) {
      t.pass('calling real fs.write, ' + buf);
      fs.write(fd, buf, enc, cb);
    };

    process.nextTick(cb, null, 0);
  };

  var SonicBoom = proxyquire('.', {
    fs: fakeFs
  });
  var dest = file();
  var fd = fs.openSync(dest, 'w');
  var stream = new SonicBoom(fd, 0, false);
  stream.on('ready', function () {
    t.pass('ready emitted');
  });
  t.ok(stream.write('hello world\n'));
  t.ok(stream.write('something else\n'));
  stream.end();
  stream.on('finish', function () {
    fs.readFile(dest, 'utf8', function (err, data) {
      t.error(err);
      t.equal(data, 'hello world\nsomething else\n');
    });
  });
  stream.on('close', function () {
    t.pass('close emitted');
  });
});
test('write buffers that are not totally written with sync mode', function (t) {
  t.plan(9);
  var fakeFs = Object.create(fs);

  fakeFs.writeSync = function (fd, buf, enc) {
    t.pass('fake fs.write called');

    fakeFs.writeSync = function (fd, buf, enc) {
      t.pass('calling real fs.writeSync, ' + buf);
      return fs.writeSync(fd, buf, enc);
    };

    return 0;
  };

  var SonicBoom = proxyquire('.', {
    fs: fakeFs
  });
  var dest = file();
  var fd = fs.openSync(dest, 'w');
  var stream = new SonicBoom(fd, 0, true);
  stream.on('ready', function () {
    t.pass('ready emitted');
  });
  t.ok(stream.write('hello world\n'));
  t.ok(stream.write('something else\n'));
  stream.end();
  stream.on('finish', function () {
    fs.readFile(dest, 'utf8', function (err, data) {
      t.error(err);
      t.equal(data, 'hello world\nsomething else\n');
    });
  });
  stream.on('close', function () {
    t.pass('close emitted');
  });
});
test('sync writing is fully sync', function (t) {
  t.plan(6);
  var fakeFs = Object.create(fs);

  fakeFs.writeSync = function (fd, buf, enc, cb) {
    t.pass('fake fs.write called');
    return fs.writeSync(fd, buf, enc);
  };

  var SonicBoom = proxyquire('.', {
    fs: fakeFs
  });
  var dest = file();
  var fd = fs.openSync(dest, 'w');
  var stream = new SonicBoom(fd, 0, true);
  t.ok(stream.write('hello world\n'));
  t.ok(stream.write('something else\n')); // 'drain' will be only emitted once,
  // the number of assertions at the top check this.

  stream.on('drain', function () {
    t.pass('drain emitted');
  });
  var data = fs.readFileSync(dest, 'utf8');
  t.equal(data, 'hello world\nsomething else\n');
}); // These they will fail on Node 6, as we cannot allocate a string this
// big. It's considered a won't fix on Node 6, as it's deprecated.

if (process.versions.node.indexOf('6.') !== 0) {
  test('write enormously large buffers async', function (t) {
    t.plan(3);
    var dest = file();
    var fd = fs.openSync(dest, 'w');
    var stream = new SonicBoom(fd, 0, false);
    var buf = Buffer.alloc(1024).fill('x').toString(); // 1 MB

    var length = 0;

    for (var i = 0; i < 1024 * 1024; i++) {
      length += buf.length;
      stream.write(buf);
    }

    stream.end();
    stream.on('finish', function () {
      fs.stat(dest, function (err, stat) {
        t.error(err);
        t.equal(stat.size, length);
      });
    });
    stream.on('close', function () {
      t.pass('close emitted');
    });
  });
  test('write enormously large buffers sync', function (t) {
    t.plan(3);
    var dest = file();
    var fd = fs.openSync(dest, 'w');
    var stream = new SonicBoom(fd, 0, true);
    var buf = Buffer.alloc(1024).fill('x').toString(); // 1 MB

    var length = 0;

    for (var i = 0; i < 1024 * 1024; i++) {
      length += buf.length;
      stream.write(buf);
    }

    stream.end();
    stream.on('finish', function () {
      fs.stat(dest, function (err, stat) {
        t.error(err);
        t.equal(stat.size, length);
      });
    });
    stream.on('close', function () {
      t.pass('close emitted');
    });
  });
}

test('write enormously large buffers sync with utf8 multi-byte split', function (t) {
  t.plan(4);
  var dest = file();
  var fd = fs.openSync(dest, 'w');
  var stream = new SonicBoom(fd, 0, true);
  var buf = Buffer.alloc(1024 * 16 - 2).fill('x'); // 16MB - 3B

  var length = buf.length + 4;
  buf = buf.toString() + '🌲'; // 16 MB + 1B

  stream.write(buf);
  stream.end();
  stream.on('finish', function () {
    fs.stat(dest, function (err, stat) {
      t.error(err);
      t.equal(stat.size, length);

      var _char = Buffer.alloc(4);

      var fd = fs.openSync(dest, 'r');
      fs.readSync(fd, _char, 0, 4, length - 4);
      t.equal(_char.toString(), '🌲');
    });
  });
  stream.on('close', function () {
    t.pass('close emitted');
  });
});