'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof3 = function _typeof3(obj) { return typeof obj; }; } else { _typeof3 = function _typeof3(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof3(obj); }

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = {
  groupRedact: groupRedact,
  groupRestore: groupRestore,
  nestedRedact: nestedRedact,
  nestedRestore: nestedRestore
};

function groupRestore(_ref) {
  var keys = _ref.keys,
      values = _ref.values,
      target = _ref.target;
  if (target == null) return;
  var length = keys.length;

  for (var i = 0; i < length; i++) {
    var k = keys[i];
    target[k] = values[i];
  }
}

function groupRedact(o, path, censor, isCensorFct) {
  var target = get(o, path);
  if (target == null) return {
    keys: null,
    values: null,
    target: null,
    flat: true
  };
  var keys = Object.keys(target);
  var length = keys.length;
  var values = new Array(length);

  for (var i = 0; i < length; i++) {
    var k = keys[i];
    values[i] = target[k];
    target[k] = isCensorFct ? censor(target[k]) : censor;
  }

  return {
    keys: keys,
    values: values,
    target: target,
    flat: true
  };
}

function nestedRestore(arr) {
  var length = arr.length;

  for (var i = 0; i < length; i++) {
    var _arr$i = arr[i],
        key = _arr$i.key,
        target = _arr$i.target,
        value = _arr$i.value;
    target[key] = value;
  }
}

function nestedRedact(store, o, path, ns, censor, isCensorFct) {
  var target = get(o, path);
  if (target == null) return;
  var keys = Object.keys(target);
  var length = keys.length;

  for (var i = 0; i < length; i++) {
    var key = keys[i];

    var _specialSet = specialSet(target, key, ns, censor, isCensorFct),
        value = _specialSet.value,
        parent = _specialSet.parent,
        exists = _specialSet.exists;

    if (exists === true && parent !== null) {
      store.push({
        key: ns[ns.length - 1],
        target: parent,
        value: value
      });
    }
  }

  return store;
}

function has(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function specialSet(o, k, p, v, f) {
  var i = -1;
  var l = p.length;
  var li = l - 1;
  var n;
  var nv;
  var ov;
  var oov = null;
  var exists = true;
  ov = n = o[k];
  if (_typeof(n) !== 'object') return {
    value: null,
    parent: null,
    exists: exists
  };

  while (n != null && ++i < l) {
    k = p[i];
    oov = ov;

    if (!(k in n)) {
      exists = false;
      break;
    }

    ov = n[k];
    nv = f ? v(ov) : v;
    nv = i !== li ? ov : nv;
    n[k] = has(n, k) && nv === ov || nv === undefined && v !== undefined ? n[k] : nv;
    n = n[k];
    if (_typeof(n) !== 'object') break;
  }

  return {
    value: ov,
    parent: oov,
    exists: exists
  };
}

function get(o, p) {
  var i = -1;
  var l = p.length;
  var n = o;

  while (n != null && ++i < l) {
    n = n[p[i]];
  }

  return n;
}