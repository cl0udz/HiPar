'use strict';

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.function.bind");

require("core-js/modules/es.object.keys");

var _require = require('./modifiers'),
    groupRestore = _require.groupRestore,
    nestedRestore = _require.nestedRestore;

module.exports = restorer;

function restorer(_ref) {
  var secret = _ref.secret,
      wcLen = _ref.wcLen;
  return function compileRestore() {
    if (this.restore) return;
    var paths = Object.keys(secret).filter(function (path) {
      return secret[path].precensored === false;
    });
    var resetters = resetTmpl(secret, paths);
    var hasWildcards = wcLen > 0;
    var state = hasWildcards ? {
      secret: secret,
      groupRestore: groupRestore,
      nestedRestore: nestedRestore
    } : {
      secret: secret
    };
    /* eslint-disable-next-line */

    this.restore = Function('o', restoreTmpl(resetters, paths, hasWildcards)).bind(state);
  };
}
/**
 * Mutates the original object to be censored by restoring its original values
 * prior to censoring.
 *
 * @param {object} secret Compiled object describing which target fields should
 * be censored and the field states.
 * @param {string[]} paths The list of paths to censor as provided at
 * initialization time.
 *
 * @returns {string} String of JavaScript to be used by `Function()`. The
 * string compiles to the function that does the work in the description.
 */


function resetTmpl(secret, paths) {
  return paths.map(function (path) {
    var _secret$path = secret[path],
        circle = _secret$path.circle,
        escPath = _secret$path.escPath,
        leadingBracket = _secret$path.leadingBracket;
    var delim = leadingBracket ? '' : '.';
    var reset = circle ? "o.".concat(circle, " = secret[").concat(escPath, "].val") : "o".concat(delim).concat(path, " = secret[").concat(escPath, "].val");
    var clear = "secret[".concat(escPath, "].val = undefined");
    return "\n      if (secret[".concat(escPath, "].val !== undefined) {\n        try { ").concat(reset, " } catch (e) {}\n        ").concat(clear, "\n      }\n    ");
  }).join('');
}

function restoreTmpl(resetters, paths, hasWildcards) {
  var dynamicReset = hasWildcards === true ? "\n    const keys = Object.keys(secret)\n    const len = keys.length\n    for (var i = ".concat(paths.length, "; i < len; i++) {\n      const k = keys[i]\n      const o = secret[k]\n      if (o.flat === true) this.groupRestore(o)\n      else this.nestedRestore(o)\n      secret[k] = null\n    }\n  ") : '';
  return "\n    const secret = this.secret\n    ".concat(resetters, "\n    ").concat(dynamicReset, "\n    return o\n  ");
}