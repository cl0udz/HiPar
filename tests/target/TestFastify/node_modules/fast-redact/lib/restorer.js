'use strict';

var _require = require('./modifiers'),
    groupRestore = _require.groupRestore,
    nestedRestore = _require.nestedRestore;

module.exports = restorer;

function restorer(_ref) {
  var secret = _ref.secret,
      wcLen = _ref.wcLen;
  return function compileRestore() {
    if (this.restore) return;
    var paths = Object.keys(secret).filter(function (path) {
      return secret[path].precensored === false;
    });
    var resetters = resetTmpl(secret, paths);
    var hasWildcards = wcLen > 0;
    var state = hasWildcards ? {
      secret,
      groupRestore,
      nestedRestore
    } : {
      secret
    };
    /* eslint-disable-next-line */

    this.restore = Function('o', restoreTmpl(resetters, paths, hasWildcards)).bind(state);
  };
}
/**
 * Mutates the original object to be censored by restoring its original values
 * prior to censoring.
 *
 * @param {object} secret Compiled object describing which target fields should
 * be censored and the field states.
 * @param {string[]} paths The list of paths to censor as provided at
 * initialization time.
 *
 * @returns {string} String of JavaScript to be used by `Function()`. The
 * string compiles to the function that does the work in the description.
 */


function resetTmpl(secret, paths) {
  return paths.map(function (path) {
    var _secret$path = secret[path],
        circle = _secret$path.circle,
        escPath = _secret$path.escPath,
        leadingBracket = _secret$path.leadingBracket;
    var delim = leadingBracket ? '' : '.';
    var reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
    var clear = `secret[${escPath}].val = undefined`;
    return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
  }).join('');
}

function restoreTmpl(resetters, paths, hasWildcards) {
  var dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = ${paths.length}; i < len; i++) {
      const k = keys[i]
      const o = secret[k]
      if (o.flat === true) this.groupRestore(o)
      else this.nestedRestore(o)
      secret[k] = null
    }
  ` : '';
  return `
    const secret = this.secret
    ${resetters}
    ${dynamicReset}
    return o
  `;
}