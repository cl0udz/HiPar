'use strict';

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.replace");

var rx = require('./rx');

module.exports = parse;

function parse(_ref) {
  var paths = _ref.paths;
  var wildcards = [];
  var wcLen = 0;
  var secret = paths.reduce(function (o, strPath, ix) {
    var path = strPath.match(rx).map(function (p) {
      return p.replace(/'|"|`/g, '');
    });
    var leadingBracket = strPath[0] === '[';
    path = path.map(function (p) {
      if (p[0] === '[') return p.substr(1, p.length - 2);else return p;
    });
    var star = path.indexOf('*');

    if (star > -1) {
      var before = path.slice(0, star);
      var beforeStr = before.join('.');
      var after = path.slice(star + 1, path.length);
      if (after.indexOf('*') > -1) throw Error('fast-redact â€“ Only one wildcard per path is supported');
      var nested = after.length > 0;
      wcLen++;
      wildcards.push({
        before: before,
        beforeStr: beforeStr,
        after: after,
        nested: nested
      });
    } else {
      o[strPath] = {
        path: path,
        val: undefined,
        precensored: false,
        circle: '',
        escPath: JSON.stringify(strPath),
        leadingBracket: leadingBracket
      };
    }

    return o;
  }, {});
  return {
    wildcards: wildcards,
    wcLen: wcLen,
    secret: secret
  };
}