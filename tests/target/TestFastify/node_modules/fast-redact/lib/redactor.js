'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.bind");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reverse");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.bind");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var rx = require('./rx');

module.exports = redactor;

function redactor(_ref, state) {
  var secret = _ref.secret,
      serialize = _ref.serialize,
      wcLen = _ref.wcLen,
      strict = _ref.strict,
      isCensorFct = _ref.isCensorFct;
  /* eslint-disable-next-line */

  var redact = Function('o', "\n    if (typeof o !== 'object' || o == null) {\n      ".concat(strictImpl(strict, serialize), "\n    }\n    const { censor, secret } = this\n    ").concat(redactTmpl(secret, isCensorFct), "\n    this.compileRestore()\n    ").concat(dynamicRedactTmpl(wcLen > 0, isCensorFct), "\n    ").concat(resultTmpl(serialize), "\n  ")).bind(state);

  if (serialize === false) {
    redact.restore = function (o) {
      return state.restore(o);
    };
  }

  return redact;
}

function redactTmpl(secret, isCensorFct) {
  return Object.keys(secret).map(function (path) {
    var _secret$path = secret[path],
        escPath = _secret$path.escPath,
        leadingBracket = _secret$path.leadingBracket;
    var skip = leadingBracket ? 1 : 0;
    var delim = leadingBracket ? '' : '.';
    var hops = [];
    var match;

    while ((match = rx.exec(path)) !== null) {
      var _match = match,
          _match2 = _slicedToArray(_match, 2),
          ix = _match2[1];

      var _match3 = match,
          index = _match3.index,
          input = _match3.input;
      if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
    }

    var existence = hops.map(function (p) {
      return "o".concat(delim).concat(p);
    }).join(' && ');
    if (existence.length === 0) existence += "o".concat(delim).concat(path, " != null");else existence += " && o".concat(delim).concat(path, " != null");
    var circularDetection = "\n      switch (true) {\n        ".concat(hops.reverse().map(function (p) {
      return "\n          case o".concat(delim).concat(p, " === censor:\n            secret[").concat(escPath, "].circle = ").concat(JSON.stringify(p), "\n            break\n        ");
    }).join('\n'), "\n      }\n    ");
    return "\n      if (".concat(existence, ") {\n        const val = o").concat(delim).concat(path, "\n        if (val === censor) {\n          secret[").concat(escPath, "].precensored = true\n        } else {\n          secret[").concat(escPath, "].val = val\n          o").concat(delim).concat(path, " = ").concat(isCensorFct ? 'censor(val)' : 'censor', "\n          ").concat(circularDetection, "\n        }\n      }\n    ");
  }).join('\n');
}

function dynamicRedactTmpl(hasWildcards, isCensorFct) {
  return hasWildcards === true ? "\n    {\n      const { wildcards, wcLen, groupRedact, nestedRedact } = this\n      for (var i = 0; i < wcLen; i++) {\n        const { before, beforeStr, after, nested } = wildcards[i]\n        if (nested === true) {\n          secret[beforeStr] = secret[beforeStr] || []\n          nestedRedact(secret[beforeStr], o, before, after, censor, ".concat(isCensorFct, ")\n        } else secret[beforeStr] = groupRedact(o, before, censor, ").concat(isCensorFct, ")\n      }\n    }\n  ") : '';
}

function resultTmpl(serialize) {
  return serialize === false ? "return o" : "\n    var s = this.serialize(o)\n    this.restore(o)\n    return s\n  ";
}

function strictImpl(strict, serialize) {
  return strict === true ? "throw Error('fast-redact: primitives cannot be redacted')" : serialize === false ? "return o" : "return this.serialize(o)";
}