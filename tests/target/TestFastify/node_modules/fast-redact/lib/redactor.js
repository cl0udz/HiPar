'use strict';

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var rx = require('./rx');

module.exports = redactor;

function redactor(_ref, state) {
  var secret = _ref.secret,
      serialize = _ref.serialize,
      wcLen = _ref.wcLen,
      strict = _ref.strict,
      isCensorFct = _ref.isCensorFct;
  /* eslint-disable-next-line */

  var redact = Function('o', `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    ${redactTmpl(secret, isCensorFct)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct)}
    ${resultTmpl(serialize)}
  `).bind(state);

  if (serialize === false) {
    redact.restore = function (o) {
      return state.restore(o);
    };
  }

  return redact;
}

function redactTmpl(secret, isCensorFct) {
  return Object.keys(secret).map(function (path) {
    var _secret$path = secret[path],
        escPath = _secret$path.escPath,
        leadingBracket = _secret$path.leadingBracket;
    var skip = leadingBracket ? 1 : 0;
    var delim = leadingBracket ? '' : '.';
    var hops = [];
    var match;

    while ((match = rx.exec(path)) !== null) {
      var _match = match,
          _match2 = _slicedToArray(_match, 2),
          ix = _match2[1];

      var _match3 = match,
          index = _match3.index,
          input = _match3.input;
      if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
    }

    var existence = hops.map(function (p) {
      return `o${delim}${p}`;
    }).join(' && ');
    if (existence.length === 0) existence += `o${delim}${path} != null`;else existence += ` && o${delim}${path} != null`;
    var circularDetection = `
      switch (true) {
        ${hops.reverse().map(function (p) {
      return `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `;
    }).join('\n')}
      }
    `;
    return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? 'censor(val)' : 'censor'}
          ${circularDetection}
        }
      }
    `;
  }).join('\n');
}

function dynamicRedactTmpl(hasWildcards, isCensorFct) {
  return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct})
      }
    }
  ` : '';
}

function resultTmpl(serialize) {
  return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
}

function strictImpl(strict, serialize) {
  return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
}