'use strict';

var flatstr = require('flatstr');

var _require = require('./symbols'),
    lsCacheSym = _require.lsCacheSym,
    levelValSym = _require.levelValSym,
    useLevelLabelsSym = _require.useLevelLabelsSym,
    changeLevelNameSym = _require.changeLevelNameSym,
    useOnlyCustomLevelsSym = _require.useOnlyCustomLevelsSym,
    streamSym = _require.streamSym;

var _require2 = require('./tools'),
    noop = _require2.noop,
    genLog = _require2.genLog;

var levels = {
  trace: 10,
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  fatal: 60
};
var logFatal = genLog(levels.fatal);
var levelMethods = {
  fatal() {
    var stream = this[streamSym];

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    logFatal.call(this, ...args);

    if (typeof stream.flushSync === 'function') {
      stream.flushSync();
    }
  },

  error: genLog(levels.error),
  warn: genLog(levels.warn),
  info: genLog(levels.info),
  debug: genLog(levels.debug),
  trace: genLog(levels.trace)
};
var nums = Object.keys(levels).reduce(function (o, k) {
  o[levels[k]] = k;
  return o;
}, {});
var initialLsCache = Object.keys(nums).reduce(function (o, k) {
  o[k] = flatstr('{"level":' + Number(k));
  return o;
}, {});

function genLsCache(instance) {
  var levelName = instance[changeLevelNameSym];
  instance[lsCacheSym] = Object.keys(instance.levels.labels).reduce(function (o, k) {
    o[k] = instance[useLevelLabelsSym] ? `{"${levelName}":"${instance.levels.labels[k]}"` : flatstr(`{"${levelName}":` + Number(k));
    return o;
  }, Object.assign({}, instance[lsCacheSym]));
  return instance;
}

function isStandardLevel(level, useOnlyCustomLevels) {
  if (useOnlyCustomLevels) {
    return false;
  }

  switch (level) {
    case 'fatal':
    case 'error':
    case 'warn':
    case 'info':
    case 'debug':
    case 'trace':
      return true;

    default:
      return false;
  }
}

function setLevel(level) {
  var _this$levels = this.levels,
      labels = _this$levels.labels,
      values = _this$levels.values;

  if (typeof level === 'number') {
    if (labels[level] === undefined) throw Error('unknown level value' + level);
    level = labels[level];
  }

  if (values[level] === undefined) throw Error('unknown level ' + level);
  var preLevelVal = this[levelValSym];
  var levelVal = this[levelValSym] = values[level];
  var useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];

  for (var key in values) {
    if (levelVal > values[key]) {
      this[key] = noop;
      continue;
    }

    this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key] : genLog(values[key]);
  }

  this.emit('level-change', level, levelVal, labels[preLevelVal], preLevelVal);
}

function getLevel(level) {
  var levels = this.levels,
      levelVal = this.levelVal;
  return levels.labels[levelVal];
}

function isLevelEnabled(logLevel) {
  var values = this.levels.values;
  var logLevelVal = values[logLevel];
  return logLevelVal !== undefined && logLevelVal >= this[levelValSym];
}

function mappings() {
  var customLevels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var useOnlyCustomLevels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var customNums = customLevels ? Object.keys(customLevels).reduce(function (o, k) {
    o[customLevels[k]] = k;
    return o;
  }, {}) : null;
  var labels = Object.assign(Object.create(Object.prototype, {
    Infinity: {
      value: 'silent'
    }
  }), useOnlyCustomLevels ? null : nums, customNums);
  var values = Object.assign(Object.create(Object.prototype, {
    silent: {
      value: Infinity
    }
  }), useOnlyCustomLevels ? null : levels, customLevels);
  return {
    labels,
    values
  };
}

function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
  if (typeof defaultLevel === 'number') {
    var values = [].concat(Object.keys(customLevels || {}).map(function (key) {
      return customLevels[key];
    }), useOnlyCustomLevels ? [] : Object.keys(nums).map(function (level) {
      return +level;
    }), Infinity);

    if (!values.includes(defaultLevel)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }

    return;
  }

  var labels = Object.assign(Object.create(Object.prototype, {
    silent: {
      value: Infinity
    }
  }), useOnlyCustomLevels ? null : levels, customLevels);

  if (!(defaultLevel in labels)) {
    throw Error(`default level:${defaultLevel} must be included in custom levels`);
  }
}

function assertNoLevelCollisions(levels, customLevels) {
  var labels = levels.labels,
      values = levels.values;

  for (var k in customLevels) {
    if (k in values) {
      throw Error('levels cannot be overridden');
    }

    if (customLevels[k] in labels) {
      throw Error('pre-existing level values cannot be used for new levels');
    }
  }
}

module.exports = {
  initialLsCache,
  genLsCache,
  levelMethods,
  getLevel,
  setLevel,
  isLevelEnabled,
  mappings,
  assertNoLevelCollisions,
  assertDefaultLevelFound
};