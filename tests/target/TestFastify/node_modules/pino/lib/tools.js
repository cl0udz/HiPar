'use strict';
/* eslint no-prototype-builtins: 0 */

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.now");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.number.is-finite");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/web.dom-collections.iterator");

function _typeof3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof3 = function _typeof3(obj) { return typeof obj; }; } else { _typeof3 = function _typeof3(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof3(obj); }

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.now");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.number.is-finite");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/web.dom-collections.iterator");

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

var format = require('quick-format-unescaped');

var _require = require('pino-std-serializers'),
    mapHttpRequest = _require.mapHttpRequest,
    mapHttpResponse = _require.mapHttpResponse;

var SonicBoom = require('sonic-boom');

var stringifySafe = require('fast-safe-stringify');

var _require2 = require('./symbols'),
    lsCacheSym = _require2.lsCacheSym,
    chindingsSym = _require2.chindingsSym,
    parsedChindingsSym = _require2.parsedChindingsSym,
    writeSym = _require2.writeSym,
    serializersSym = _require2.serializersSym,
    formatOptsSym = _require2.formatOptsSym,
    endSym = _require2.endSym,
    stringifiersSym = _require2.stringifiersSym,
    stringifySym = _require2.stringifySym,
    wildcardFirstSym = _require2.wildcardFirstSym,
    needsMetadataGsym = _require2.needsMetadataGsym,
    wildcardGsym = _require2.wildcardGsym,
    redactFmtSym = _require2.redactFmtSym,
    streamSym = _require2.streamSym;

function noop() {}

function genLog(z) {
  return function LOG(o) {
    for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      n[_key - 1] = arguments[_key];
    }

    if (_typeof(o) === 'object' && o !== null) {
      if (o.method && o.headers && o.socket) {
        o = mapHttpRequest(o);
      } else if (typeof o.setHeader === 'function') {
        o = mapHttpResponse(o);
      }

      this[writeSym](o, format(null, n, this[formatOptsSym]), z);
    } else this[writeSym](null, format(o, n, this[formatOptsSym]), z);
  };
} // magically escape strings for json
// relying on their charCodeAt
// everything below 32 needs JSON.stringify()
// 34 and 92 happens all the time, so we
// have a fast case for them


function asString(str) {
  var result = '';
  var last = 0;
  var found = false;
  var point = 255;
  var l = str.length;

  if (l > 100) {
    return JSON.stringify(str);
  }

  for (var i = 0; i < l && point >= 32; i++) {
    point = str.charCodeAt(i);

    if (point === 34 || point === 92) {
      result += str.slice(last, i) + '\\';
      last = i;
      found = true;
    }
  }

  if (!found) {
    result = str;
  } else {
    result += str.slice(last);
  }

  return point < 32 ? JSON.stringify(str) : '"' + result + '"';
}

function asJson(obj, num, time) {
  var stringify = this[stringifySym];
  var stringifiers = this[stringifiersSym];
  var end = this[endSym];
  var chindings = this[chindingsSym];
  var serializers = this[serializersSym];
  var data = this[lsCacheSym][num] + time; // we need the child bindings added to the output first so instance logged
  // objects can take precedence when JSON.parse-ing the resulting log line

  data = data + chindings;
  var value;
  var notHasOwnProperty = obj.hasOwnProperty === undefined;

  if (serializers[wildcardGsym]) {
    obj = serializers[wildcardGsym](obj);
  }

  var wildcardStringifier = stringifiers[wildcardFirstSym];

  for (var key in obj) {
    value = obj[key];

    if ((notHasOwnProperty || obj.hasOwnProperty(key)) && value !== undefined) {
      value = serializers[key] ? serializers[key](value) : value;
      var stringifier = stringifiers[key] || wildcardStringifier;

      switch (_typeof(value)) {
        case 'undefined':
        case 'function':
          continue;

        case 'number':
          /* eslint no-fallthrough: "off" */
          if (Number.isFinite(value) === false) {
            value = null;
          }

        // this case explicity falls through to the next one

        case 'boolean':
          if (stringifier) value = stringifier(value);
          data += ',"' + key + '":' + value;
          continue;

        case 'string':
          value = (stringifier || asString)(value);
          break;

        default:
          value = (stringifier || stringify)(value);
      }

      if (value === undefined) continue;
      data += ',"' + key + '":' + value;
    }
  }

  return data + end;
}

function asChindings(instance, bindings) {
  if (!bindings) {
    throw Error('missing bindings for child Pino');
  }

  var key;
  var value;
  var data = instance[chindingsSym];
  var stringify = instance[stringifySym];
  var stringifiers = instance[stringifiersSym];
  var serializers = instance[serializersSym];

  if (serializers[wildcardGsym]) {
    bindings = serializers[wildcardGsym](bindings);
  }

  for (key in bindings) {
    value = bindings[key];
    var valid = key !== 'level' && key !== 'serializers' && key !== 'customLevels' && bindings.hasOwnProperty(key) && value !== undefined;

    if (valid === true) {
      value = serializers[key] ? serializers[key](value) : value;
      value = (stringifiers[key] || stringify)(value);
      if (value === undefined) continue;
      data += ',"' + key + '":' + value;
    }
  }

  return data;
}

function getPrettyStream(opts, prettifier, dest) {
  if (prettifier && typeof prettifier === 'function') {
    return prettifierMetaWrapper(prettifier(opts), dest);
  }

  try {
    var prettyFactory = require('pino-pretty');

    prettyFactory.asMetaWrapper = prettifierMetaWrapper;
    return prettifierMetaWrapper(prettyFactory(opts), dest);
  } catch (e) {
    throw Error('Missing `pino-pretty` module: `pino-pretty` must be installed separately');
  }
}

function prettifierMetaWrapper(pretty, dest) {
  var _ref;

  var warned = false;
  return _ref = {}, _defineProperty(_ref, needsMetadataGsym, true), _defineProperty(_ref, "lastLevel", 0), _defineProperty(_ref, "lastMsg", null), _defineProperty(_ref, "lastObj", null), _defineProperty(_ref, "lastLogger", null), _defineProperty(_ref, "flushSync", function flushSync() {
    if (warned) {
      return;
    }

    warned = true;
    dest.write(pretty(Object.assign({
      level: 40,
      // warn
      msg: 'pino.final with prettyPrint does not support flushing',
      time: Date.now()
    }, this.chindings())));
  }), _defineProperty(_ref, "chindings", function chindings() {
    var lastLogger = this.lastLogger;
    var chindings = null; // protection against flushSync being called before logging
    // anything

    if (!lastLogger) {
      return null;
    }

    if (lastLogger.hasOwnProperty(parsedChindingsSym)) {
      chindings = lastLogger[parsedChindingsSym];
    } else {
      chindings = JSON.parse('{"v":1' + lastLogger[chindingsSym] + '}');
      lastLogger[parsedChindingsSym] = chindings;
    }

    return chindings;
  }), _defineProperty(_ref, "write", function write(chunk) {
    var lastLogger = this.lastLogger;
    var chindings = this.chindings();
    var time = this.lastTime;

    if (time.match(/^\d+/)) {
      time = parseInt(time);
    }

    var lastObj = this.lastObj;
    var errorProps = null;
    var obj = Object.assign({
      level: this.lastLevel,
      time: time
    }, chindings, lastObj, errorProps);
    var serializers = lastLogger[serializersSym];
    var keys = Object.keys(serializers);
    var key;

    for (var i = 0; i < keys.length; i++) {
      key = keys[i];

      if (obj[key] !== undefined) {
        obj[key] = serializers[key](obj[key]);
      }
    }

    var stringifiers = lastLogger[stringifiersSym];
    var redact = stringifiers[redactFmtSym];
    var formatted = pretty(typeof redact === 'function' ? redact(obj) : obj);
    if (formatted === undefined) return;
    dest.write(formatted);
  }), _ref;
}

function hasBeenTampered(stream) {
  return stream.write !== stream.constructor.prototype.write;
}

function buildSafeSonicBoom(dest) {
  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var sync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var stream = new SonicBoom(dest, buffer, sync);
  stream.on('error', filterBrokenPipe);
  return stream;

  function filterBrokenPipe(err) {
    // TODO verify on Windows
    if (err.code === 'EPIPE') {
      // If we get EPIPE, we should stop logging here
      // however we have no control to the consumer of
      // SonicBoom, so we just overwrite the write method
      stream.write = noop;
      stream.end = noop;
      stream.flushSync = noop;
      stream.destroy = noop;
      return;
    }

    stream.removeListener('error', filterBrokenPipe);
    stream.emit('error', err);
  }
}

function createArgsNormalizer(defaultOptions) {
  return function normalizeArgs() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var stream = arguments.length > 1 ? arguments[1] : undefined; // support stream as a string

    if (typeof opts === 'string') {
      stream = buildSafeSonicBoom(opts);
      opts = {};
    } else if (typeof stream === 'string') {
      stream = buildSafeSonicBoom(stream);
    } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
      stream = opts;
      opts = null;
    }

    opts = Object.assign({}, defaultOptions, opts);

    if ('extreme' in opts) {
      throw Error('The extreme option has been removed, use pino.extreme instead');
    }

    if ('onTerminated' in opts) {
      throw Error('The onTerminated option has been removed, use pino.final instead');
    }

    var _opts = opts,
        enabled = _opts.enabled,
        prettyPrint = _opts.prettyPrint,
        prettifier = _opts.prettifier,
        messageKey = _opts.messageKey;
    if (enabled === false) opts.level = 'silent';
    stream = stream || process.stdout;

    if (stream === process.stdout && stream.fd >= 0 && !hasBeenTampered(stream)) {
      stream = buildSafeSonicBoom(stream.fd);
    }

    if (prettyPrint) {
      var prettyOpts = Object.assign({
        messageKey: messageKey
      }, prettyPrint);
      stream = getPrettyStream(prettyOpts, prettifier, stream);
    }

    return {
      opts: opts,
      stream: stream
    };
  };
}

function _final(logger, handler) {
  if (typeof logger === 'undefined' || typeof logger.child !== 'function') {
    throw Error('expected a pino logger instance');
  }

  var hasHandler = typeof handler !== 'undefined';

  if (hasHandler && typeof handler !== 'function') {
    throw Error('if supplied, the handler parameter should be a function');
  }

  var stream = logger[streamSym];

  if (typeof stream.flushSync !== 'function') {
    throw Error('final requires a stream that has a flushSync method, such as pino.destination and pino.extreme');
  }

  var finalLogger = new Proxy(logger, {
    get: function get(logger, key) {
      if (key in logger.levels.values) {
        return function () {
          logger[key].apply(logger, arguments);
          stream.flushSync();
        };
      }

      return logger[key];
    }
  });

  if (!hasHandler) {
    return finalLogger;
  }

  return function () {
    var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    try {
      stream.flushSync();
    } catch (e) {// it's too late to wait for the stream to be ready
      // because this is a final tick scenario.
      // in practice there shouldn't be a situation where it isn't
      // however, swallow the error just in case (and for easier testing)
    }

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return handler.apply(void 0, [err, finalLogger].concat(args));
  };
}

function stringify(obj) {
  try {
    return JSON.stringify(obj);
  } catch (_) {
    return stringifySafe(obj);
  }
}

module.exports = {
  noop: noop,
  buildSafeSonicBoom: buildSafeSonicBoom,
  getPrettyStream: getPrettyStream,
  asChindings: asChindings,
  asJson: asJson,
  genLog: genLog,
  createArgsNormalizer: createArgsNormalizer,
  "final": _final,
  stringify: stringify
};