'use strict';
/* eslint no-prototype-builtins: 0 */

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var SonicBoom = require('sonic-boom');

var flatstr = require('flatstr');

var _require2 = require('./symbols'),
    lsCacheSym = _require2.lsCacheSym,
    levelValSym = _require2.levelValSym,
    setLevelSym = _require2.setLevelSym,
    getLevelSym = _require2.getLevelSym,
    chindingsSym = _require2.chindingsSym,
    asJsonSym = _require2.asJsonSym,
    messageKeySym = _require2.messageKeySym,
    writeSym = _require2.writeSym,
    timeSym = _require2.timeSym,
    timeSliceIndexSym = _require2.timeSliceIndexSym,
    streamSym = _require2.streamSym,
    serializersSym = _require2.serializersSym,
    useOnlyCustomLevelsSym = _require2.useOnlyCustomLevelsSym,
    needsMetadataGsym = _require2.needsMetadataGsym;

var _require3 = require('./levels'),
    getLevel = _require3.getLevel,
    setLevel = _require3.setLevel,
    isLevelEnabled = _require3.isLevelEnabled,
    mappings = _require3.mappings,
    initialLsCache = _require3.initialLsCache,
    genLsCache = _require3.genLsCache,
    assertNoLevelCollisions = _require3.assertNoLevelCollisions;

var _require4 = require('./tools'),
    asChindings = _require4.asChindings,
    asJson = _require4.asJson;

var _require5 = require('./meta'),
    version = _require5.version,
    LOG_VERSION = _require5.LOG_VERSION; // note: use of class is satirical
// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127


var constructor = class Pino {};
var prototype = {
  constructor,
  child,
  bindings,
  flush,
  isLevelEnabled,
  version,

  get level() {
    return this[getLevelSym]();
  },

  set level(lvl) {
    return this[setLevelSym](lvl);
  },

  get levelVal() {
    return this[levelValSym];
  },

  set levelVal(n) {
    throw Error('levelVal is read-only');
  },

  [lsCacheSym]: initialLsCache,
  [writeSym]: write,
  [asJsonSym]: asJson,
  [getLevelSym]: getLevel,
  [setLevelSym]: setLevel,
  LOG_VERSION
};
Object.setPrototypeOf(prototype, EventEmitter.prototype);
module.exports = prototype;

function child(bindings) {
  var level = this.level;
  var serializers = this[serializersSym];
  var chindings = asChindings(this, bindings);
  var instance = Object.create(this);

  if (bindings.hasOwnProperty('serializers') === true) {
    instance[serializersSym] = Object.create(null);

    for (var k in serializers) {
      instance[serializersSym][k] = serializers[k];
    }

    var parentSymbols = Object.getOwnPropertySymbols(serializers);

    for (var i = 0; i < parentSymbols.length; i++) {
      var ks = parentSymbols[i];
      instance[serializersSym][ks] = serializers[ks];
    }

    for (var bk in bindings.serializers) {
      instance[serializersSym][bk] = bindings.serializers[bk];
    }

    var bindingsSymbols = Object.getOwnPropertySymbols(bindings.serializers);

    for (var bi = 0; bi < bindingsSymbols.length; bi++) {
      var bks = bindingsSymbols[bi];
      instance[serializersSym][bks] = bindings.serializers[bks];
    }
  } else instance[serializersSym] = serializers;

  if (bindings.hasOwnProperty('customLevels') === true) {
    assertNoLevelCollisions(this.levels, bindings.customLevels);
    instance.levels = mappings(bindings.customLevels, instance[useOnlyCustomLevelsSym]);
    genLsCache(instance);
  }

  instance[chindingsSym] = chindings;
  var childLevel = bindings.level || level;
  instance[setLevelSym](childLevel);
  return instance;
}

function bindings() {
  var chindings = this[chindingsSym];
  var chindingsJson = `{${chindings.substr(1)}}`; // at least contains ,"pid":7068,"hostname":"myMac"

  var bindingsFromJson = JSON.parse(chindingsJson);
  delete bindingsFromJson.pid;
  delete bindingsFromJson.hostname;
  return bindingsFromJson;
}

function write(_obj, msg, num) {
  var t = this[timeSym]();
  var messageKey = this[messageKeySym];
  var objError = _obj instanceof Error;
  var obj;

  if (_obj === undefined || _obj === null) {
    obj = {};
    obj[messageKey] = msg;
  } else {
    obj = Object.assign({}, _obj);

    if (msg) {
      obj[messageKey] = msg;
    } else if (objError) {
      obj[messageKey] = _obj.message;
    }

    if (objError) {
      obj.stack = _obj.stack;

      if (!obj.type) {
        obj.type = 'Error';
      }
    }
  }

  var s = this[asJsonSym](obj, num, t);
  var stream = this[streamSym];

  if (stream[needsMetadataGsym] === true) {
    stream.lastLevel = num; // TODO remove in the next major release,
    // it is not needed anymore

    stream.lastMsg = msg;
    stream.lastObj = obj;
    stream.lastTime = t.slice(this[timeSliceIndexSym]);
    stream.lastLogger = this; // for child loggers
  }

  if (stream instanceof SonicBoom) stream.write(s);else stream.write(flatstr(s));
}

function flush() {
  var stream = this[streamSym];
  if ('flush' in stream) stream.flush();
}