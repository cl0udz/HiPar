'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var fastRedact = require('fast-redact');

var _require = require('./symbols'),
    redactFmtSym = _require.redactFmtSym,
    wildcardFirstSym = _require.wildcardFirstSym;

var rx = fastRedact.rx,
    validator = fastRedact.validator;
var validate = validator({
  ERR_PATHS_MUST_BE_STRINGS: function ERR_PATHS_MUST_BE_STRINGS() {
    return 'pino – redacted paths must be strings';
  },
  ERR_INVALID_PATH: function ERR_INVALID_PATH(s) {
    return "pino \u2013 redact paths array contains an invalid path (".concat(s, ")");
  }
});
var CENSOR = '[Redacted]';
var strict = false; // TODO should this be configurable?

function redaction(opts, serialize) {
  var _handle = handle(opts),
      paths = _handle.paths,
      censor = _handle.censor;

  var shape = paths.reduce(function (o, str) {
    rx.lastIndex = 0;
    var first = rx.exec(str);
    var next = rx.exec(str); // ns is the top-level path segment, brackets + quoting removed.

    var ns = first[1] !== undefined ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, '$1') : first[0];

    if (ns === '*') {
      ns = wildcardFirstSym;
    } // top level key:


    if (next === null) {
      o[ns] = null;
      return o;
    } // path with at least two segments:
    // if ns is already redacted at the top level, ignore lower level redactions


    if (o[ns] === null) {
      return o;
    }

    var index = next.index;
    var nextPath = "".concat(str.substr(index, str.length - 1));
    o[ns] = o[ns] || []; // shape is a mix of paths beginning with literal values and wildcard
    // paths [ "a.b.c", "*.b.z" ] should reduce to a shape of
    // { "a": [ "b.c", "b.z" ], *: [ "b.z" ] }
    // note: "b.z" is in both "a" and * arrays because "a" matches the wildcard.
    // (* entry has wildcardFirstSym as key)

    if (ns !== wildcardFirstSym && o[ns].length === 0) {
      var _o$ns;

      // first time ns's get all '*' redactions so far
      (_o$ns = o[ns]).push.apply(_o$ns, _toConsumableArray(o[wildcardFirstSym] || []));
    }

    if (ns === wildcardFirstSym) {
      // new * path gets added to all previously registered literal ns's.
      Object.keys(o).forEach(function (k) {
        if (o[k]) {
          o[k].push(nextPath);
        }
      });
    }

    o[ns].push(nextPath);
    return o;
  }, {}); // the redactor assigned to the format symbol key
  // provides top level redaction for instances where
  // an object is interpolated into the msg string

  var result = _defineProperty({}, redactFmtSym, fastRedact({
    paths: paths,
    censor: censor,
    serialize: serialize,
    strict: strict
  }));

  var topCensor = function topCensor() {
    return typeof censor === 'function' ? serialize(censor.apply(void 0, arguments)) : serialize(censor);
  };

  return [].concat(_toConsumableArray(Object.keys(shape)), _toConsumableArray(Object.getOwnPropertySymbols(shape))).reduce(function (o, k) {
    // top level key:
    if (shape[k] === null) o[k] = topCensor;else o[k] = fastRedact({
      paths: shape[k],
      censor: censor,
      serialize: serialize,
      strict: strict
    });
    return o;
  }, result);
}

function handle(opts) {
  if (Array.isArray(opts)) {
    opts = {
      paths: opts,
      censor: CENSOR
    };
    validate(opts);
    return opts;
  }

  var _opts = opts,
      paths = _opts.paths,
      _opts$censor = _opts.censor,
      censor = _opts$censor === void 0 ? CENSOR : _opts$censor,
      remove = _opts.remove;

  if (Array.isArray(paths) === false) {
    throw Error('pino – redact must contain an array of strings');
  }

  if (remove === true) censor = undefined;
  validate({
    paths: paths,
    censor: censor
  });
  return {
    paths: paths,
    censor: censor
  };
}

module.exports = redaction;