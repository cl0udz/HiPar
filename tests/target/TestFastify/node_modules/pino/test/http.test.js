'use strict';

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("regenerator-runtime/runtime");

var http = require('http');

var os = require('os');

var _require = require('tap'),
    test = _require.test;

var _require2 = require('./helper'),
    sink = _require2.sink,
    once = _require2.once;

var pino = require('../');

var _process = process,
    pid = _process.pid;
var hostname = os.hostname();
test('http request support', function _callee(_ref) {
  var ok, same, error, teardown, originalReq, instance, server, err, res;
  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          ok = _ref.ok, same = _ref.same, error = _ref.error, teardown = _ref.teardown;
          instance = pino(sink(function (chunk, enc) {
            ok(new Date(chunk.time) <= new Date(), 'time is greater than Date.now()');
            delete chunk.time;
            same(chunk, {
              pid: pid,
              hostname: hostname,
              level: 30,
              msg: 'my request',
              v: 1,
              req: {
                method: originalReq.method,
                url: originalReq.url,
                headers: originalReq.headers,
                remoteAddress: originalReq.connection.remoteAddress,
                remotePort: originalReq.connection.remotePort
              }
            });
          }));
          server = http.createServer(function (req, res) {
            originalReq = req;
            instance.info(req, 'my request');
            res.end('hello');
          });
          server.unref();
          server.listen();
          _context.next = 7;
          return regeneratorRuntime.awrap(once(server, 'listening'));

        case 7:
          err = _context.sent;
          error(err);
          _context.next = 11;
          return regeneratorRuntime.awrap(once(http.get('http://localhost:' + server.address().port), 'response'));

        case 11:
          res = _context.sent;
          res.resume();
          server.close();

        case 14:
        case "end":
          return _context.stop();
      }
    }
  });
});
test('http request support via serializer', function _callee2(_ref2) {
  var ok, same, error, teardown, originalReq, instance, server, err, res;
  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          ok = _ref2.ok, same = _ref2.same, error = _ref2.error, teardown = _ref2.teardown;
          instance = pino({
            serializers: {
              req: pino.stdSerializers.req
            }
          }, sink(function (chunk, enc) {
            ok(new Date(chunk.time) <= new Date(), 'time is greater than Date.now()');
            delete chunk.time;
            same(chunk, {
              pid: pid,
              hostname: hostname,
              level: 30,
              msg: 'my request',
              v: 1,
              req: {
                method: originalReq.method,
                url: originalReq.url,
                headers: originalReq.headers,
                remoteAddress: originalReq.connection.remoteAddress,
                remotePort: originalReq.connection.remotePort
              }
            });
          }));
          server = http.createServer(function (req, res) {
            originalReq = req;
            instance.info({
              req: req
            }, 'my request');
            res.end('hello');
          });
          server.unref();
          server.listen();
          _context2.next = 7;
          return regeneratorRuntime.awrap(once(server, 'listening'));

        case 7:
          err = _context2.sent;
          error(err);
          _context2.next = 11;
          return regeneratorRuntime.awrap(once(http.get('http://localhost:' + server.address().port), 'response'));

        case 11:
          res = _context2.sent;
          res.resume();
          server.close();

        case 14:
        case "end":
          return _context2.stop();
      }
    }
  });
});
test('http request support via serializer without request connection', function _callee3(_ref3) {
  var ok, same, error, teardown, originalReq, instance, server, err, res;
  return regeneratorRuntime.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          ok = _ref3.ok, same = _ref3.same, error = _ref3.error, teardown = _ref3.teardown;
          instance = pino({
            serializers: {
              req: pino.stdSerializers.req
            }
          }, sink(function (chunk, enc) {
            ok(new Date(chunk.time) <= new Date(), 'time is greater than Date.now()');
            delete chunk.time;
            same(chunk, {
              pid: pid,
              hostname: hostname,
              level: 30,
              msg: 'my request',
              v: 1,
              req: {
                method: originalReq.method,
                url: originalReq.url,
                headers: originalReq.headers
              }
            });
          }));
          server = http.createServer(function (req, res) {
            originalReq = req;
            delete req.connection;
            instance.info({
              req: req
            }, 'my request');
            res.end('hello');
          });
          server.unref();
          server.listen();
          _context3.next = 7;
          return regeneratorRuntime.awrap(once(server, 'listening'));

        case 7:
          err = _context3.sent;
          error(err);
          _context3.next = 11;
          return regeneratorRuntime.awrap(once(http.get('http://localhost:' + server.address().port), 'response'));

        case 11:
          res = _context3.sent;
          res.resume();
          server.close();

        case 14:
        case "end":
          return _context3.stop();
      }
    }
  });
});
test('http response support', function _callee4(_ref4) {
  var ok, same, error, teardown, originalRes, instance, server, err, res;
  return regeneratorRuntime.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          ok = _ref4.ok, same = _ref4.same, error = _ref4.error, teardown = _ref4.teardown;
          instance = pino(sink(function (chunk, enc) {
            ok(new Date(chunk.time) <= new Date(), 'time is greater than Date.now()');
            delete chunk.time;
            same(chunk, {
              pid: pid,
              hostname: hostname,
              level: 30,
              msg: 'my response',
              v: 1,
              res: {
                statusCode: originalRes.statusCode,
                headers: originalRes._headers
              }
            });
          }));
          server = http.createServer(function (req, res) {
            originalRes = res;
            res.end('hello');
            instance.info(res, 'my response');
          });
          server.unref();
          server.listen();
          _context4.next = 7;
          return regeneratorRuntime.awrap(once(server, 'listening'));

        case 7:
          err = _context4.sent;
          error(err);
          _context4.next = 11;
          return regeneratorRuntime.awrap(once(http.get('http://localhost:' + server.address().port), 'response'));

        case 11:
          res = _context4.sent;
          res.resume();
          server.close();

        case 14:
        case "end":
          return _context4.stop();
      }
    }
  });
});
test('http response support via a serializer', function _callee5(_ref5) {
  var ok, same, error, teardown, instance, server, err, res;
  return regeneratorRuntime.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          ok = _ref5.ok, same = _ref5.same, error = _ref5.error, teardown = _ref5.teardown;
          instance = pino({
            serializers: {
              res: pino.stdSerializers.res
            }
          }, sink(function (chunk, enc) {
            ok(new Date(chunk.time) <= new Date(), 'time is greater than Date.now()');
            delete chunk.time;
            same(chunk, {
              pid: pid,
              hostname: hostname,
              level: 30,
              msg: 'my response',
              v: 1,
              res: {
                statusCode: 200,
                headers: {
                  'x-single': 'y',
                  'x-multi': [1, 2]
                }
              }
            });
          }));
          server = http.createServer(function (req, res) {
            res.setHeader('x-single', 'y');
            res.setHeader('x-multi', [1, 2]);
            res.end('hello');
            instance.info({
              res: res
            }, 'my response');
          });
          server.unref();
          server.listen();
          _context5.next = 7;
          return regeneratorRuntime.awrap(once(server, 'listening'));

        case 7:
          err = _context5.sent;
          error(err);
          _context5.next = 11;
          return regeneratorRuntime.awrap(once(http.get('http://localhost:' + server.address().port), 'response'));

        case 11:
          res = _context5.sent;
          res.resume();
          server.close();

        case 14:
        case "end":
          return _context5.stop();
      }
    }
  });
});
test('http request support via serializer in a child', function _callee6(_ref6) {
  var ok, same, error, teardown, originalReq, instance, server, err, res;
  return regeneratorRuntime.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          ok = _ref6.ok, same = _ref6.same, error = _ref6.error, teardown = _ref6.teardown;
          instance = pino({
            serializers: {
              req: pino.stdSerializers.req
            }
          }, sink(function (chunk, enc) {
            ok(new Date(chunk.time) <= new Date(), 'time is greater than Date.now()');
            delete chunk.time;
            same(chunk, {
              pid: pid,
              hostname: hostname,
              level: 30,
              msg: 'my request',
              v: 1,
              req: {
                method: originalReq.method,
                url: originalReq.url,
                headers: originalReq.headers,
                remoteAddress: originalReq.connection.remoteAddress,
                remotePort: originalReq.connection.remotePort
              }
            });
          }));
          server = http.createServer(function (req, res) {
            originalReq = req;
            var child = instance.child({
              req: req
            });
            child.info('my request');
            res.end('hello');
          });
          server.unref();
          server.listen();
          _context6.next = 7;
          return regeneratorRuntime.awrap(once(server, 'listening'));

        case 7:
          err = _context6.sent;
          error(err);
          _context6.next = 11;
          return regeneratorRuntime.awrap(once(http.get('http://localhost:' + server.address().port), 'response'));

        case 11:
          res = _context6.sent;
          res.resume();
          server.close();

        case 14:
        case "end":
          return _context6.stop();
      }
    }
  });
});