'use strict';

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("regenerator-runtime/runtime");

var os = require('os');

var _require = require('tap'),
    test = _require.test;

var _require2 = require('./helper'),
    sink = _require2.sink,
    once = _require2.once;

var pino = require('../');

var _process = process,
    pid = _process.pid;
var hostname = os.hostname();

function testEscape(ch, key) {
  test('correctly escape ' + ch, function _callee(_ref) {
    var same, stream, instance, result;
    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            same = _ref.same;
            stream = sink();
            instance = pino({
              name: 'hello'
            }, stream);
            instance.fatal('this contains ' + key);
            _context.next = 6;
            return regeneratorRuntime.awrap(once(stream, 'data'));

          case 6:
            result = _context.sent;
            delete result.time;
            same(result, {
              pid: pid,
              hostname: hostname,
              level: 60,
              name: 'hello',
              msg: 'this contains ' + key,
              v: 1
            });

          case 9:
          case "end":
            return _context.stop();
        }
      }
    });
  });
}

testEscape('\\n', '\n');
testEscape('\\/', '/');
testEscape('\\\\', '\\');
testEscape('\\r', '\r');
testEscape('\\t', '\t');
testEscape('\\b', '\b');
var toEscape = ["\0", // NUL  Null character
"\x01", // SOH  Start of Heading
"\x02", // STX  Start of Text
"\x03", // ETX  End-of-text character
"\x04", // EOT  End-of-transmission character
"\x05", // ENQ  Enquiry character
"\x06", // ACK  Acknowledge character
"\x07", // BEL  Bell character
"\b", // BS   Backspace
"\t", // HT   Horizontal tab
"\n", // LF   Line feed
"\x0B", // VT   Vertical tab
"\f", // FF   Form feed
"\r", // CR   Carriage return
"\x0E", // SO   Shift Out
"\x0F", // SI   Shift In
"\x10", // DLE  Data Link Escape
"\x11", // DC1  Device Control 1
"\x12", // DC2  Device Control 2
"\x13", // DC3  Device Control 3
"\x14", // DC4  Device Control 4
"\x15", // NAK  Negative-acknowledge character
"\x16", // SYN  Synchronous Idle
"\x17", // ETB  End of Transmission Block
"\x18", // CAN  Cancel character
"\x19", // EM   End of Medium
"\x1A", // SUB  Substitute character
"\x1B", // ESC  Escape character
"\x1C", // FS   File Separator
"\x1D", // GS   Group Separator
"\x1E", // RS   Record Separator
"\x1F" // US   Unit Separator
];
toEscape.forEach(function (key) {
  testEscape(JSON.stringify(key), key);
});
test("correctly escape `hello \\u001F world \\n \\u0022`", function _callee2(_ref2) {
  var same, stream, instance, result;
  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          same = _ref2.same;
          stream = sink();
          instance = pino({
            name: 'hello'
          }, stream);
          instance.fatal("hello \x1F world \n \"");
          _context2.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          result = _context2.sent;
          delete result.time;
          same(result, {
            pid: pid,
            hostname: hostname,
            level: 60,
            name: 'hello',
            msg: "hello \x1F world \n \"",
            v: 1
          });

        case 9:
        case "end":
          return _context2.stop();
      }
    }
  });
});