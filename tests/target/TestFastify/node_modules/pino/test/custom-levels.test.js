'use strict';
/* eslint no-prototype-builtins: 0 */

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

require("regenerator-runtime/runtime");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require('tap'),
    test = _require.test;

var _require2 = require('./helper'),
    sink = _require2.sink,
    once = _require2.once;

var pino = require('../');

test('adds additional levels', function _callee(_ref) {
  var is, stream, logger, _ref2, level;

  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          is = _ref.is;
          stream = sink();
          logger = pino({
            customLevels: {
              foo: 35,
              bar: 45
            }
          }, stream);
          logger.foo('test');
          _context.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          _ref2 = _context.sent;
          level = _ref2.level;
          is(level, 35);

        case 9:
        case "end":
          return _context.stop();
      }
    }
  });
});
test('custom levels does not override default levels', function _callee2(_ref3) {
  var is, stream, logger, _ref4, level;

  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          is = _ref3.is;
          stream = sink();
          logger = pino({
            customLevels: {
              foo: 35
            }
          }, stream);
          logger.info('test');
          _context2.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          _ref4 = _context2.sent;
          level = _ref4.level;
          is(level, 30);

        case 9:
        case "end":
          return _context2.stop();
      }
    }
  });
});
test('default levels can be redefined using custom levels', function _callee3(_ref5) {
  var is, stream, logger, _ref6, level;

  return regeneratorRuntime.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          is = _ref5.is;
          stream = sink();
          logger = pino({
            customLevels: {
              info: 35,
              debug: 45
            },
            useOnlyCustomLevels: true
          }, stream);
          is(logger.hasOwnProperty('info'), true);
          logger.info('test');
          _context3.next = 7;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 7:
          _ref6 = _context3.sent;
          level = _ref6.level;
          is(level, 35);

        case 10:
        case "end":
          return _context3.stop();
      }
    }
  });
});
test('custom levels overrides default level label if use useOnlyCustomLevels', function _callee4(_ref7) {
  var is, stream, logger;
  return regeneratorRuntime.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          is = _ref7.is;
          stream = sink();
          logger = pino({
            customLevels: {
              foo: 35
            },
            useOnlyCustomLevels: true,
            level: 'foo'
          }, stream);
          is(logger.hasOwnProperty('info'), false);

        case 4:
        case "end":
          return _context4.stop();
      }
    }
  });
});
test('custom levels overrides default level value if use useOnlyCustomLevels', function _callee5(_ref8) {
  var is, stream, logger;
  return regeneratorRuntime.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          is = _ref8.is;
          stream = sink();
          logger = pino({
            customLevels: {
              foo: 35
            },
            useOnlyCustomLevels: true,
            level: 35
          }, stream);
          is(logger.hasOwnProperty('info'), false);

        case 4:
        case "end":
          return _context5.stop();
      }
    }
  });
});
test('custom levels are inherited by children', function _callee6(_ref9) {
  var is, stream, logger, _ref10, msg, childMsg, level;

  return regeneratorRuntime.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          is = _ref9.is;
          stream = sink();
          logger = pino({
            customLevels: {
              foo: 35
            }
          }, stream);
          logger.child({
            childMsg: 'ok'
          }).foo('test');
          _context6.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          _ref10 = _context6.sent;
          msg = _ref10.msg;
          childMsg = _ref10.childMsg;
          level = _ref10.level;
          is(level, 35);
          is(childMsg, 'ok');
          is(msg, 'test');

        case 13:
        case "end":
          return _context6.stop();
      }
    }
  });
});
test('custom levels can be specified on child bindings', function _callee7(_ref11) {
  var is, stream, logger, _ref12, msg, childMsg, level;

  return regeneratorRuntime.async(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          is = _ref11.is;
          stream = sink();
          logger = pino(stream).child({
            customLevels: {
              foo: 35
            },
            childMsg: 'ok'
          });
          logger.foo('test');
          _context7.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          _ref12 = _context7.sent;
          msg = _ref12.msg;
          childMsg = _ref12.childMsg;
          level = _ref12.level;
          is(level, 35);
          is(childMsg, 'ok');
          is(msg, 'test');

        case 13:
        case "end":
          return _context7.stop();
      }
    }
  });
});
test('customLevels property child bindings does not get logged', function _callee8(_ref13) {
  var is, stream, logger, _ref14, customLevels;

  return regeneratorRuntime.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          is = _ref13.is;
          stream = sink();
          logger = pino(stream).child({
            customLevels: {
              foo: 35
            },
            childMsg: 'ok'
          });
          logger.foo('test');
          _context8.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          _ref14 = _context8.sent;
          customLevels = _ref14.customLevels;
          is(customLevels, undefined);

        case 9:
        case "end":
          return _context8.stop();
      }
    }
  });
});
test('throws when specifying pre-existing parent labels via child bindings', function _callee9(_ref15) {
  var is, _throws, stream, message;

  return regeneratorRuntime.async(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          is = _ref15.is, _throws = _ref15["throws"];
          stream = sink();

          _throws(function () {
            return pino({
              customLevels: {
                foo: 35
              }
            }, stream).child({
              customLevels: {
                foo: 45
              }
            });
          });

          try {
            pino({
              customLevels: {
                foo: 35
              }
            }, stream).child({
              customLevels: {
                foo: 45
              }
            });
          } catch (_ref16) {
            message = _ref16.message;
            is(message, 'levels cannot be overridden');
          }

        case 4:
        case "end":
          return _context9.stop();
      }
    }
  });
});
test('throws when specifying pre-existing parent values via child bindings', function _callee10(_ref17) {
  var is, _throws2, stream, message;

  return regeneratorRuntime.async(function _callee10$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          is = _ref17.is, _throws2 = _ref17["throws"];
          stream = sink();

          _throws2(function () {
            return pino({
              customLevels: {
                foo: 35
              }
            }, stream).child({
              customLevels: {
                bar: 35
              }
            });
          });

          try {
            pino({
              customLevels: {
                foo: 35
              }
            }, stream).child({
              customLevels: {
                bar: 35
              }
            });
          } catch (_ref18) {
            message = _ref18.message;
            is(message, 'pre-existing level values cannot be used for new levels');
          }

        case 4:
        case "end":
          return _context10.stop();
      }
    }
  });
});
test('throws when specifying core values via child bindings', function _callee11(_ref19) {
  var is, _throws3, stream, message;

  return regeneratorRuntime.async(function _callee11$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          is = _ref19.is, _throws3 = _ref19["throws"];
          stream = sink();

          _throws3(function () {
            return pino(stream).child({
              customLevels: {
                foo: 30
              }
            });
          });

          try {
            pino(stream).child({
              customLevels: {
                foo: 30
              }
            });
          } catch (_ref20) {
            message = _ref20.message;
            is(message, 'pre-existing level values cannot be used for new levels');
          }

        case 4:
        case "end":
          return _context11.stop();
      }
    }
  });
});
test('throws when useOnlyCustomLevels is set true without customLevels', function _callee12(_ref21) {
  var is, _throws4, stream, message;

  return regeneratorRuntime.async(function _callee12$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          is = _ref21.is, _throws4 = _ref21["throws"];
          stream = sink();

          _throws4(function () {
            return pino({
              useOnlyCustomLevels: true
            }, stream);
          });

          try {
            pino({
              useOnlyCustomLevels: true
            }, stream);
          } catch (_ref22) {
            message = _ref22.message;
            is(message, 'customLevels is required if useOnlyCustomLevels is set true');
          }

        case 4:
        case "end":
          return _context12.stop();
      }
    }
  });
});
test('custom level on one instance does not affect other instances', function _callee13(_ref23) {
  var is;
  return regeneratorRuntime.async(function _callee13$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          is = _ref23.is;
          pino({
            customLevels: {
              foo: 37
            }
          });
          is(_typeof(pino().foo), 'undefined');

        case 3:
        case "end":
          return _context13.stop();
      }
    }
  });
});
test('setting level below or at custom level will successfully log', function _callee14(_ref24) {
  var is, stream, instance, _ref25, msg;

  return regeneratorRuntime.async(function _callee14$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          is = _ref24.is;
          stream = sink();
          instance = pino({
            customLevels: {
              foo: 35
            }
          }, stream);
          instance.level = 'foo';
          instance.info('nope');
          instance.foo('bar');
          _context14.next = 8;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 8:
          _ref25 = _context14.sent;
          msg = _ref25.msg;
          is(msg, 'bar');

        case 11:
        case "end":
          return _context14.stop();
      }
    }
  });
});
test('custom level below level threshold will not log', function _callee15(_ref26) {
  var is, stream, instance, _ref27, msg;

  return regeneratorRuntime.async(function _callee15$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          is = _ref26.is;
          stream = sink();
          instance = pino({
            customLevels: {
              foo: 15
            }
          }, stream);
          instance.level = 'info';
          instance.info('bar');
          instance.foo('nope');
          _context15.next = 8;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 8:
          _ref27 = _context15.sent;
          msg = _ref27.msg;
          is(msg, 'bar');

        case 11:
        case "end":
          return _context15.stop();
      }
    }
  });
});
test('does not share custom level state across siblings', function _callee16(_ref28) {
  var doesNotThrow, stream, logger;
  return regeneratorRuntime.async(function _callee16$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          doesNotThrow = _ref28.doesNotThrow;
          stream = sink();
          logger = pino(stream);
          logger.child({
            customLevels: {
              foo: 35
            }
          });
          doesNotThrow(function () {
            logger.child({
              customLevels: {
                foo: 35
              }
            });
          });

        case 5:
        case "end":
          return _context16.stop();
      }
    }
  });
});
test('custom level does not affect changeLevelName', function _callee17(_ref29) {
  var is, stream, logger, _ref30, priority;

  return regeneratorRuntime.async(function _callee17$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          is = _ref29.is;
          stream = sink();
          logger = pino({
            customLevels: {
              foo: 35,
              bar: 45
            },
            changeLevelName: 'priority'
          }, stream);
          logger.foo('test');
          _context17.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          _ref30 = _context17.sent;
          priority = _ref30.priority;
          is(priority, 35);

        case 9:
        case "end":
          return _context17.stop();
      }
    }
  });
});