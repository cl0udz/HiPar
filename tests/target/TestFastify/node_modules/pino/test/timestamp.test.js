'use strict';
/* eslint no-prototype-builtins: 0 */

var _require = require('tap'),
    test = _require.test;

var _require2 = require('./helper'),
    sink = _require2.sink,
    once = _require2.once;

var pino = require('../');

test('pino exposes standard time functions', function _callee(_ref) {
  var ok;
  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          ok = _ref.ok;
          ok(pino.stdTimeFunctions);
          ok(pino.stdTimeFunctions.epochTime);
          ok(pino.stdTimeFunctions.unixTime);
          ok(pino.stdTimeFunctions.nullTime);

        case 5:
        case "end":
          return _context.stop();
      }
    }
  });
});
test('pino accepts external time functions', function _callee2(_ref2) {
  var is, opts, stream, instance, result;
  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          is = _ref2.is;
          opts = {
            timestamp: function timestamp() {
              return ',"time":"none"';
            }
          };
          stream = sink();
          instance = pino(opts, stream);
          instance.info('foobar');
          _context2.next = 7;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 7:
          result = _context2.sent;
          is(result.hasOwnProperty('time'), true);
          is(result.time, 'none');

        case 10:
        case "end":
          return _context2.stop();
      }
    }
  });
});
test('pino accepts external time functions with custom label', function _callee3(_ref3) {
  var is, opts, stream, instance, result;
  return regeneratorRuntime.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          is = _ref3.is;
          opts = {
            timestamp: function timestamp() {
              return ',"custom-time-label":"none"';
            }
          };
          stream = sink();
          instance = pino(opts, stream);
          instance.info('foobar');
          _context3.next = 7;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 7:
          result = _context3.sent;
          is(result.hasOwnProperty('custom-time-label'), true);
          is(result['custom-time-label'], 'none');

        case 10:
        case "end":
          return _context3.stop();
      }
    }
  });
});
test('inserts timestamp by default', function _callee4(_ref4) {
  var ok, is, stream, instance, result;
  return regeneratorRuntime.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          ok = _ref4.ok, is = _ref4.is;
          stream = sink();
          instance = pino(stream);
          instance.info('foobar');
          _context4.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          result = _context4.sent;
          is(result.hasOwnProperty('time'), true);
          ok(new Date(result.time) <= new Date(), 'time is greater than timestamp');
          is(result.msg, 'foobar');

        case 10:
        case "end":
          return _context4.stop();
      }
    }
  });
});
test('omits timestamp when timestamp option is false', function _callee5(_ref5) {
  var is, stream, instance, result;
  return regeneratorRuntime.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          is = _ref5.is;
          stream = sink();
          instance = pino({
            timestamp: false
          }, stream);
          instance.info('foobar');
          _context5.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          result = _context5.sent;
          is(result.hasOwnProperty('time'), false);
          is(result.msg, 'foobar');

        case 9:
        case "end":
          return _context5.stop();
      }
    }
  });
});
test('inserts timestamp when timestamp option is true', function _callee6(_ref6) {
  var ok, is, stream, instance, result;
  return regeneratorRuntime.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          ok = _ref6.ok, is = _ref6.is;
          stream = sink();
          instance = pino({
            timestamp: true
          }, stream);
          instance.info('foobar');
          _context6.next = 6;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 6:
          result = _context6.sent;
          is(result.hasOwnProperty('time'), true);
          ok(new Date(result.time) <= new Date(), 'time is greater than timestamp');
          is(result.msg, 'foobar');

        case 10:
        case "end":
          return _context6.stop();
      }
    }
  });
});
test('child inserts timestamp by default', function _callee7(_ref7) {
  var ok, is, stream, logger, instance, result;
  return regeneratorRuntime.async(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          ok = _ref7.ok, is = _ref7.is;
          stream = sink();
          logger = pino(stream);
          instance = logger.child({
            component: 'child'
          });
          instance.info('foobar');
          _context7.next = 7;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 7:
          result = _context7.sent;
          is(result.hasOwnProperty('time'), true);
          ok(new Date(result.time) <= new Date(), 'time is greater than timestamp');
          is(result.msg, 'foobar');

        case 11:
        case "end":
          return _context7.stop();
      }
    }
  });
});
test('child omits timestamp with option', function _callee8(_ref8) {
  var is, stream, logger, instance, result;
  return regeneratorRuntime.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          is = _ref8.is;
          stream = sink();
          logger = pino({
            timestamp: false
          }, stream);
          instance = logger.child({
            component: 'child'
          });
          instance.info('foobar');
          _context8.next = 7;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 7:
          result = _context8.sent;
          is(result.hasOwnProperty('time'), false);
          is(result.msg, 'foobar');

        case 10:
        case "end":
          return _context8.stop();
      }
    }
  });
});
test('pino.stdTimeFunctions.unixTime returns seconds based timestamps', function _callee9(_ref9) {
  var is, opts, stream, instance, now, result;
  return regeneratorRuntime.async(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          is = _ref9.is;
          opts = {
            timestamp: pino.stdTimeFunctions.unixTime
          };
          stream = sink();
          instance = pino(opts, stream);
          now = Date.now;

          Date.now = function () {
            return 1531069919686;
          };

          instance.info('foobar');
          _context9.next = 9;
          return regeneratorRuntime.awrap(once(stream, 'data'));

        case 9:
          result = _context9.sent;
          is(result.hasOwnProperty('time'), true);
          is(result.time, 1531069920);
          Date.now = now;

        case 13:
        case "end":
          return _context9.stop();
      }
    }
  });
});