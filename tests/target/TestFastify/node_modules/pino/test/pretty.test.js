'use strict';

var _require = require('stream'),
    Writable = _require.Writable;

var _require2 = require('tap'),
    test = _require2.test;

var _require3 = require('path'),
    join = _require3.join;

var execa = require('execa');

var writer = require('flush-write-stream');

var _require4 = require('./helper'),
    once = _require4.once;

var pino = require('../');

var tap = require('tap');

var isWin = process.platform === 'win32';

if (isWin) {
  tap.comment('Skipping pretty printing tests on Windows as colour codes are different and tests fail');
  process.exit(0);
}

test('can be enabled via exported pino function', function _callee(_ref) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          isNot = _ref.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'basic.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): h/), null);

        case 7:
        case "end":
          return _context.stop();
      }
    }
  });
});
test('can be enabled via exported pino function with pretty configuration', function _callee2(_ref2) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          isNot = _ref2.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'level-first.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context2.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/^INFO.*h/), null);

        case 7:
        case "end":
          return _context2.stop();
      }
    }
  });
});
test('can be enabled via exported pino function with prettifier', function _callee3(_ref3) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          isNot = _ref3.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'pretty-factory.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context3.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/^INFO.*h/), null);

        case 7:
        case "end":
          return _context3.stop();
      }
    }
  });
});
test('does not throw error when enabled with stream specified', function _callee4(_ref4) {
  var doesNotThrow;
  return regeneratorRuntime.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          doesNotThrow = _ref4.doesNotThrow;
          doesNotThrow(function () {
            return pino({
              prettyPrint: true
            }, process.stdout);
          });

        case 2:
        case "end":
          return _context4.stop();
      }
    }
  });
});
test('throws when prettyPrint is true but pino-pretty module is not installed', function _callee5(_ref5) {
  var throws, is, prettyFactory, message;
  return regeneratorRuntime.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          throws = _ref5.throws, is = _ref5.is; // pino pretty *is* installed, and probably also cached, so rather than
          // messing with the filesystem the simplest way to generate a not found
          // error is to simulate it:

          prettyFactory = require('pino-pretty');

          require.cache[require.resolve('pino-pretty')].exports = function () {
            throw Error('Cannot find module \'pino-pretty\'');
          };

          throws(function () {
            return pino({
              prettyPrint: true
            });
          });

          try {
            pino({
              prettyPrint: true
            });
          } catch (_ref6) {
            message = _ref6.message;
            is(message, 'Missing `pino-pretty` module: `pino-pretty` must be installed separately');
          }

          require.cache[require.resolve('pino-pretty')].exports = prettyFactory;

        case 6:
        case "end":
          return _context5.stop();
      }
    }
  });
});
test('can send pretty print to custom stream', function _callee6(_ref7) {
  var is, dest, log;
  return regeneratorRuntime.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          is = _ref7.is;
          dest = new Writable({
            objectMode: true,

            write(formatted, enc) {
              is(/^INFO.*foo\n$/.test(formatted), true);
            }

          });
          log = pino({
            prettifier: require('pino-pretty'),
            prettyPrint: {
              levelFirst: true,
              colorize: false
            }
          }, dest);
          log.info('foo');

        case 4:
        case "end":
          return _context6.stop();
      }
    }
  });
});
test('ignores `undefined` from prettifier', function _callee7(_ref8) {
  var is, actual, child;
  return regeneratorRuntime.async(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          is = _ref8.is;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'skipped-output.js')]);
          child.stdout.pipe(writer(function (s, enc) {
            actual += s;
          }));
          _context7.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          is(actual, '');

        case 7:
        case "end":
          return _context7.stop();
      }
    }
  });
});
test('parses and outputs chindings', function _callee8(_ref9) {
  var is, isNot, actual, child;
  return regeneratorRuntime.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          is = _ref9.is, isNot = _ref9.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'child.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context8.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): h/), null);
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): h2/), null);
          isNot(actual.match(/a: 1/), null);
          isNot(actual.match(/b: 2/), null);
          is(actual.match(/a: 1/g).length, 3);

        case 11:
        case "end":
          return _context8.stop();
      }
    }
  });
});
test('applies serializers', function _callee9(_ref10) {
  var is, isNot, actual, child;
  return regeneratorRuntime.async(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          is = _ref10.is, isNot = _ref10.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'serializers.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context9.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): h/), null);
          isNot(actual.match(/foo: "bar"/), null);

        case 8:
        case "end":
          return _context9.stop();
      }
    }
  });
});
test('applies redaction rules', function _callee10(_ref11) {
  var is, isNot, actual, child;
  return regeneratorRuntime.async(function _callee10$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          is = _ref11.is, isNot = _ref11.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'redact.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context10.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): h/), null);
          isNot(actual.match(/\[Redacted\]/), null);
          is(actual.match(/object/), null);

        case 9:
        case "end":
          return _context10.stop();
      }
    }
  });
});
test('dateformat', function _callee11(_ref12) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee11$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          isNot = _ref12.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'dateformat.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context11.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): h/), null);

        case 7:
        case "end":
          return _context11.stop();
      }
    }
  });
});
test('without timestamp', function _callee12(_ref13) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee12$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          isNot = _ref13.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'no-time.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context12.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.slice(2), '[]');

        case 7:
        case "end":
          return _context12.stop();
      }
    }
  });
});
test('with custom timestamp', function _callee13(_ref14) {
  var is, actual, child;
  return regeneratorRuntime.async(function _callee13$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          is = _ref14.is;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'custom-time.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context13.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          is(actual.slice(0, 8), '["test"]');

        case 7:
        case "end":
          return _context13.stop();
      }
    }
  });
});
test('with custom timestamp label', function _callee14(_ref15) {
  var is, actual, child;
  return regeneratorRuntime.async(function _callee14$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          is = _ref15.is;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'custom-time-label.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context14.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          is(actual.slice(0, 8), '["test"]');

        case 7:
        case "end":
          return _context14.stop();
      }
    }
  });
});
test('errors', function _callee15(_ref16) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee15$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          isNot = _ref16.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'error.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context15.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): kaboom/), null);
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): with a message/), null);
          isNot(actual.match(/.*error\.js.*/), null);

        case 9:
        case "end":
          return _context15.stop();
      }
    }
  });
});
test('errors with props', function _callee16(_ref17) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee16$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          isNot = _ref17.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'error-props.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context16.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): kaboom/), null);
          isNot(actual.match(/code: ENOENT/), null);
          isNot(actual.match(/errno: 1/), null);
          isNot(actual.match(/.*error-props\.js.*/), null);

        case 10:
        case "end":
          return _context16.stop();
      }
    }
  });
});
test('final works with pretty', function _callee17(_ref18) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee17$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          isNot = _ref18.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'final.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context17.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/WARN\s+\(123456 on abcdefghijklmnopqr\): pino.final with prettyPrint does not support flushing/), null);
          isNot(actual.match(/INFO\s+\(123456 on abcdefghijklmnopqr\): beforeExit/), null);

        case 8:
        case "end":
          return _context17.stop();
      }
    }
  });
});
test('final works when returning a logger', function _callee18(_ref19) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee18$(_context18) {
    while (1) {
      switch (_context18.prev = _context18.next) {
        case 0:
          isNot = _ref19.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'final-return.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context18.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/WARN\s+\(123456 on abcdefghijklmnopqr\): pino.final with prettyPrint does not support flushing/), null);
          isNot(actual.match(/INFO\s+\(123456 on abcdefghijklmnopqr\): after/), null);

        case 8:
        case "end":
          return _context18.stop();
      }
    }
  });
});
test('final works without prior logging', function _callee19(_ref20) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee19$(_context19) {
    while (1) {
      switch (_context19.prev = _context19.next) {
        case 0:
          isNot = _ref20.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'final-no-log-before.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context19.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/WARN\s+: pino.final with prettyPrint does not support flushing/), null);
          isNot(actual.match(/INFO\s+\(123456 on abcdefghijklmnopqr\): beforeExit/), null);

        case 8:
        case "end":
          return _context19.stop();
      }
    }
  });
});
test('works as expected with an object with the msg prop', function _callee20(_ref21) {
  var isNot, actual, child;
  return regeneratorRuntime.async(function _callee20$(_context20) {
    while (1) {
      switch (_context20.prev = _context20.next) {
        case 0:
          isNot = _ref21.isNot;
          actual = '';
          child = execa(process.argv[0], [join(__dirname, 'fixtures', 'pretty', 'obj-msg-prop.js')]);
          child.stdout.pipe(writer(function (s, enc, cb) {
            actual += s;
            cb();
          }));
          _context20.next = 6;
          return regeneratorRuntime.awrap(once(child, 'close'));

        case 6:
          isNot(actual.match(/\(123456 on abcdefghijklmnopqr\): hello/), null);

        case 7:
        case "end":
          return _context20.stop();
      }
    }
  });
});