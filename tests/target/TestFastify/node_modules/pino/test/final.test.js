'use strict';

var pino = require('..');

var fs = require('fs');

var _require = require('tap'),
    test = _require.test;

var _require2 = require('./helper'),
    sleep = _require2.sleep,
    getPathToNull = _require2.getPathToNull;

test('replaces onTerminated option', function _callee(_ref) {
  var throws;
  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          throws = _ref.throws;
          throws(function () {
            pino({
              onTerminated: function onTerminated() {}
            });
          }, Error('The onTerminated option has been removed, use pino.final instead'));

        case 2:
        case "end":
          return _context.stop();
      }
    }
  });
});
test('throws if not supplied a logger instance', function _callee2(_ref2) {
  var throws;
  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          throws = _ref2.throws;
          throws(function () {
            pino.final();
          }, Error('expected a pino logger instance'));

        case 2:
        case "end":
          return _context2.stop();
      }
    }
  });
});
test('throws if the supplied handler is not a function', function _callee3(_ref3) {
  var throws;
  return regeneratorRuntime.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          throws = _ref3.throws;
          throws(function () {
            pino.final(pino(), 'dummy');
          }, Error('if supplied, the handler parameter should be a function'));

        case 2:
        case "end":
          return _context3.stop();
      }
    }
  });
});
test('throws if not supplied logger with pino.extreme instance', function _callee4(_ref4) {
  var throws, doesNotThrow;
  return regeneratorRuntime.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          throws = _ref4.throws, doesNotThrow = _ref4.doesNotThrow;
          throws(function () {
            pino.final(pino(fs.createWriteStream(getPathToNull())), function () {});
          }, Error('final requires a stream that has a flushSync method, such as pino.destination and pino.extreme'));
          doesNotThrow(function () {
            pino.final(pino(pino.extreme()), function () {});
          });
          doesNotThrow(function () {
            pino.final(pino(pino.extreme()), function () {});
          });

        case 4:
        case "end":
          return _context4.stop();
      }
    }
  });
});
test('returns an exit listener function', function _callee5(_ref5) {
  var is;
  return regeneratorRuntime.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          is = _ref5.is;
          is(typeof pino.final(pino(pino.extreme()), function () {}), 'function');

        case 2:
        case "end":
          return _context5.stop();
      }
    }
  });
});
test('listener function immediately sync flushes when fired', function _callee6(_ref6) {
  var pass, fail, dest, passed;
  return regeneratorRuntime.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          pass = _ref6.pass, fail = _ref6.fail;
          dest = pino.extreme(getPathToNull());
          passed = false;

          dest.flushSync = function () {
            passed = true;
            pass('flushSync called');
          };

          pino.final(pino(dest), function () {})();
          _context6.next = 7;
          return regeneratorRuntime.awrap(sleep(10));

        case 7:
          if (passed === false) fail('flushSync not called');

        case 8:
        case "end":
          return _context6.stop();
      }
    }
  });
});
test('listener function immediately sync flushes when fired (pino.destination)', function _callee7(_ref7) {
  var pass, fail, dest, passed;
  return regeneratorRuntime.async(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          pass = _ref7.pass, fail = _ref7.fail;
          dest = pino.destination(getPathToNull());
          passed = false;

          dest.flushSync = function () {
            passed = true;
            pass('flushSync called');
          };

          pino.final(pino(dest), function () {})();
          _context7.next = 7;
          return regeneratorRuntime.awrap(sleep(10));

        case 7:
          if (passed === false) fail('flushSync not called');

        case 8:
        case "end":
          return _context7.stop();
      }
    }
  });
});
test('swallows the non-ready error', function _callee8(_ref8) {
  var doesNotThrow, dest;
  return regeneratorRuntime.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          doesNotThrow = _ref8.doesNotThrow;
          dest = pino.extreme(getPathToNull());
          doesNotThrow(function () {
            pino.final(pino(dest), function () {})();
          });

        case 3:
        case "end":
          return _context8.stop();
      }
    }
  });
});
test('listener function triggers handler function parameter', function _callee9(_ref9) {
  var pass, fail, dest, passed;
  return regeneratorRuntime.async(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          pass = _ref9.pass, fail = _ref9.fail;
          dest = pino.extreme(getPathToNull());
          passed = false;
          pino.final(pino(dest), function () {
            passed = true;
            pass('handler function triggered');
          })();
          _context9.next = 6;
          return regeneratorRuntime.awrap(sleep(10));

        case 6:
          if (passed === false) fail('handler function not triggered');

        case 7:
        case "end":
          return _context9.stop();
      }
    }
  });
});
test('passes any error to the handler', function _callee10(_ref10) {
  var is, dest;
  return regeneratorRuntime.async(function _callee10$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          is = _ref10.is;
          dest = pino.extreme(getPathToNull());
          pino.final(pino(dest), function (err) {
            is(err.message, 'test');
          })(Error('test'));

        case 3:
        case "end":
          return _context10.stop();
      }
    }
  });
});
test('passes a specialized final logger instance', function _callee11(_ref11) {
  var is, isNot, error, dest, logger;
  return regeneratorRuntime.async(function _callee11$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          is = _ref11.is, isNot = _ref11.isNot, error = _ref11.error;
          dest = pino.extreme(getPathToNull());
          logger = pino(dest);
          pino.final(logger, function (err, finalLogger) {
            error(err);
            is(typeof finalLogger.trace, 'function');
            is(typeof finalLogger.debug, 'function');
            is(typeof finalLogger.info, 'function');
            is(typeof finalLogger.warn, 'function');
            is(typeof finalLogger.error, 'function');
            is(typeof finalLogger.fatal, 'function');
            isNot(finalLogger.trace, logger.trace);
            isNot(finalLogger.debug, logger.debug);
            isNot(finalLogger.info, logger.info);
            isNot(finalLogger.warn, logger.warn);
            isNot(finalLogger.error, logger.error);
            isNot(finalLogger.fatal, logger.fatal);
            is(finalLogger.child, logger.child);
            is(finalLogger.levels, logger.levels);
          })();

        case 4:
        case "end":
          return _context11.stop();
      }
    }
  });
});
test('returns a specialized final logger instance if no handler is passed', function _callee12(_ref12) {
  var is, isNot, dest, logger, finalLogger;
  return regeneratorRuntime.async(function _callee12$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          is = _ref12.is, isNot = _ref12.isNot;
          dest = pino.extreme(getPathToNull());
          logger = pino(dest);
          finalLogger = pino.final(logger);
          is(typeof finalLogger.trace, 'function');
          is(typeof finalLogger.debug, 'function');
          is(typeof finalLogger.info, 'function');
          is(typeof finalLogger.warn, 'function');
          is(typeof finalLogger.error, 'function');
          is(typeof finalLogger.fatal, 'function');
          isNot(finalLogger.trace, logger.trace);
          isNot(finalLogger.debug, logger.debug);
          isNot(finalLogger.info, logger.info);
          isNot(finalLogger.warn, logger.warn);
          isNot(finalLogger.error, logger.error);
          isNot(finalLogger.fatal, logger.fatal);
          is(finalLogger.child, logger.child);
          is(finalLogger.levels, logger.levels);

        case 18:
        case "end":
          return _context12.stop();
      }
    }
  });
});
test('final logger instances synchronously flush after a log method call', function _callee13(_ref13) {
  var pass, fail, error, dest, logger, passed, count;
  return regeneratorRuntime.async(function _callee13$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          pass = _ref13.pass, fail = _ref13.fail, error = _ref13.error;
          dest = pino.extreme(getPathToNull());
          logger = pino(dest);
          passed = false;
          count = 0;

          dest.flushSync = function () {
            count++;

            if (count === 2) {
              passed = true;
              pass('flushSync called');
            }
          };

          pino.final(logger, function (err, finalLogger) {
            error(err);
            finalLogger.info('hello');
          })();
          _context13.next = 9;
          return regeneratorRuntime.awrap(sleep(10));

        case 9:
          if (passed === false) fail('flushSync not called');

        case 10:
        case "end":
          return _context13.stop();
      }
    }
  });
});
test('also instruments custom log methods', function _callee14(_ref14) {
  var pass, fail, error, dest, logger, passed, count;
  return regeneratorRuntime.async(function _callee14$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          pass = _ref14.pass, fail = _ref14.fail, error = _ref14.error;
          dest = pino.extreme(getPathToNull());
          logger = pino({
            customLevels: {
              foo: 35
            }
          }, dest);
          passed = false;
          count = 0;

          dest.flushSync = function () {
            count++;

            if (count === 2) {
              passed = true;
              pass('flushSync called');
            }
          };

          pino.final(logger, function (err, finalLogger) {
            error(err);
            finalLogger.foo('hello');
          })();
          _context14.next = 9;
          return regeneratorRuntime.awrap(sleep(10));

        case 9:
          if (passed === false) fail('flushSync not called');

        case 10:
        case "end":
          return _context14.stop();
      }
    }
  });
});