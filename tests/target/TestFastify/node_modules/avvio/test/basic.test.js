'use strict';

var t = require('tap');

var test = t.test;

var boot = require('..');

test('boot an empty app', function (t) {
  t.plan(1);
  var app = boot();
  app.on('start', function () {
    t.pass('booted');
  });
});
test('start returns app', function (t) {
  t.plan(1);
  var app = boot({}, {
    autostart: false
  });
  app.start().ready(function (err) {
    t.error(err);
  });
});
test('boot an app with a plugin', function (t) {
  t.plan(4);
  var app = boot();
  var after = false;
  app.use(function (server, opts, done) {
    t.equal(server, app, 'the first argument is the server');
    t.deepEqual(opts, {}, 'no options');
    t.ok(after, 'delayed execution');
    done();
  });
  after = true;
  app.on('start', function () {
    t.pass('booted');
  });
});
test('boot an app with a promisified plugin', function (t) {
  t.plan(4);
  var app = boot();
  var after = false;
  app.use(function (server, opts) {
    t.equal(server, app, 'the first argument is the server');
    t.deepEqual(opts, {}, 'no options');
    t.ok(after, 'delayed execution');
    return Promise.resolve();
  });
  after = true;
  app.on('start', function () {
    t.pass('booted');
  });
});
test('boot an app with a plugin and a callback', function (t) {
  t.plan(2);
  var app = boot(function () {
    t.pass('booted');
  });
  app.use(function (server, opts, done) {
    t.pass('plugin loaded');
    done();
  });
});
test('boot a plugin with a custom server', function (t) {
  t.plan(4);
  var server = {};
  var app = boot(server);
  app.use(function (s, opts, done) {
    t.equal(s, server, 'the first argument is the server');
    t.deepEqual(opts, {}, 'no options');
    done();
  });
  app.onClose(function () {
    t.ok('onClose called');
  });
  app.on('start', function () {
    app.close(function () {
      t.pass('booted');
    });
  });
});
test('custom instance should inherits avvio methods', function (t) {
  t.plan(6);
  var server = {};
  var app = boot(server, {});
  server.use(function (s, opts, done) {
    t.equal(s, server, 'the first argument is the server');
    t.deepEqual(opts, {}, 'no options');
    done();
  }).after(function () {
    t.ok('after called');
  });
  server.onClose(function () {
    t.ok('onClose called');
  });
  server.ready(function () {
    t.ok('ready called');
  });
  app.on('start', function () {
    server.close(function () {
      t.pass('booted');
    });
  });
});
test('boot a plugin with options', function (t) {
  t.plan(3);
  var server = {};
  var app = boot(server);
  var myOpts = {
    hello: 'world'
  };
  app.use(function (s, opts, done) {
    t.equal(s, server, 'the first argument is the server');
    t.deepEqual(opts, myOpts, 'passed options');
    done();
  }, myOpts);
  app.on('start', function () {
    t.pass('booted');
  });
});
test('boot a plugin with a function that returns the options', function (t) {
  t.plan(4);
  var server = {};
  var app = boot(server);
  var myOpts = {
    hello: 'world'
  };

  var myOptsAsFunc = function myOptsAsFunc(parent) {
    t.strictEqual(parent, server);
    return parent.myOpts;
  };

  app.use(function (s, opts, done) {
    s.myOpts = opts;
    done();
  }, myOpts);
  app.use(function (s, opts, done) {
    t.equal(s, server, 'the first argument is the server');
    t.deepEqual(opts, myOpts, 'passed options via function accessing parent injected variable');
    done();
  }, myOptsAsFunc);
  app.on('start', function () {
    t.pass('booted');
  });
});
test('throw on non-function use', function (t) {
  t.plan(1);
  var app = boot();
  t.throws(function () {
    app.use({});
  });
}); // https://github.com/mcollina/avvio/issues/20

test('ready and nextTick', function (t) {
  var app = boot();
  process.nextTick(function () {
    app.ready(function () {
      t.end();
    });
  });
}); // https://github.com/mcollina/avvio/issues/20

test('promises and microtask', function (t) {
  var app = boot();
  Promise.resolve().then(function () {
    app.ready(function () {
      t.end();
    });
  });
});
test('always loads nested plugins after the current one', function (t) {
  t.plan(2);
  var server = {};
  var app = boot(server);
  var second = false;
  app.use(function (s, opts, done) {
    app.use(function (s, opts, done) {
      second = true;
      done();
    });
    t.notOk(second);
    done();
  });
  app.on('start', function () {
    t.ok(second);
  });
});
test('promise long resolve', function (t) {
  t.plan(2);
  var app = boot();
  setTimeout(function () {
    t.throws(function () {
      app.use(function (s, opts, done) {
        done();
      });
    }, 'root plugin has already booted');
  });
  app.ready(function (err) {
    t.notOk(err);
  });
});
test('do not autostart', function (t) {
  var app = boot(null, {
    autostart: false
  });
  app.on('start', function () {
    t.fail();
  });
  t.end();
});
test('start with ready', function (t) {
  t.plan(2);
  var app = boot(null, {
    autostart: false
  });
  app.on('start', function () {
    t.pass();
  });
  app.ready(function (err) {
    t.error(err);
  });
});
test('load a plugin after start()', function (t) {
  t.plan(1);
  var startCalled = false;
  var app = boot(null, {
    autostart: false
  });
  app.use(function (s, opts, done) {
    t.ok(startCalled);
    done();
  }); // we use a timer because
  // it is more reliable than
  // nextTick and setImmediate
  // this almost always will come
  // after those are completed

  setTimeout(function () {
    app.start();
    startCalled = true;
  }, 2);
});
test('booted should be set before ready', function (t) {
  t.plan(2);
  var app = boot();
  app.ready(function (err) {
    t.error(err);
    t.equal(app.booted, true);
  });
});
test('throws correctly if registering after ready', function (t) {
  t.plan(1);
  var app = boot();
  app.ready(function () {
    t.throws(function () {
      app.use(function (a, b, done) {
        return done();
      });
    }, 'root plugin has already booted');
  });
});