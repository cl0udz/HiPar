'use strict';

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.now");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.timers");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.now");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.timers");

var fastq = require('fastq');

var EE = require('events').EventEmitter;

var inherits = require('util').inherits;

var debug = require('debug')('avvio');

var CODE_PLUGIN_TIMEOUT = 'ERR_AVVIO_PLUGIN_TIMEOUT';

function getName(func) {
  // let's see if this is a file, and in that case use that
  // this is common for plugins
  var cache = require.cache;
  var keys = Object.keys(cache);

  for (var i = 0; i < keys.length; i++) {
    if (cache[keys[i]].exports === func) {
      return keys[i];
    }
  } // if not maybe it's a named function, so use that


  if (func.name) {
    return func.name;
  } // takes the first two lines of the function if nothing else works


  return func.toString().split('\n').slice(0, 2).map(function (s) {
    return s.trim();
  }).join(' -- ');
}

function Plugin(parent, func, optsOrFunc, isAfter, timeout) {
  this.func = func;
  this.opts = optsOrFunc;
  this.deferred = false;
  this.onFinish = null;
  this.parent = parent;
  this.timeout = timeout === undefined ? parent._timeout : timeout;
  this.name = getName(func);
  this.isAfter = isAfter;
  this.q = fastq(parent, loadPlugin, 1);
  this.q.pause();
  this.loaded = false; // always start the queue in the next tick
  // because we try to attach subsequent call to use()
  // to the right plugin. we need to defer them,
  // or they will end up at the top of _current
}

inherits(Plugin, EE);

Plugin.prototype.exec = function (server, cb) {
  var func = this.func;
  var completed = false;
  var name = this.name;

  if (this.parent._error && !this.isAfter) {
    debug('skipping loading of plugin as parent errored and it is not an after', name);
    process.nextTick(cb);
    return;
  }

  try {
    this.server = this.parent.override(server, func, this.opts);
  } catch (err) {
    debug('override errored', name);
    return cb(err);
  }

  this.opts = typeof this.opts === 'function' ? this.opts(this.server) : this.opts;
  debug('exec', name);
  var timer;

  if (this.timeout > 0) {
    debug('setting up timeout', name, this.timeout);
    timer = setTimeout(function () {
      debug('timed out', name);
      timer = null;
      var err = new Error("".concat(CODE_PLUGIN_TIMEOUT, ": plugin did not start in time: ").concat(name));
      err.code = CODE_PLUGIN_TIMEOUT;
      err.fn = func;
      done(err);
    }, this.timeout);
  }

  this.emit('start', this.server ? this.server.name : null, this.name, Date.now());
  var promise = func(this.server, this.opts, done);

  if (promise && typeof promise.then === 'function') {
    debug('resolving promise', name);
    promise.then(function () {
      return process.nextTick(done);
    }, function (e) {
      return process.nextTick(done, e);
    });
  }

  function done(err) {
    if (completed) {
      debug('loading complete', name);
      return;
    }

    if (err) {
      debug('exec errored', name);
    } else {
      debug('exec completed', name);
    }

    completed = true;

    if (timer) {
      clearTimeout(timer);
    }

    cb(err);
  }
};

Plugin.prototype.enqueue = function (obj, cb) {
  debug('enqueue', this.name, obj.name);
  this.emit('enqueue', this.server ? this.server.name : null, this.name, Date.now());
  this.q.push(obj, cb);
};

Plugin.prototype.finish = function (err, cb) {
  var _this = this;

  debug('finish', this.name);

  var done = function done() {
    if (_this.loaded) {
      return;
    }

    debug('loaded', _this.name);

    _this.emit('loaded', _this.server ? _this.server.name : null, _this.name, Date.now());

    _this.loaded = true;
    cb(err);
  };

  if (err) {
    done();
    return;
  }

  var check = function check() {
    debug('check', _this.name, _this.q.length(), _this.q.running());

    if (_this.q.length() === 0 && _this.q.running() === 0) {
      done();
    } else {
      debug('delayed', _this.name); // finish when the queue of nested plugins to load is empty

      _this.q.drain = function () {
        debug('drain', _this.name);
        _this.q.drain = noop; // we defer the check, as a safety net for things
        // that might be scheduled in the loading callback

        process.nextTick(check);
      };
    }
  };

  process.nextTick(check); // we start loading the dependents plugins only once
  // the current level is finished

  this.q.resume();
}; // loads a plugin


function loadPlugin(toLoad, cb) {
  var _this2 = this;

  var last = this._current[0]; // place the plugin at the top of _current

  this._current.unshift(toLoad);

  toLoad.exec(last && last.server || this._server, function (err) {
    toLoad.finish(err, function (err) {
      _this2._current.shift();

      cb(err);
    });
  });
}

function noop() {}

module.exports = Plugin;
module.exports.loadPlugin = loadPlugin;