'use strict';

var net = require('net');

var t = require('tap');

var test = t.test;

var Fastify = require('..');

test('close callback', function (t) {
  t.plan(4);
  var fastify = Fastify();
  fastify.addHook('onClose', onClose);

  function onClose(instance, done) {
    t.type(fastify, instance);
    done();
  }

  fastify.listen(0, function (err) {
    t.error(err);
    fastify.close(function (err) {
      t.error(err);
      t.ok('close callback');
    });
  });
});
test('inside register', function (t) {
  t.plan(5);
  var fastify = Fastify();
  fastify.register(function (f, opts, next) {
    f.addHook('onClose', onClose);

    function onClose(instance, done) {
      t.ok(instance.prototype === fastify.prototype);
      t.strictEqual(instance, f);
      done();
    }

    next();
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.close(function (err) {
      t.error(err);
      t.ok('close callback');
    });
  });
});
test('close order', function (t) {
  t.plan(5);
  var fastify = Fastify();
  var order = [1, 2, 3];
  fastify.register(function (f, opts, next) {
    f.addHook('onClose', function (instance, done) {
      t.is(order.shift(), 1);
      done();
    });
    next();
  });
  fastify.addHook('onClose', function (instance, done) {
    t.is(order.shift(), 2);
    done();
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.close(function (err) {
      t.error(err);
      t.is(order.shift(), 3);
    });
  });
});
test('should not throw an error if the server is not listening', function (t) {
  t.plan(2);
  var fastify = Fastify();
  fastify.addHook('onClose', onClose);

  function onClose(instance, done) {
    t.type(fastify, instance);
    done();
  }

  fastify.close(function (err) {
    t.error(err);
  });
});
test('onClose should keep the context', function (t) {
  t.plan(4);
  var fastify = Fastify();
  fastify.register(plugin);

  function plugin(instance, opts, next) {
    instance.decorate('test', true);
    instance.addHook('onClose', onClose);
    t.ok(instance.prototype === fastify.prototype);

    function onClose(i, done) {
      t.ok(i.test);
      t.strictEqual(i, instance);
      done();
    }

    next();
  }

  fastify.close(function (err) {
    t.error(err);
  });
});
test('Should return error while closing - injection', function (t) {
  t.plan(4);
  var fastify = Fastify();
  fastify.addHook('onClose', function (instance, done) {
    setTimeout(done, 150);
  });
  fastify.get('/', function (req, reply) {
    reply.send({
      hello: 'world'
    });
  });
  fastify.inject({
    method: 'GET',
    url: '/'
  }, function (err, res) {
    t.error(err);
    t.strictEqual(res.statusCode, 200);
    fastify.close();
    setTimeout(function () {
      fastify.inject({
        method: 'GET',
        url: '/'
      }, function (err, res) {
        t.ok(err);
        t.equal(err.message, 'Server is closed');
      });
    }, 100);
  });
});
t.test('Current opened connection should continue to work after closing and return "connection: close" header - return503OnClosing: false', function (t) {
  var fastify = Fastify({
    return503OnClosing: false
  });
  fastify.get('/', function (req, reply) {
    fastify.close();
    reply.send({
      hello: 'world'
    });
  });
  fastify.listen(0, function (err) {
    t.error(err);
    var port = fastify.server.address().port;
    var client = net.createConnection({
      port: port
    }, function () {
      client.write('GET / HTTP/1.1\r\n\r\n');
      client.once('data', function (data) {
        t.match(data.toString(), /Connection:\s*keep-alive/i);
        t.match(data.toString(), /200 OK/i);
        client.write('GET / HTTP/1.1\r\n\r\n');
        client.once('data', function (data) {
          t.match(data.toString(), /Connection:\s*close/i);
          t.match(data.toString(), /200 OK/i); // Test that fastify closes the TCP connection

          client.once('close', function () {
            t.end();
          });
        });
      });
    });
  });
});
t.test('Current opened connection should not accept new incoming connections', function (t) {
  var fastify = Fastify();
  fastify.get('/', function (req, reply) {
    fastify.close();
    reply.send({
      hello: 'world'
    });
  });
  fastify.listen(0, function (err) {
    t.error(err);
    var port = fastify.server.address().port;
    var client = net.createConnection({
      port: port
    }, function () {
      client.write('GET / HTTP/1.1\r\n\r\n');
      var newConnection = net.createConnection({
        port: port
      });
      newConnection.on('error', function (err) {
        t.ok(err);
        t.ok(['ECONNREFUSED', 'ECONNRESET'].includes(err.code));
        client.end();
        t.end();
      });
    });
  });
});