'use strict';

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.object.define-property");

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var test = require('tap').test;

var Fastify = require('../');

function testExecutionHook(hook) {
  test("".concat(hook), function (t) {
    t.plan(3);
    var fastify = Fastify();
    fastify.post('/', _defineProperty({}, hook, function (req, reply, done) {
      t.pass('hook called');
      done();
    }), function (req, reply) {
      reply.send(req.body);
    });
    fastify.inject({
      method: 'POST',
      url: '/',
      payload: {
        hello: 'world'
      }
    }, function (err, res) {
      t.error(err);
      var payload = JSON.parse(res.payload);
      t.deepEqual(payload, {
        hello: 'world'
      });
    });
  });
  test("".concat(hook, " option should be called after ").concat(hook, " hook"), function (t) {
    t.plan(3);
    var fastify = Fastify();
    var checker = Object.defineProperty({
      calledTimes: 0
    }, 'check', {
      get: function get() {
        return ++this.calledTimes;
      }
    });
    fastify.addHook(hook, function (req, reply, next) {
      t.equal(checker.check, 1);
      next();
    });
    fastify.post('/', _defineProperty({}, hook, function (req, reply, done) {
      t.equal(checker.check, 2);
      done();
    }), function (req, reply) {
      reply.send({});
    });
    fastify.inject({
      method: 'POST',
      url: '/',
      payload: {
        hello: 'world'
      }
    }, function (err, res) {
      t.error(err);
    });
  });
  test("".concat(hook, " option could accept an array of functions"), function (t) {
    t.plan(3);
    var fastify = Fastify();
    var checker = Object.defineProperty({
      calledTimes: 0
    }, 'check', {
      get: function get() {
        return ++this.calledTimes;
      }
    });
    fastify.post('/', _defineProperty({}, hook, [function (req, reply, done) {
      t.equal(checker.check, 1);
      done();
    }, function (req, reply, done) {
      t.equal(checker.check, 2);
      done();
    }]), function (req, reply) {
      reply.send({});
    });
    fastify.inject({
      method: 'POST',
      url: '/',
      payload: {
        hello: 'world'
      }
    }, function (err, res) {
      t.error(err);
    });
  });
  test("".concat(hook, " option does not interfere with ").concat(hook, " hook"), function (t) {
    t.plan(7);
    var fastify = Fastify();
    var checker = Object.defineProperty({
      calledTimes: 0
    }, 'check', {
      get: function get() {
        return ++this.calledTimes;
      }
    });
    fastify.addHook(hook, function (req, reply, next) {
      t.equal(checker.check, 1);
      next();
    });
    fastify.post('/', _defineProperty({}, hook, function (req, reply, done) {
      t.equal(checker.check, 2);
      done();
    }), handler);
    fastify.post('/no', handler);

    function handler(req, reply) {
      reply.send({});
    }

    fastify.inject({
      method: 'post',
      url: '/'
    }, function (err, res) {
      t.error(err);
      t.equal(checker.calledTimes, 2);
      checker.calledTimes = 0;
      fastify.inject({
        method: 'post',
        url: '/no'
      }, function (err, res) {
        t.error(err);
        t.equal(checker.calledTimes, 1);
      });
    });
  });
}

function testBeforeHandlerHook(hook) {
  test("".concat(hook, " option should be unique per route"), function (t) {
    t.plan(4);
    var fastify = Fastify();
    fastify.post('/', _defineProperty({}, hook, function (req, reply, done) {
      req.hello = 'earth';
      done();
    }), function (req, reply) {
      reply.send({
        hello: req.hello
      });
    });
    fastify.post('/no', function (req, reply) {
      reply.send(req.body);
    });
    fastify.inject({
      method: 'POST',
      url: '/',
      payload: {
        hello: 'world'
      }
    }, function (err, res) {
      t.error(err);
      var payload = JSON.parse(res.payload);
      t.deepEqual(payload, {
        hello: 'earth'
      });
    });
    fastify.inject({
      method: 'POST',
      url: '/no',
      payload: {
        hello: 'world'
      }
    }, function (err, res) {
      t.error(err);
      var payload = JSON.parse(res.payload);
      t.deepEqual(payload, {
        hello: 'world'
      });
    });
  });
  test("".concat(hook, " option should handle errors"), function (t) {
    t.plan(3);
    var fastify = Fastify();
    fastify.post('/', _defineProperty({}, hook, function (req, reply, done) {
      done(new Error('kaboom'));
    }), function (req, reply) {
      reply.send(req.body);
    });
    fastify.inject({
      method: 'POST',
      url: '/',
      payload: {
        hello: 'world'
      }
    }, function (err, res) {
      t.error(err);
      var payload = JSON.parse(res.payload);
      t.equal(res.statusCode, 500);
      t.deepEqual(payload, {
        message: 'kaboom',
        error: 'Internal Server Error',
        statusCode: 500
      });
    });
  });
  test("".concat(hook, " option should handle errors with custom status code"), function (t) {
    t.plan(3);
    var fastify = Fastify();
    fastify.post('/', _defineProperty({}, hook, function (req, reply, done) {
      reply.code(401);
      done(new Error('go away'));
    }), function (req, reply) {
      reply.send(req.body);
    });
    fastify.inject({
      method: 'POST',
      url: '/',
      payload: {
        hello: 'world'
      }
    }, function (err, res) {
      t.error(err);
      var payload = JSON.parse(res.payload);
      t.equal(res.statusCode, 401);
      t.deepEqual(payload, {
        message: 'go away',
        error: 'Unauthorized',
        statusCode: 401
      });
    });
  });
  test("".concat(hook, " option should keep the context"), function (t) {
    t.plan(3);
    var fastify = Fastify();
    fastify.decorate('foo', 42);
    fastify.post('/', _defineProperty({}, hook, function (req, reply, done) {
      t.strictEqual(this.foo, 42);
      this.foo += 1;
      done();
    }), function (req, reply) {
      reply.send({
        foo: this.foo
      });
    });
    fastify.inject({
      method: 'POST',
      url: '/',
      payload: {
        hello: 'world'
      }
    }, function (err, res) {
      t.error(err);
      var payload = JSON.parse(res.payload);
      t.deepEqual(payload, {
        foo: 43
      });
    });
  });
  test("".concat(hook, " option should keep the context (array)"), function (t) {
    t.plan(3);
    var fastify = Fastify();
    fastify.decorate('foo', 42);
    fastify.post('/', _defineProperty({}, hook, [function (req, reply, done) {
      t.strictEqual(this.foo, 42);
      this.foo += 1;
      done();
    }]), function (req, reply) {
      reply.send({
        foo: this.foo
      });
    });
    fastify.inject({
      method: 'POST',
      url: '/',
      payload: {
        hello: 'world'
      }
    }, function (err, res) {
      t.error(err);
      var payload = JSON.parse(res.payload);
      t.deepEqual(payload, {
        foo: 43
      });
    });
  });
}

testExecutionHook('preHandler');
testExecutionHook('onRequest');
testExecutionHook('onResponse');
testExecutionHook('preValidation');
testExecutionHook('preParsing'); // hooks that comes before the handler

testBeforeHandlerHook('preHandler');
testBeforeHandlerHook('onRequest');
testBeforeHandlerHook('preValidation');
testBeforeHandlerHook('preParsing');
test('preHandler backwards compatibility with beforeHandler option (should emit a warning)', function (t) {
  t.plan(4);
  var fastify = Fastify();
  process.on('warning', function (warn) {
    t.strictEqual(warn.message, 'The route option `beforeHandler` has been deprecated, use `preHandler` instead');
    t.ok(warn.stack.indexOf(__filename) >= 0);
  });
  fastify.post('/', {
    beforeHandler: function beforeHandler(req, reply, done) {
      req.body.preHandler = true;
      done();
    }
  }, function (req, reply) {
    reply.send(req.body);
  });
  fastify.inject({
    method: 'POST',
    url: '/',
    payload: {
      hello: 'world'
    }
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      preHandler: true,
      hello: 'world'
    });
  });
});
test('preValidation option should be called before preHandler hook', function (t) {
  t.plan(3);
  var fastify = Fastify();
  fastify.addHook('preHandler', function (req, reply, next) {
    t["true"](req.called);
    next();
  });
  fastify.post('/', {
    preValidation: function preValidation(req, reply, done) {
      req.called = true;
      done();
    }
  }, function (req, reply) {
    reply.send(req.body);
  });
  fastify.inject({
    method: 'POST',
    url: '/',
    payload: {
      hello: 'world'
    }
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
});
test('preSerialization option should be able to modify the payload', function (t) {
  t.plan(3);
  var fastify = Fastify();
  fastify.get('/only', {
    preSerialization: function preSerialization(req, reply, payload, done) {
      done(null, {
        hello: 'another world'
      });
    }
  }, function (req, reply) {
    reply.send({
      hello: 'world'
    });
  });
  fastify.inject({
    method: 'GET',
    url: '/only'
  }, function (err, res) {
    t.error(err);
    t.equal(res.statusCode, 200);
    t.deepEqual(JSON.parse(res.payload), {
      hello: 'another world'
    });
  });
});
test('preParsing option should be called before preValidation hook', function (t) {
  t.plan(3);
  var fastify = Fastify();
  fastify.addHook('preValidation', function (req, reply, next) {
    t["true"](req.called);
    next();
  });
  fastify.post('/', {
    preParsing: function preParsing(req, reply, done) {
      req.called = true;
      done();
    }
  }, function (req, reply) {
    reply.send(req.body);
  });
  fastify.inject({
    method: 'POST',
    url: '/',
    payload: {
      hello: 'world'
    }
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
});
test('onRequest option should be called before preParsing', function (t) {
  t.plan(3);
  var fastify = Fastify();
  fastify.addHook('preParsing', function (req, reply, next) {
    t["true"](req.called);
    next();
  });
  fastify.post('/', {
    onRequest: function onRequest(req, reply, done) {
      req.called = true;
      done();
    }
  }, function (req, reply) {
    reply.send(req.body);
  });
  fastify.inject({
    method: 'POST',
    url: '/',
    payload: {
      hello: 'world'
    }
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
});