'use strict';

require("core-js/modules/es.array.concat");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/web.immediate");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/web.immediate");

var t = require('tap');

var test = t.test;

var sget = require('simple-get').concat;

var fs = require('fs');

var resolve = require('path').resolve;

var zlib = require('zlib');

var pump = require('pump');

var Fastify = require('..');

var errors = require('http-errors');

var JSONStream = require('JSONStream');

var send = require('send');

var Readable = require('stream').Readable;

var split = require('split2');

test('should respond with a stream', function (t) {
  t.plan(8);
  var fastify = Fastify();
  fastify.get('/', function (req, reply) {
    var stream = fs.createReadStream(__filename, 'utf8');
    reply.code(200).send(stream);
  });
  fastify.get('/error', function (req, reply) {
    var stream = fs.createReadStream('not-existing-file', 'utf8');
    reply.code(200).send(stream);
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    sget("http://localhost:".concat(fastify.server.address().port), function (err, response, data) {
      t.error(err);
      t.strictEqual(response.headers['content-type'], 'application/octet-stream');
      t.strictEqual(response.statusCode, 200);
      fs.readFile(__filename, function (err, expected) {
        t.error(err);
        t.equal(expected.toString(), data.toString());
      });
    });
    sget("http://localhost:".concat(fastify.server.address().port, "/error"), function (err, response) {
      t.error(err);
      t.strictEqual(response.statusCode, 500);
    });
  });
});
test('should trigger the onSend hook', function (t) {
  t.plan(4);
  var fastify = Fastify();
  fastify.get('/', function (req, reply) {
    reply.send(fs.createReadStream(__filename, 'utf8'));
  });
  fastify.addHook('onSend', function (req, reply, payload, next) {
    t.ok(payload._readableState);
    reply.header('Content-Type', 'application/javascript');
    next();
  });
  fastify.inject({
    url: '/'
  }, function (err, res) {
    t.error(err);
    t.strictEqual(res.headers['content-type'], 'application/javascript');
    t.strictEqual(res.payload, fs.readFileSync(__filename, 'utf8'));
    fastify.close();
  });
});
test('should trigger the onSend hook only twice if pumping the stream fails, first with the stream, second with the serialized error', function (t) {
  t.plan(5);
  var fastify = Fastify();
  fastify.get('/', function (req, reply) {
    reply.send(fs.createReadStream('not-existing-file', 'utf8'));
  });
  var counter = 0;
  fastify.addHook('onSend', function (req, reply, payload, next) {
    if (counter === 0) {
      t.ok(payload._readableState);
    } else if (counter === 1) {
      var error = JSON.parse(payload);
      t.strictEqual(error.statusCode, 500);
    }

    counter++;
    next();
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    sget("http://localhost:".concat(fastify.server.address().port), function (err, response) {
      t.error(err);
      t.strictEqual(response.statusCode, 500);
    });
  });
});
test('onSend hook stream', function (t) {
  t.plan(4);
  var fastify = Fastify();
  fastify.get('/', function (req, reply) {
    reply.send({
      hello: 'world'
    });
  });
  fastify.addHook('onSend', function (req, reply, payload, next) {
    var gzStream = zlib.createGzip();
    reply.header('Content-Encoding', 'gzip');
    pump(fs.createReadStream(resolve(process.cwd() + '/test/stream.test.js'), 'utf8'), gzStream, t.error);
    next(null, gzStream);
  });
  fastify.inject({
    url: '/',
    method: 'GET'
  }, function (err, res) {
    t.error(err);
    t.strictEqual(res.headers['content-encoding'], 'gzip');
    var file = fs.readFileSync(resolve(process.cwd() + '/test/stream.test.js'), 'utf8');
    var payload = zlib.gunzipSync(res.rawPayload);
    t.strictEqual(payload.toString('utf-8'), file);
    fastify.close();
  });
});
test('Destroying streams prematurely', function (t) {
  t.plan(6);
  var fastify = null;
  var logStream = split(JSON.parse);

  try {
    fastify = Fastify({
      logger: {
        stream: logStream,
        level: 'warn'
      }
    });
  } catch (e) {
    t.fail();
  }

  var stream = require('stream');

  var http = require('http'); // Test that "premature close" errors are logged with level warn


  logStream.once('data', function (line) {
    t.equal(line.msg, 'response terminated with an error with headers already sent');
    t.equal(line.level, 40);
  });
  fastify.get('/', function (request, reply) {
    t.pass('Received request');
    var sent = false;
    var reallyLongStream = new stream.Readable({
      read: function read() {
        if (!sent) {
          this.push(Buffer.from('hello\n'));
        }

        sent = true;
      }
    });
    reply.send(reallyLongStream);
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    var port = fastify.server.address().port;
    http.get("http://localhost:".concat(port), function (response) {
      t.strictEqual(response.statusCode, 200);
      response.on('readable', function () {
        response.destroy();
      }); // Node bug? Node never emits 'close' here.

      response.on('aborted', function () {
        t.pass('Response closed');
      });
    });
  });
});
test('Destroying streams prematurely should call close method', function (t) {
  t.plan(7);
  var fastify = null;
  var logStream = split(JSON.parse);

  try {
    fastify = Fastify({
      logger: {
        stream: logStream,
        level: 'warn'
      }
    });
  } catch (e) {
    t.fail();
  }

  var stream = require('stream');

  var http = require('http'); // Test that "premature close" errors are logged with level warn


  logStream.once('data', function (line) {
    t.equal(line.msg, 'response terminated with an error with headers already sent');
    t.equal(line.level, 40);
  });
  fastify.get('/', function (request, reply) {
    t.pass('Received request');
    var sent = false;
    var reallyLongStream = new stream.Readable({
      read: function read() {
        if (!sent) {
          this.push(Buffer.from('hello\n'));
        }

        sent = true;
      }
    });
    reallyLongStream.destroy = undefined;

    reallyLongStream.close = function () {
      return t.ok('called');
    };

    reply.send(reallyLongStream);
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    var port = fastify.server.address().port;
    http.get("http://localhost:".concat(port), function (response) {
      t.strictEqual(response.statusCode, 200);
      response.on('readable', function () {
        response.destroy();
      }); // Node bug? Node never emits 'close' here.

      response.on('aborted', function () {
        t.pass('Response closed');
      });
    });
  });
});
test('Destroying streams prematurely should call abort method', function (t) {
  t.plan(7);
  var fastify = null;
  var logStream = split(JSON.parse);

  try {
    fastify = Fastify({
      logger: {
        stream: logStream,
        level: 'warn'
      }
    });
  } catch (e) {
    t.fail();
  }

  var stream = require('stream');

  var http = require('http'); // Test that "premature close" errors are logged with level warn


  logStream.once('data', function (line) {
    t.equal(line.msg, 'response terminated with an error with headers already sent');
    t.equal(line.level, 40);
  });
  fastify.get('/', function (request, reply) {
    t.pass('Received request');
    var sent = false;
    var reallyLongStream = new stream.Readable({
      read: function read() {
        if (!sent) {
          this.push(Buffer.from('hello\n'));
        }

        sent = true;
      }
    });
    reallyLongStream.destroy = undefined;
    reallyLongStream.close = undefined;

    reallyLongStream.abort = function () {
      return t.ok('called');
    };

    reply.send(reallyLongStream);
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    var port = fastify.server.address().port;
    http.get("http://localhost:".concat(port), function (response) {
      t.strictEqual(response.statusCode, 200);
      response.on('readable', function () {
        response.destroy();
      }); // Node bug? Node never emits 'close' here.

      response.on('aborted', function () {
        t.pass('Response closed');
      });
    });
  });
});
test('should respond with a stream1', function (t) {
  t.plan(5);
  var fastify = Fastify();
  fastify.get('/', function (req, reply) {
    var stream = JSONStream.stringify();
    reply.code(200).type('application/json').send(stream);
    stream.write({
      hello: 'world'
    });
    stream.end({
      a: 42
    });
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    sget("http://localhost:".concat(fastify.server.address().port), function (err, response, body) {
      t.error(err);
      t.strictEqual(response.headers['content-type'], 'application/json');
      t.strictEqual(response.statusCode, 200);
      t.deepEqual(JSON.parse(body), [{
        hello: 'world'
      }, {
        a: 42
      }]);
    });
  });
});
test('return a 404 if the stream emits a 404 error', function (t) {
  t.plan(5);
  var fastify = Fastify();
  fastify.get('/', function (request, reply) {
    t.pass('Received request');
    var reallyLongStream = new Readable({
      read: function read() {
        var _this = this;

        setImmediate(function () {
          _this.emit('error', new errors.NotFound());
        });
      }
    });
    reply.send(reallyLongStream);
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    var port = fastify.server.address().port;
    sget("http://localhost:".concat(port), function (err, response) {
      t.error(err);
      t.strictEqual(response.headers['content-type'], 'application/json; charset=utf-8');
      t.strictEqual(response.statusCode, 404);
    });
  });
});
test('should support send module 200 and 404', function (t) {
  t.plan(8);
  var fastify = Fastify();
  fastify.get('/', function (req, reply) {
    var stream = send(req.req, __filename);
    reply.code(200).send(stream);
  });
  fastify.get('/error', function (req, reply) {
    var stream = send(req.req, 'non-existing-file');
    reply.code(200).send(stream);
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    sget("http://localhost:".concat(fastify.server.address().port), function (err, response, data) {
      t.error(err);
      t.strictEqual(response.headers['content-type'], 'application/octet-stream');
      t.strictEqual(response.statusCode, 200);
      fs.readFile(__filename, function (err, expected) {
        t.error(err);
        t.equal(expected.toString(), data.toString());
      });
    });
    sget("http://localhost:".concat(fastify.server.address().port, "/error"), function (err, response) {
      t.error(err);
      t.strictEqual(response.statusCode, 404);
    });
  });
});