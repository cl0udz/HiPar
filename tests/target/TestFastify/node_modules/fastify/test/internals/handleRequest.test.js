'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var t = require('tap');

var test = t.test;

var handleRequest = require('../../lib/handleRequest');

var internals = require('../../lib/handleRequest')[Symbol["for"]('internals')];

var Request = require('../../lib/request');

var Reply = require('../../lib/reply');

var buildSchema = require('../../lib/validation').build;

var _require = require('../../lib/schemas'),
    Schemas = _require.Schemas;

var sget = require('simple-get').concat;

var Ajv = require('ajv');

var ajv = new Ajv({
  coerceTypes: true
});

function schemaCompiler(schema) {
  var validateFuncion = ajv.compile(schema);

  var fn = function fn(body) {
    var isOk = validateFuncion(body);
    if (isOk) return;
    return false;
  };

  fn.errors = [];
  return fn;
}

test('Request object', function (t) {
  t.plan(8);
  var req = new Request('params', 'req', 'query', 'headers', 'log');
  t.type(req, Request);
  t.equal(req.params, 'params');
  t.deepEqual(req.raw, 'req');
  t.deepEqual(req.req, req.raw);
  t.equal(req.query, 'query');
  t.equal(req.headers, 'headers');
  t.equal(req.log, 'log');
  t.strictDeepEqual(req.body, null);
});
test('handleRequest function - sent reply', function (t) {
  t.plan(1);
  var request = {};
  var reply = {
    sent: true
  };
  var res = handleRequest(null, request, reply);
  t.equal(res, undefined);
});
test('handleRequest function - invoke with error', function (t) {
  t.plan(1);
  var request = {};
  var reply = {};

  reply.send = function (err) {
    return t.is(err.message, 'Kaboom');
  };

  handleRequest(new Error('Kaboom'), request, reply);
});
test('handler function - invalid schema', function (t) {
  t.plan(2);
  var res = {};

  res.end = function () {
    t.equal(res.statusCode, 400);
    t.pass();
  };

  res.writeHead = function () {};

  res.log = {
    error: function error() {},
    info: function info() {}
  };
  var context = {
    schema: {
      body: {
        type: 'object',
        properties: {
          hello: {
            type: 'number'
          }
        }
      }
    },
    handler: function handler() {},
    Reply: Reply,
    Request: Request,
    preValidation: [],
    preHandler: [],
    onSend: [],
    onError: [],
    attachValidation: false
  };
  var schemas = new Schemas();
  buildSchema(context, schemaCompiler, schemas);
  var request = {
    body: {
      hello: 'world'
    }
  };
  internals.handler(request, new Reply(res, context, request));
});
test('handler function - reply', function (t) {
  t.plan(3);
  var res = {};

  res.end = function () {
    t.equal(res.statusCode, 204);
    t.pass();
  };

  res.writeHead = function () {};

  var context = {
    handler: function handler(req, reply) {
      t.is(_typeof(reply), 'object');
      reply.code(204);
      reply.send(undefined);
    },
    Reply: Reply,
    Request: Request,
    preValidation: [],
    preHandler: [],
    onSend: [],
    onError: []
  };
  buildSchema(context, schemaCompiler);
  internals.handler({}, new Reply(res, context, {}));
});
test('handler function - preValidationCallback with finished response', function (t) {
  t.plan(0);
  var res = {};
  res.finished = true;

  res.end = function () {
    t.fail();
  };

  res.writeHead = function () {};

  var context = {
    handler: function handler(req, reply) {
      t.fail();
      reply.send(undefined);
    },
    Reply: Reply,
    Request: Request,
    preValidation: null,
    preHandler: [],
    onSend: [],
    onError: []
  };
  buildSchema(context, schemaCompiler);
  internals.handler({}, new Reply(res, context, {}));
});
test('request should be defined in onSend Hook on post request with content type application/json', function (t) {
  t.plan(8);

  var fastify = require('../..')();

  fastify.addHook('onSend', function (request, reply, payload, done) {
    t.ok(request);
    t.ok(request.raw);
    t.ok(request.id);
    t.ok(request.params);
    t.ok(request.query);
    done();
  });
  fastify.post('/', function (request, reply) {
    reply.send(200);
  });
  fastify.listen(0, function (err) {
    fastify.server.unref();
    t.error(err);
    sget({
      method: 'POST',
      url: 'http://localhost:' + fastify.server.address().port,
      headers: {
        'content-type': 'application/json'
      }
    }, function (err, response, body) {
      t.error(err); // a 400 error is expected because of no body

      t.strictEqual(response.statusCode, 400);
    });
  });
});
test('request should be defined in onSend Hook on post request with content type application/x-www-form-urlencoded', function (t) {
  t.plan(7);

  var fastify = require('../..')();

  fastify.addHook('onSend', function (request, reply, payload, done) {
    t.ok(request);
    t.ok(request.raw);
    t.ok(request.params);
    t.ok(request.query);
    done();
  });
  fastify.post('/', function (request, reply) {
    reply.send(200);
  });
  fastify.listen(0, function (err) {
    fastify.server.unref();
    t.error(err);
    sget({
      method: 'POST',
      url: 'http://localhost:' + fastify.server.address().port,
      headers: {
        'content-type': 'application/x-www-form-urlencoded'
      }
    }, function (err, response, body) {
      t.error(err); // a 415 error is expected because of missing content type parser

      t.strictEqual(response.statusCode, 415);
    });
  });
});
test('request should be defined in onSend Hook on options request with content type application/x-www-form-urlencoded', function (t) {
  t.plan(7);

  var fastify = require('../..')();

  fastify.addHook('onSend', function (request, reply, payload, done) {
    t.ok(request);
    t.ok(request.raw);
    t.ok(request.params);
    t.ok(request.query);
    done();
  });
  fastify.options('/', function (request, reply) {
    reply.send(200);
  });
  fastify.listen(0, function (err) {
    fastify.server.unref();
    t.error(err);
    sget({
      method: 'OPTIONS',
      url: 'http://localhost:' + fastify.server.address().port,
      headers: {
        'content-type': 'application/x-www-form-urlencoded'
      }
    }, function (err, response, body) {
      t.error(err); // Body parsing skipped, so no body sent

      t.strictEqual(response.statusCode, 200);
    });
  });
});
test('request should respond with an error if an unserialized payload is sent inside an an async handler', function (t) {
  t.plan(3);

  var fastify = require('../..')();

  fastify.get('/', function (request, reply) {
    reply.type('text/html');
    return Promise.resolve(request.headers);
  });
  fastify.inject({
    method: 'GET',
    url: '/'
  }, function (err, res) {
    t.error(err);
    t.strictEqual(res.statusCode, 500);
    t.strictDeepEqual(JSON.parse(res.payload), {
      error: 'Internal Server Error',
      code: 'FST_ERR_REP_INVALID_PAYLOAD_TYPE',
      message: 'FST_ERR_REP_INVALID_PAYLOAD_TYPE: Attempted to send payload of invalid type \'object\'. Expected a string or Buffer.',
      statusCode: 500
    });
  });
});