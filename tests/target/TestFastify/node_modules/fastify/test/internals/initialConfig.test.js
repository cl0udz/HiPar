'use strict';

require("core-js/modules/es.array.join");

require("core-js/modules/es.array-buffer.constructor");

require("core-js/modules/es.array-buffer.slice");

require("core-js/modules/es.data-view");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.is-frozen");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array-buffer.constructor");

require("core-js/modules/es.array-buffer.slice");

require("core-js/modules/es.data-view");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.is-frozen");

require("core-js/modules/es.object.to-string");

var _require = require('tap'),
    test = _require.test;

var Fastify = require('../..');

var fs = require('fs');

var path = require('path');

var http = require('http');

var pino = require('pino');

var split = require('split2');

var deepClone = require('rfdc')({
  circles: true,
  proto: false
});

var deepFreezeObject = require('../../lib/initialConfigValidation').utils.deepFreezeObject;

test('Fastify.initialConfig is an object', function (t) {
  t.plan(1);
  t.type(Fastify().initialConfig, 'object');
});
test('without options passed to Fastify, initialConfig should expose default values', function (t) {
  t.plan(1);
  var fastifyDefaultOptions = {
    bodyLimit: 1024 * 1024,
    caseSensitive: true,
    disableRequestLogging: false,
    ignoreTrailingSlash: false,
    maxParamLength: 100,
    onProtoPoisoning: 'error',
    pluginTimeout: 10000,
    requestIdHeader: 'request-id',
    requestIdLogLabel: 'reqId'
  };
  t.deepEquals(Fastify().initialConfig, fastifyDefaultOptions);
});
test('Fastify.initialConfig should expose all options', function (t) {
  t.plan(16);

  var serverFactory = function serverFactory(handler, opts) {
    var server = http.createServer(function (req, res) {
      handler(req, res);
    });
    return server;
  };

  var versioning = {
    storage: function storage() {
      var versions = {};
      return {
        get: function get(version) {
          return versions[version] || null;
        },
        set: function set(version, store) {
          versions[version] = store;
        },
        del: function del(version) {
          delete versions[version];
        },
        empty: function empty() {
          versions = {};
        }
      };
    },
    deriveVersion: function deriveVersion(req, ctx) {
      return req.headers.accept;
    }
  };
  var options = {
    http2: true,
    https: {
      key: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.key')),
      cert: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.cert'))
    },
    ignoreTrailingSlash: true,
    maxParamLength: 200,
    bodyLimit: 1049600,
    onProtoPoisoning: 'remove',
    serverFactory: serverFactory,
    caseSensitive: true,
    requestIdHeader: 'request-id-alt',
    pluginTimeout: 20000,
    querystringParser: function querystringParser(str) {
      return str;
    },
    genReqId: function genReqId(req) {
      var i = 0;
      return i++;
    },
    logger: pino({
      level: 'info'
    }),
    versioning: versioning,
    trustProxy: function myTrustFn(address, hop) {
      return address === '1.2.3.4' || hop === 1;
    }
  };
  var fastify = Fastify(options);
  t.strictEqual(fastify.initialConfig.http2, true);
  t.strictEqual(fastify.initialConfig.https, true);
  t.strictEqual(fastify.initialConfig.ignoreTrailingSlash, true);
  t.strictEqual(fastify.initialConfig.maxParamLength, 200);
  t.strictEqual(fastify.initialConfig.bodyLimit, 1049600);
  t.strictEqual(fastify.initialConfig.onProtoPoisoning, 'remove');
  t.strictEqual(fastify.initialConfig.caseSensitive, true);
  t.strictEqual(fastify.initialConfig.requestIdHeader, 'request-id-alt');
  t.strictEqual(fastify.initialConfig.pluginTimeout, 20000); // obfuscated options:

  t.strictEqual(fastify.initialConfig.serverFactory, undefined);
  t.strictEqual(fastify.initialConfig.trustProxy, undefined);
  t.strictEqual(fastify.initialConfig.genReqId, undefined);
  t.strictEqual(fastify.initialConfig.querystringParser, undefined);
  t.strictEqual(fastify.initialConfig.logger, undefined);
  t.strictEqual(fastify.initialConfig.versioning, undefined);
  t.strictEqual(fastify.initialConfig.trustProxy, undefined);
});
test('Should throw if you try to modify Fastify.initialConfig', function (t) {
  t.plan(4);
  var fastify = Fastify({
    ignoreTrailingSlash: true
  });

  try {
    fastify.initialConfig.ignoreTrailingSlash = false;
    t.fail();
  } catch (error) {
    t.type(error, TypeError);
    t.equal(error.message, "Cannot assign to read only property 'ignoreTrailingSlash' of object '#<Object>'");
    t.ok(error.stack);
    t.pass();
  }
});
test('We must avoid shallow freezing and ensure that the whole object is freezed', function (t) {
  t.plan(4);
  var fastify = Fastify({
    https: {
      allowHTTP1: true,
      key: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.key')),
      cert: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.cert'))
    }
  });

  try {
    fastify.initialConfig.https.allowHTTP1 = false;
    t.fail();
  } catch (error) {
    t.type(error, TypeError);
    t.equal(error.message, "Cannot assign to read only property 'allowHTTP1' of object '#<Object>'");
    t.ok(error.stack);
    t.pass();
  }
});
test('Return an error if options do not match the validation schema', function (t) {
  t.plan(6);

  try {
    Fastify({
      ignoreTrailingSlash: 'string instead of boolean'
    });
    t.fail();
  } catch (error) {
    t.type(error, Error);
    t.equal(error.name, 'FastifyError [FST_ERR_INIT_OPTS_INVALID]');
    t.equal(error.message, 'FST_ERR_INIT_OPTS_INVALID: Invalid initialization options: \'["should be boolean"]\'');
    t.equal(error.code, 'FST_ERR_INIT_OPTS_INVALID');
    t.ok(error.stack);
    t.pass();
  }
});
test('Original options must not be frozen', function (t) {
  t.plan(4);
  var originalOptions = {
    https: {
      allowHTTP1: true,
      key: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.key')),
      cert: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.cert'))
    }
  };
  var fastify = Fastify(originalOptions);
  t.strictEqual(Object.isFrozen(originalOptions), false);
  t.strictEqual(Object.isFrozen(originalOptions.https), false);
  t.strictEqual(Object.isFrozen(fastify.initialConfig), true);
  t.strictEqual(Object.isFrozen(fastify.initialConfig.https), true);
});
test('Original options must not be altered (test deep cloning)', function (t) {
  t.plan(3);
  var originalOptions = {
    https: {
      allowHTTP1: true,
      key: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.key')),
      cert: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.cert'))
    }
  };
  var originalOptionsClone = deepClone(originalOptions);
  var fastify = Fastify(originalOptions); // initialConfig has been triggered

  t.strictEqual(Object.isFrozen(fastify.initialConfig), true); // originalOptions must not have been altered

  t.deepEqual(originalOptions.https.key, originalOptionsClone.https.key);
  t.deepEqual(originalOptions.https.cert, originalOptionsClone.https.cert);
});
test('Should not have issues when passing stream options to Pino.js', function (t) {
  t.plan(15);
  var stream = split(JSON.parse);
  var originalOptions = {
    ignoreTrailingSlash: true,
    logger: {
      level: 'trace',
      stream: stream
    }
  };
  var fastify;

  try {
    fastify = Fastify(originalOptions);
    t.type(fastify, 'object');
    t.deepEqual(fastify.initialConfig, {
      bodyLimit: 1024 * 1024,
      caseSensitive: true,
      disableRequestLogging: false,
      ignoreTrailingSlash: true,
      maxParamLength: 100,
      onProtoPoisoning: 'error',
      pluginTimeout: 10000,
      requestIdHeader: 'request-id',
      requestIdLogLabel: 'reqId'
    });
  } catch (error) {
    t.fail();
  }

  fastify.get('/', function (req, reply) {
    t.ok(req.log);
    reply.send({
      hello: 'world'
    });
  });
  stream.once('data', function (listenAtLogLine) {
    t.ok(listenAtLogLine, 'listen at log message is ok');
    stream.once('data', function (line) {
      var id = line.reqId;
      t.ok(line.reqId, 'reqId is defined');
      t.ok(line.req, 'req is defined');
      t.equal(line.msg, 'incoming request', 'message is set');
      t.equal(line.req.method, 'GET', 'method is get');
      stream.once('data', function (line) {
        t.equal(line.reqId, id);
        t.ok(line.reqId, 'reqId is defined');
        t.ok(line.res, 'res is defined');
        t.equal(line.msg, 'request completed', 'message is set');
        t.equal(line.res.statusCode, 200, 'statusCode is 200');
        t.ok(line.responseTime, 'responseTime is defined');
      });
    });
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port);
  });
});
test('deepFreezeObject() should not throw on TypedArray', function (t) {
  t.plan(5);
  var object = {
    buffer: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.key')),
    dataView: new DataView(new ArrayBuffer(16)),
    "float": 1.1,
    integer: 1,
    object: {
      nested: {
        string: 'string'
      }
    },
    stream: split(JSON.parse),
    string: 'string'
  };

  try {
    var frozenObject = deepFreezeObject(object); // Buffers should not be frozen, as they are Uint8Array inherited instances

    t.strictEqual(Object.isFrozen(frozenObject.buffer), false);
    t.strictEqual(Object.isFrozen(frozenObject), true);
    t.strictEqual(Object.isFrozen(frozenObject.object), true);
    t.strictEqual(Object.isFrozen(frozenObject.object.nested), true);
    t.pass();
  } catch (error) {
    t.fail();
  }
});