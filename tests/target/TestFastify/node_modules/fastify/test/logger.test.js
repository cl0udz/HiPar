'use strict';

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.match");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require('tap'),
    test = _require.test,
    tearDown = _require.tearDown;

var http = require('http');

var stream = require('stream');

var split = require('split2');

var Fastify = require('..');

var pino = require('pino');

var path = require('path');

var os = require('os');

var fs = require('fs');

var sget = require('simple-get').concat;

var files = [];
var count = 0;

function file() {
  var file = path.join(os.tmpdir(), "sonic-boom-".concat(process.pid, "-").concat(process.hrtime().toString(), "-").concat(count++));
  files.push(file);
  return file;
}

tearDown(function () {
  files.forEach(function (file) {
    try {
      fs.unlinkSync(file);
    } catch (e) {
      console.log(e);
    }
  });
});
test('defaults to info level', function (t) {
  t.plan(13);
  var fastify = null;
  var stream = split(JSON.parse);

  try {
    fastify = Fastify({
      logger: {
        stream: stream
      }
    });
  } catch (e) {
    t.fail();
  }

  fastify.get('/', function (req, reply) {
    t.ok(req.log);
    reply.send({
      hello: 'world'
    });
  });
  stream.once('data', function (listenAtLogLine) {
    t.ok(listenAtLogLine, 'listen at log message is ok');
    stream.once('data', function (line) {
      var id = line.reqId;
      t.ok(line.reqId, 'reqId is defined');
      t.ok(line.req, 'req is defined');
      t.equal(line.msg, 'incoming request', 'message is set');
      t.equal(line.req.method, 'GET', 'method is get');
      stream.once('data', function (line) {
        t.equal(line.reqId, id);
        t.ok(line.reqId, 'reqId is defined');
        t.ok(line.res, 'res is defined');
        t.equal(line.msg, 'request completed', 'message is set');
        t.equal(line.res.statusCode, 200, 'statusCode is 200');
        t.ok(line.responseTime, 'responseTime is defined');
      });
    });
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port);
  });
});
test('test log stream', function (t) {
  t.plan(12);
  var fastify = null;
  var stream = split(JSON.parse);

  try {
    fastify = Fastify({
      logger: {
        stream: stream,
        level: 'info'
      }
    });
  } catch (e) {
    t.fail();
  }

  fastify.get('/', function (req, reply) {
    t.ok(req.log);
    reply.send({
      hello: 'world'
    });
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port);
    stream.once('data', function (listenAtLogLine) {
      t.ok(listenAtLogLine, 'listen at log message is ok');
      stream.once('data', function (line) {
        var id = line.reqId;
        t.ok(line.reqId, 'reqId is defined');
        t.ok(line.req, 'req is defined');
        t.equal(line.msg, 'incoming request', 'message is set');
        t.equal(line.req.method, 'GET', 'method is get');
        stream.once('data', function (line) {
          t.equal(line.reqId, id);
          t.ok(line.reqId, 'reqId is defined');
          t.ok(line.res, 'res is defined');
          t.equal(line.msg, 'request completed', 'message is set');
          t.equal(line.res.statusCode, 200, 'statusCode is 200');
        });
      });
    });
  });
});
test('test error log stream', function (t) {
  t.plan(11);
  var fastify = null;
  var stream = split(JSON.parse);

  try {
    fastify = Fastify({
      logger: {
        stream: stream,
        level: 'info'
      }
    });
  } catch (e) {
    t.fail();
  }

  fastify.get('/error', function (req, reply) {
    t.ok(req.log);
    reply.send(new Error('kaboom'));
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port + '/error');
    stream.once('data', function (listenAtLogLine) {
      t.ok(listenAtLogLine, 'listen at log message is ok');
      stream.once('data', function (line) {
        t.ok(line.reqId, 'reqId is defined');
        t.ok(line.req, 'req is defined');
        t.equal(line.msg, 'incoming request', 'message is set');
        t.equal(line.req.method, 'GET', 'method is get');
        stream.once('data', function (line) {
          t.ok(line.reqId, 'reqId is defined');
          t.ok(line.res, 'res is defined');
          t.equal(line.msg, 'kaboom', 'message is set');
          t.equal(line.res.statusCode, 500, 'statusCode is 500');
        });
      });
    });
  });
});
test('can use external logger instance', function (t) {
  var lines = [/^Server listening at /, /^incoming request$/, /^log success$/, /^request completed$/];
  t.plan(lines.length + 2);
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    var regex = lines.shift();
    t.ok(regex.test(line.msg), '"' + line.msg + '" dont match "' + regex + '"');
  });

  var logger = require('pino')(splitStream);

  var localFastify = Fastify({
    logger: logger
  });
  localFastify.get('/foo', function (req, reply) {
    t.ok(req.log);
    req.log.info('log success');
    reply.send({
      hello: 'world'
    });
  });
  localFastify.listen(0, function (err) {
    t.error(err);
    http.get('http://localhost:' + localFastify.server.address().port + '/foo', function (res) {
      res.resume();
      res.on('end', function () {
        localFastify.server.close();
      });
    });
  });
});
test('can use external logger instance with custom serializer', function (t) {
  var lines = [['level', 30], ['req', {
    url: '/foo'
  }], ['level', 30], ['res', {
    statusCode: 200
  }]];
  t.plan(lines.length + 2);
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    var check = lines.shift();
    var key = check[0];
    var value = check[1];
    t.deepEqual(line[key], value);
  });

  var logger = require('pino')({
    level: 'info',
    serializers: {
      req: function req(_req) {
        return {
          url: _req.url
        };
      }
    }
  }, splitStream);

  var localFastify = Fastify({
    logger: logger
  });
  localFastify.get('/foo', function (req, reply) {
    t.ok(req.log);
    req.log.info('log success');
    reply.send({
      hello: 'world'
    });
  });
  localFastify.listen(0, function (err) {
    t.error(err);
    http.get('http://localhost:' + localFastify.server.address().port + '/foo', function (res) {
      res.resume();
      res.on('end', function () {
        localFastify.server.close();
      });
    });
  });
});
test('expose the logger', function (t) {
  t.plan(2);
  var fastify = null;
  var stream = split(JSON.parse);

  try {
    fastify = Fastify({
      logger: {
        stream: stream,
        level: 'info'
      }
    });
  } catch (e) {
    t.fail();
  }

  t.ok(fastify.log);
  t.is(_typeof(fastify.log), 'object');
});
test('The request id header key can be customized', function (t) {
  t.plan(9);
  var REQUEST_ID = '42';
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      level: 'info'
    },
    requestIdHeader: 'my-custom-request-id'
  });
  t.tearDown(function () {
    return fastify.close();
  });
  fastify.get('/', function (req, reply) {
    t.equal(req.raw.id, REQUEST_ID);
    req.log.info('some log message');
    reply.send({
      id: req.raw.id
    });
  });
  fastify.inject({
    method: 'GET',
    url: '/',
    headers: {
      'my-custom-request-id': REQUEST_ID
    }
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.equal(payload.id, REQUEST_ID);
    stream.once('data', function (line) {
      t.equal(line.reqId, REQUEST_ID);
      t.equal(line.msg, 'incoming request', 'message is set');
      stream.once('data', function (line) {
        t.equal(line.reqId, REQUEST_ID);
        t.equal(line.msg, 'some log message', 'message is set');
        stream.once('data', function (line) {
          t.equal(line.reqId, REQUEST_ID);
          t.equal(line.msg, 'request completed', 'message is set');
        });
      });
    });
  });
});
test('The request id header key can be customized along with a custom id generator', function (t) {
  t.plan(12);
  var REQUEST_ID = '42';
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      level: 'info'
    },
    requestIdHeader: 'my-custom-request-id',
    genReqId: function genReqId() {
      return 'foo';
    }
  });
  t.tearDown(function () {
    return fastify.close();
  });
  fastify.get('/one', function (req, reply) {
    t.equal(req.id, REQUEST_ID);
    req.log.info('some log message');
    reply.send({
      id: req.id
    });
  });
  fastify.get('/two', function (req, reply) {
    t.equal(req.id, 'foo');
    req.log.info('some log message 2');
    reply.send({
      id: req.id
    });
  });
  var matches = [{
    reqId: REQUEST_ID,
    msg: /incoming request/
  }, {
    reqId: REQUEST_ID,
    msg: /some log message/
  }, {
    reqId: REQUEST_ID,
    msg: /request completed/
  }, {
    reqId: 'foo',
    msg: /incoming request/
  }, {
    reqId: 'foo',
    msg: /some log message 2/
  }, {
    reqId: 'foo',
    msg: /request completed/
  }];
  var i = 0;
  stream.on('data', function (line) {
    t.match(line, matches[i]);
    i += 1;
  });
  fastify.inject({
    method: 'GET',
    url: '/one',
    headers: {
      'my-custom-request-id': REQUEST_ID
    }
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.equal(payload.id, REQUEST_ID);
  });
  fastify.inject({
    method: 'GET',
    url: '/two'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.equal(payload.id, 'foo');
  });
});
test('The request id log label can be changed', function (t) {
  t.plan(6);
  var REQUEST_ID = '42';
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      level: 'info'
    },
    requestIdHeader: 'my-custom-request-id',
    requestIdLogLabel: 'traceId'
  });
  t.tearDown(function () {
    return fastify.close();
  });
  fastify.get('/one', function (req, reply) {
    t.equal(req.id, REQUEST_ID);
    req.log.info('some log message');
    reply.send({
      id: req.id
    });
  });
  var matches = [{
    traceId: REQUEST_ID,
    msg: /incoming request/
  }, {
    traceId: REQUEST_ID,
    msg: /some log message/
  }, {
    traceId: REQUEST_ID,
    msg: /request completed/
  }];
  var i = 0;
  stream.on('data', function (line) {
    t.match(line, matches[i]);
    i += 1;
  });
  fastify.inject({
    method: 'GET',
    url: '/one',
    headers: {
      'my-custom-request-id': REQUEST_ID
    }
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.equal(payload.id, REQUEST_ID);
  });
});
test('The logger should accept custom serializer', function (t) {
  t.plan(9);
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      level: 'info',
      serializers: {
        req: function req(_req2) {
          return {
            url: _req2.url
          };
        }
      }
    }
  });
  fastify.get('/custom', function (req, reply) {
    t.ok(req.log);
    reply.send(new Error('kaboom'));
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port + '/custom');
    stream.once('data', function (listenAtLogLine) {
      t.ok(listenAtLogLine, 'listen at log message is ok');
      stream.once('data', function (line) {
        t.ok(line.req, 'req is defined');
        t.equal(line.msg, 'incoming request', 'message is set');
        t.deepEqual(line.req, {
          url: '/custom'
        }, 'custom req serialiser is use');
        stream.once('data', function (line) {
          t.ok(line.res, 'res is defined');
          t.equal(line.msg, 'kaboom', 'message is set');
          t.deepEqual(line.res, {
            statusCode: 500
          }, 'default res serialiser is use');
        });
      });
    });
  });
});
test('reply.send logs an error if called twice in a row', function (t) {
  var lines = ['incoming request', 'request completed', 'Reply already sent', 'Reply already sent'];
  t.plan(lines.length + 2);
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    t.is(line.msg, lines.shift());
  });
  var logger = pino(splitStream);
  var fastify = Fastify({
    logger: logger
  });
  fastify.get('/', function (req, reply) {
    reply.send({
      hello: 'world'
    });
    reply.send({
      hello: 'world2'
    });
    reply.send({
      hello: 'world3'
    });
  });
  fastify.inject({
    method: 'GET',
    url: '/'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
});
test('logger can be silented', function (t) {
  t.plan(17);
  var fastify = Fastify({
    logger: false
  });
  t.ok(fastify.log);
  t.is(_typeof(fastify.log), 'object');
  t.is(_typeof(fastify.log.fatal), 'function');
  t.is(_typeof(fastify.log.error), 'function');
  t.is(_typeof(fastify.log.warn), 'function');
  t.is(_typeof(fastify.log.info), 'function');
  t.is(_typeof(fastify.log.debug), 'function');
  t.is(_typeof(fastify.log.trace), 'function');
  t.is(_typeof(fastify.log.child), 'function');
  var childLog = fastify.log.child();
  t.is(_typeof(childLog), 'object');
  t.is(_typeof(childLog.fatal), 'function');
  t.is(_typeof(childLog.error), 'function');
  t.is(_typeof(childLog.warn), 'function');
  t.is(_typeof(childLog.info), 'function');
  t.is(_typeof(childLog.debug), 'function');
  t.is(_typeof(childLog.trace), 'function');
  t.is(_typeof(childLog.child), 'function');
});
test('Should set a custom logLevel for a plugin', function (t) {
  var lines = ['incoming request', 'Hello', 'request completed'];
  t.plan(7);
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    t.is(line.msg, lines.shift());
  });
  var logger = pino({
    level: 'error'
  }, splitStream);
  var fastify = Fastify({
    logger: logger
  });
  fastify.get('/', function (req, reply) {
    req.log.info('Hello'); // we should not see this log

    reply.send({
      hello: 'world'
    });
  });
  fastify.register(function (instance, opts, next) {
    instance.get('/plugin', function (req, reply) {
      req.log.info('Hello'); // we should see this log

      reply.send({
        hello: 'world'
      });
    });
    next();
  }, {
    logLevel: 'info'
  });
  fastify.inject({
    method: 'GET',
    url: '/'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
  fastify.inject({
    method: 'GET',
    url: '/plugin'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
});
test('Should set a custom logLevel for every plugin', function (t) {
  var lines = ['incoming request', 'request completed', 'info', 'debug'];
  t.plan(18);
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    t.ok(line.level === 30 || line.level === 20);
    t.ok(lines.indexOf(line.msg) > -1);
  });
  var logger = pino({
    level: 'error'
  }, splitStream);
  var fastify = Fastify({
    logger: logger
  });
  fastify.get('/', function (req, reply) {
    req.log.warn('Hello'); // we should not see this log

    reply.send({
      hello: 'world'
    });
  });
  fastify.register(function (instance, opts, next) {
    instance.get('/info', function (req, reply) {
      req.log.info('info'); // we should see this log

      req.log.debug('hidden log');
      reply.send({
        hello: 'world'
      });
    });
    next();
  }, {
    logLevel: 'info'
  });
  fastify.register(function (instance, opts, next) {
    instance.get('/debug', function (req, reply) {
      req.log.debug('debug'); // we should see this log

      req.log.trace('hidden log');
      reply.send({
        hello: 'world'
      });
    });
    next();
  }, {
    logLevel: 'debug'
  });
  fastify.inject({
    method: 'GET',
    url: '/'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
  fastify.inject({
    method: 'GET',
    url: '/info'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
  fastify.inject({
    method: 'GET',
    url: '/debug'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
});
test('Should increase the log level for a specific plugin', function (t) {
  t.plan(4);
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    t.is(line.msg, 'Hello');
    t.ok(line.level === 50);
  });
  var logger = pino({
    level: 'info'
  }, splitStream);
  var fastify = Fastify({
    logger: logger
  });
  fastify.register(function (instance, opts, next) {
    instance.get('/', function (req, reply) {
      req.log.error('Hello'); // we should see this log

      reply.send({
        hello: 'world'
      });
    });
    next();
  }, {
    logLevel: 'error'
  });
  fastify.inject({
    method: 'GET',
    url: '/'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
});
test('Should set the log level for the customized 404 handler', function (t) {
  t.plan(4);
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    t.is(line.msg, 'Hello');
    t.ok(line.level === 50);
  });
  var logger = pino({
    level: 'warn'
  }, splitStream);
  var fastify = Fastify({
    logger: logger
  });
  fastify.register(function (instance, opts, next) {
    instance.setNotFoundHandler(function (req, reply) {
      req.log.error('Hello');
      reply.code(404).send();
    });
    next();
  }, {
    logLevel: 'error'
  });
  fastify.inject({
    method: 'GET',
    url: '/'
  }, function (err, res) {
    t.error(err);
    t.strictEqual(res.statusCode, 404);
  });
});
test('Should set the log level for the customized 500 handler', function (t) {
  t.plan(4);
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    t.is(line.msg, 'Hello');
    t.ok(line.level === 60);
  });
  var logger = pino({
    level: 'warn'
  }, splitStream);
  var fastify = Fastify({
    logger: logger
  });
  fastify.register(function (instance, opts, next) {
    instance.get('/', function (req, reply) {
      req.log.error('kaboom');
      reply.send(new Error('kaboom'));
    });
    instance.setErrorHandler(function (e, request, reply) {
      reply.log.fatal('Hello');
      reply.code(500).send();
    });
    next();
  }, {
    logLevel: 'fatal'
  });
  fastify.inject({
    method: 'GET',
    url: '/'
  }, function (err, res) {
    t.error(err);
    t.strictEqual(res.statusCode, 500);
  });
});
test('Should set a custom log level for a specific route', function (t) {
  var lines = ['incoming request', 'Hello', 'request completed'];
  t.plan(7);
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    t.is(line.msg, lines.shift());
  });
  var logger = pino({
    level: 'error'
  }, splitStream);
  var fastify = Fastify({
    logger: logger
  });
  fastify.get('/log', {
    logLevel: 'info'
  }, function (req, reply) {
    req.log.info('Hello');
    reply.send({
      hello: 'world'
    });
  });
  fastify.get('/no-log', function (req, reply) {
    req.log.info('Hello');
    reply.send({
      hello: 'world'
    });
  });
  fastify.inject({
    method: 'GET',
    url: '/log'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
  fastify.inject({
    method: 'GET',
    url: '/no-log'
  }, function (err, res) {
    t.error(err);
    var payload = JSON.parse(res.payload);
    t.deepEqual(payload, {
      hello: 'world'
    });
  });
});
test('The default 404 handler logs the incoming request', function (t) {
  t.plan(5);
  var expectedMessages = ['incoming request', 'Route GET:/not-found not found', 'request completed'];
  var splitStream = split(JSON.parse);
  splitStream.on('data', function (line) {
    t.is(line.msg, expectedMessages.shift());
  });
  var logger = pino({
    level: 'trace'
  }, splitStream);
  var fastify = Fastify({
    logger: logger
  });
  fastify.inject({
    method: 'GET',
    url: '/not-found'
  }, function (err, res) {
    t.error(err);
    t.strictEqual(res.statusCode, 404);
  });
});
test('should serialize request and response', function (t) {
  t.plan(3);
  var lines = [];
  var dest = new stream.Writable({
    write: function write(chunk, enc, cb) {
      lines.push(JSON.parse(chunk));
      cb();
    }
  });
  var fastify = Fastify({
    logger: {
      level: 'info',
      stream: dest
    }
  });
  fastify.get('/500', function (req, reply) {
    reply.code(500).send(Error('500 error'));
  });
  fastify.inject({
    url: '/500',
    method: 'GET'
  }, function (e, res) {
    var l = lines.find(function (line) {
      return line.res && line.res.statusCode === 500;
    });
    t.ok(l.req);
    t.is(l.req.method, 'GET');
    t.is(l.req.url, '/500');
  });
});
{
  var interfaces = os.networkInterfaces();
  var ipv6 = Object.keys(interfaces).filter(function (name) {
    return name.substr(0, 2) === 'lo';
  }).map(function (name) {
    return interfaces[name];
  }).reduce(function (list, set) {
    return list.concat(set);
  }, []).filter(function (info) {
    return info.family === 'IPv6';
  }).map(function (info) {
    return info.address;
  }).shift();

  if (ipv6 !== undefined) {
    test('Wrap IPv6 address in listening log message', function (t) {
      t.plan(2);
      var stream = split(JSON.parse);
      var fastify = Fastify({
        logger: {
          stream: stream,
          level: 'info'
        }
      });
      fastify.listen(0, ipv6, function (err) {
        t.error(err);
        stream.once('data', function (line) {
          var expected = 'Server listening at http://[' + ipv6 + ']:' + fastify.server.address().port;
          t.is(line.msg, expected);
          fastify.close();
        });
      });
    });
  }
}
test('Do not wrap IPv4 address', function (t) {
  t.plan(2);
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      level: 'info'
    }
  });
  fastify.listen(0, '127.0.0.1', function (err) {
    t.error(err);
    stream.once('data', function (line) {
      var expected = 'Server listening at http://127.0.0.1:' + fastify.server.address().port;
      t.is(line.msg, expected);
      fastify.close();
    });
  });
});
test('file option', function (t) {
  t.plan(13);
  var fastify = null;
  var dest = file();
  fastify = Fastify({
    logger: {
      file: dest
    }
  });
  fastify.get('/', function (req, reply) {
    t.ok(req.log);
    reply.send({
      hello: 'world'
    });
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port, function () {
      var stream = fs.createReadStream(dest).pipe(split(JSON.parse));
      stream.once('data', function (listenAtLogLine) {
        t.ok(listenAtLogLine, 'listen at log message is ok');
        stream.once('data', function (line) {
          var id = line.reqId;
          t.ok(line.reqId, 'reqId is defined');
          t.ok(line.req, 'req is defined');
          t.equal(line.msg, 'incoming request', 'message is set');
          t.equal(line.req.method, 'GET', 'method is get');
          stream.once('data', function (line) {
            t.equal(line.reqId, id);
            t.ok(line.reqId, 'reqId is defined');
            t.ok(line.res, 'res is defined');
            t.equal(line.msg, 'request completed', 'message is set');
            t.equal(line.res.statusCode, 200, 'statusCode is 200');
            t.ok(line.responseTime, 'responseTime is defined');
            stream.resume();
          });
        });
      });
    });
  });
});
test('should log the error if no error handler is defined', function (t) {
  t.plan(8);
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      level: 'info'
    }
  });
  fastify.get('/error', function (req, reply) {
    t.ok(req.log);
    reply.send(new Error('a generic error'));
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port + '/error');
    stream.once('data', function (listenAtLogLine) {
      t.ok(listenAtLogLine, 'listen at log message is ok');
      stream.once('data', function (line) {
        t.equal(line.msg, 'incoming request', 'message is set');
        stream.once('data', function (line) {
          t.equal(line.level, 50, 'level is correct');
          t.equal(line.msg, 'a generic error', 'message is set');
          stream.once('data', function (line) {
            t.equal(line.msg, 'request completed', 'message is set');
            t.deepEqual(line.res, {
              statusCode: 500
            }, 'status code is set');
          });
        });
      });
    });
  });
});
test('should log as info if error status code >= 400 and < 500 if no error handler is defined', function (t) {
  t.plan(8);
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      level: 'info'
    }
  });
  fastify.get('/400', function (req, reply) {
    t.ok(req.log);
    reply.send(Object.assign(new Error('a 400 error'), {
      statusCode: 400
    }));
  });
  fastify.get('/503', function (req, reply) {
    t.ok(req.log);
    reply.send(Object.assign(new Error('a 503 error'), {
      statusCode: 503
    }));
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port + '/400');
    stream.once('data', function (listenAtLogLine) {
      t.ok(listenAtLogLine, 'listen at log message is ok');
      stream.once('data', function (line) {
        t.equal(line.msg, 'incoming request', 'message is set');
        stream.once('data', function (line) {
          t.equal(line.level, 30, 'level is correct');
          t.equal(line.msg, 'a 400 error', 'message is set');
          stream.once('data', function (line) {
            t.equal(line.msg, 'request completed', 'message is set');
            t.deepEqual(line.res, {
              statusCode: 400
            }, 'status code is set');
          });
        });
      });
    });
  });
});
test('should log as error if error status code >= 500 if no error handler is defined', function (t) {
  t.plan(8);
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      level: 'info'
    }
  });
  fastify.get('/503', function (req, reply) {
    t.ok(req.log);
    reply.send(Object.assign(new Error('a 503 error'), {
      statusCode: 503
    }));
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port + '/503');
    stream.once('data', function (listenAtLogLine) {
      t.ok(listenAtLogLine, 'listen at log message is ok');
      stream.once('data', function (line) {
        t.equal(line.msg, 'incoming request', 'message is set');
        stream.once('data', function (line) {
          t.equal(line.level, 50, 'level is correct');
          t.equal(line.msg, 'a 503 error', 'message is set');
          stream.once('data', function (line) {
            t.equal(line.msg, 'request completed', 'message is set');
            t.deepEqual(line.res, {
              statusCode: 503
            }, 'status code is set');
          });
        });
      });
    });
  });
});
test('should not log the error if error handler is defined', function (t) {
  t.plan(7);
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      level: 'info'
    }
  });
  fastify.get('/error', function (req, reply) {
    t.ok(req.log);
    reply.send(new Error('something happened'));
  });
  fastify.setErrorHandler(function (err, req, reply) {
    reply.send(err);
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port + '/error');
    stream.once('data', function (listenAtLogLine) {
      t.ok(listenAtLogLine, 'listen at log message is ok');
      stream.once('data', function (line) {
        t.equal(line.msg, 'incoming request', 'message is set');
        stream.once('data', function (line) {
          t.equal(line.level, 30, 'level is correct');
          t.equal(line.msg, 'request completed', 'message is set');
          t.deepEqual(line.res, {
            statusCode: 500
          }, 'status code is set');
        });
      });
    });
  });
});
test('should not rely on raw request to log errors', function (t) {
  t.plan(7);
  var stream = split(JSON.parse);
  var fastify = Fastify({
    modifyCoreObjects: false,
    logger: {
      stream: stream,
      level: 'info'
    }
  });
  fastify.get('/error', function (req, reply) {
    t.ok(req.log);
    reply.status(415).send(new Error('something happened'));
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    http.get('http://localhost:' + fastify.server.address().port + '/error');
    stream.once('data', function (listenAtLogLine) {
      t.ok(listenAtLogLine, 'listen at log message is ok');
      stream.once('data', function (line) {
        t.equal(line.msg, 'incoming request', 'message is set');
        stream.once('data', function (line) {
          t.equal(line.level, 30, 'level is correct');
          t.equal(line.msg, 'something happened', 'message is set');
          t.deepEqual(line.res, {
            statusCode: 415
          }, 'status code is set');
        });
      });
    });
  });
});
test('should redact the authorization header if so specified', function (t) {
  t.plan(7);
  var stream = split(JSON.parse);
  var fastify = Fastify({
    logger: {
      stream: stream,
      redact: ['req.headers.authorization'],
      level: 'info',
      serializers: {
        req: function req(_req3) {
          return {
            method: _req3.method,
            url: _req3.url,
            headers: _req3.headers,
            hostname: _req3.hostname,
            remoteAddress: _req3.ip,
            remotePort: _req3.connection.remotePort
          };
        }
      }
    }
  });
  fastify.get('/', function (req, reply) {
    t.is(req.headers.authorization, 'Bearer abcde');
    reply.send({
      hello: 'world'
    });
  });
  stream.once('data', function (listenAtLogLine) {
    t.ok(listenAtLogLine, 'listen at log message is ok');
    stream.once('data', function (line) {
      t.equal(line.req.headers.authorization, '[Redacted]', 'authorization is redacted');
    });
  });
  fastify.listen(0, function (err) {
    t.error(err);
    fastify.server.unref();
    sget({
      method: 'GET',
      url: 'http://localhost:' + fastify.server.address().port,
      headers: {
        authorization: 'Bearer abcde'
      }
    }, function (err, response, body) {
      t.error(err);
      t.strictEqual(response.statusCode, 200);
      t.deepEqual(body.toString(), JSON.stringify({
        hello: 'world'
      }));
    });
  });
});
test('should not log incoming request and outgoing response when disabled', function (t) {
  t.plan(3);
  var lines = [];
  var dest = new stream.Writable({
    write: function write(chunk, enc, cb) {
      lines.push(JSON.parse(chunk));
      cb();
    }
  });
  var fastify = Fastify({
    disableRequestLogging: true,
    logger: {
      level: 'info',
      stream: dest
    }
  });
  fastify.get('/500', function (req, reply) {
    reply.code(500).send(Error('500 error'));
  });
  fastify.inject({
    url: '/500',
    method: 'GET'
  }, function (e, res) {
    t.is(lines.length, 1);
    t.ok(lines[0].msg);
    t.is(lines[0].msg, '500 error');
  });
});