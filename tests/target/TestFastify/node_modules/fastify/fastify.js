'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.function.bind");

require("core-js/modules/es.function.name");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.ends-with");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Avvio = require('avvio');

var http = require('http');

var querystring = require('querystring');

var lightMyRequest;

var _require = require('./lib/symbols.js'),
    kChildren = _require.kChildren,
    kBodyLimit = _require.kBodyLimit,
    kRoutePrefix = _require.kRoutePrefix,
    kLogLevel = _require.kLogLevel,
    kHooks = _require.kHooks,
    kSchemas = _require.kSchemas,
    kSchemaCompiler = _require.kSchemaCompiler,
    kSchemaResolver = _require.kSchemaResolver,
    kReplySerializerDefault = _require.kReplySerializerDefault,
    kContentTypeParser = _require.kContentTypeParser,
    kReply = _require.kReply,
    kRequest = _require.kRequest,
    kMiddlewares = _require.kMiddlewares,
    kFourOhFour = _require.kFourOhFour,
    kState = _require.kState,
    kOptions = _require.kOptions,
    kGlobalHooks = _require.kGlobalHooks,
    kPluginNameChain = _require.kPluginNameChain;

var _require2 = require('./lib/server'),
    createServer = _require2.createServer;

var Reply = require('./lib/reply');

var Request = require('./lib/request');

var supportedMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'OPTIONS'];

var decorator = require('./lib/decorate');

var ContentTypeParser = require('./lib/contentTypeParser');

var _require3 = require('./lib/hooks'),
    Hooks = _require3.Hooks,
    buildHooks = _require3.buildHooks;

var _require4 = require('./lib/schemas'),
    Schemas = _require4.Schemas,
    buildSchemas = _require4.buildSchemas;

var _require5 = require('./lib/logger'),
    createLogger = _require5.createLogger;

var pluginUtils = require('./lib/pluginUtils');

var reqIdGenFactory = require('./lib/reqIdGenFactory');

var _require6 = require('./lib/route'),
    buildRouting = _require6.buildRouting,
    validateBodyLimitOption = _require6.validateBodyLimitOption;

var build404 = require('./lib/fourOhFour');

var getSecuredInitialConfig = require('./lib/initialConfigValidation');

var defaultInitOptions = getSecuredInitialConfig.defaultInitOptions;

function build(options) {
  var _fastify;

  // Options validations
  options = options || {};

  if (_typeof(options) !== 'object') {
    throw new TypeError('Options must be an object');
  }

  if (options.querystringParser && typeof options.querystringParser !== 'function') {
    throw new Error("querystringParser option should be a function, instead got '".concat(_typeof(options.querystringParser), "'"));
  }

  validateBodyLimitOption(options.bodyLimit);

  if (options.logger && options.logger.genReqId) {
    process.emitWarning("Using 'genReqId' in logger options is deprecated. Use fastify options instead. See: https://www.fastify.io/docs/latest/Server/#gen-request-id");
    options.genReqId = options.logger.genReqId;
  }

  var modifyCoreObjects = options.modifyCoreObjects !== false;
  var requestIdHeader = options.requestIdHeader || defaultInitOptions.requestIdHeader;
  var querystringParser = options.querystringParser || querystring.parse;
  var genReqId = options.genReqId || reqIdGenFactory();
  var requestIdLogLabel = options.requestIdLogLabel || 'reqId';
  var bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
  var disableRequestLogging = options.disableRequestLogging || false; // Instance Fastify components

  var _createLogger = createLogger(options),
      logger = _createLogger.logger,
      hasLogger = _createLogger.hasLogger; // Update the options with the fixed values


  options.logger = logger;
  options.modifyCoreObjects = modifyCoreObjects;
  options.genReqId = genReqId;
  options.requestIdHeader = requestIdHeader;
  options.querystringParser = querystringParser;
  options.requestIdLogLabel = requestIdLogLabel;
  options.modifyCoreObjects = modifyCoreObjects;
  options.disableRequestLogging = disableRequestLogging; // Default router

  var router = buildRouting({
    config: {
      defaultRoute: defaultRoute,
      ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
      maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
      caseSensitive: options.caseSensitive,
      versioning: options.versioning
    }
  }); // 404 router, used for handling encapsulated 404 handlers

  var fourOhFour = build404(options); // HTTP server and its handler

  var httpHandler = router.routing;

  var _createServer = createServer(options, httpHandler),
      server = _createServer.server,
      listen = _createServer.listen;

  if (Number(process.version.match(/v(\d+)/)[1]) >= 6) {
    server.on('clientError', handleClientError);
  }

  var setupResponseListeners = Reply.setupResponseListeners;
  var schemas = new Schemas(); // Public API

  var fastify = (_fastify = {}, _defineProperty(_fastify, kState, {
    listening: false,
    closing: false,
    started: false
  }), _defineProperty(_fastify, kOptions, options), _defineProperty(_fastify, kChildren, []), _defineProperty(_fastify, kBodyLimit, bodyLimit), _defineProperty(_fastify, kRoutePrefix, ''), _defineProperty(_fastify, kLogLevel, ''), _defineProperty(_fastify, kHooks, new Hooks()), _defineProperty(_fastify, kSchemas, schemas), _defineProperty(_fastify, kSchemaCompiler, null), _defineProperty(_fastify, kSchemaResolver, null), _defineProperty(_fastify, kReplySerializerDefault, null), _defineProperty(_fastify, kContentTypeParser, new ContentTypeParser(bodyLimit, options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning)), _defineProperty(_fastify, kReply, Reply.buildReply(Reply)), _defineProperty(_fastify, kRequest, Request.buildRequest(Request)), _defineProperty(_fastify, kMiddlewares, []), _defineProperty(_fastify, kFourOhFour, fourOhFour), _defineProperty(_fastify, kGlobalHooks, {
    onRoute: [],
    onRegister: []
  }), _defineProperty(_fastify, pluginUtils.registeredPlugins, []), _defineProperty(_fastify, kPluginNameChain, []), _defineProperty(_fastify, "delete", function _delete(url, opts, handler) {
    return router.prepareRoute.call(this, 'DELETE', url, opts, handler);
  }), _defineProperty(_fastify, "get", function _get(url, opts, handler) {
    return router.prepareRoute.call(this, 'GET', url, opts, handler);
  }), _defineProperty(_fastify, "head", function _head(url, opts, handler) {
    return router.prepareRoute.call(this, 'HEAD', url, opts, handler);
  }), _defineProperty(_fastify, "patch", function _patch(url, opts, handler) {
    return router.prepareRoute.call(this, 'PATCH', url, opts, handler);
  }), _defineProperty(_fastify, "post", function _post(url, opts, handler) {
    return router.prepareRoute.call(this, 'POST', url, opts, handler);
  }), _defineProperty(_fastify, "put", function _put(url, opts, handler) {
    return router.prepareRoute.call(this, 'PUT', url, opts, handler);
  }), _defineProperty(_fastify, "options", function _options(url, opts, handler) {
    return router.prepareRoute.call(this, 'OPTIONS', url, opts, handler);
  }), _defineProperty(_fastify, "all", function _all(url, opts, handler) {
    return router.prepareRoute.call(this, supportedMethods, url, opts, handler);
  }), _defineProperty(_fastify, "route", function _route(opts) {
    // we need the fastify object that we are producing so we apply a lazy loading of the function,
    // otherwise we should bind it after the declaration
    return router.route.call(this, opts);
  }), _defineProperty(_fastify, "log", logger), _defineProperty(_fastify, "addHook", addHook), _defineProperty(_fastify, "addSchema", addSchema), _defineProperty(_fastify, "getSchemas", schemas.getSchemas.bind(schemas)), _defineProperty(_fastify, "setSchemaCompiler", setSchemaCompiler), _defineProperty(_fastify, "setSchemaResolver", setSchemaResolver), _defineProperty(_fastify, "setReplySerializer", setReplySerializer), _defineProperty(_fastify, "addContentTypeParser", ContentTypeParser.helpers.addContentTypeParser), _defineProperty(_fastify, "hasContentTypeParser", ContentTypeParser.helpers.hasContentTypeParser), _defineProperty(_fastify, "register", null), _defineProperty(_fastify, "after", null), _defineProperty(_fastify, "ready", null), _defineProperty(_fastify, "onClose", null), _defineProperty(_fastify, "close", null), _defineProperty(_fastify, "listen", listen), _defineProperty(_fastify, "server", server), _defineProperty(_fastify, "decorate", decorator.add), _defineProperty(_fastify, "hasDecorator", decorator.exist), _defineProperty(_fastify, "decorateReply", decorator.decorateReply), _defineProperty(_fastify, "decorateRequest", decorator.decorateRequest), _defineProperty(_fastify, "hasRequestDecorator", decorator.existRequest), _defineProperty(_fastify, "hasReplyDecorator", decorator.existReply), _defineProperty(_fastify, "use", use), _defineProperty(_fastify, "inject", inject), _defineProperty(_fastify, "printRoutes", router.printRoutes), _defineProperty(_fastify, "setNotFoundHandler", setNotFoundHandler), _defineProperty(_fastify, "setErrorHandler", setErrorHandler), _defineProperty(_fastify, "initialConfig", getSecuredInitialConfig(options)), _fastify);
  Object.defineProperty(fastify, 'schemaCompiler', {
    get: function get() {
      return this[kSchemaCompiler];
    },
    set: function set(schemaCompiler) {
      this.setSchemaCompiler(schemaCompiler);
    }
  });
  Object.defineProperty(fastify, 'prefix', {
    get: function get() {
      return this[kRoutePrefix];
    }
  });
  Object.defineProperty(fastify, 'basePath', {
    get: function get() {
      process.emitWarning('basePath is deprecated. Use prefix instead. See: https://www.fastify.io/docs/latest/Server/#prefix');
      return this[kRoutePrefix];
    }
  });
  Object.defineProperty(fastify, 'pluginName', {
    get: function get() {
      if (this[kPluginNameChain].length > 1) {
        return this[kPluginNameChain].join(' -> ');
      }

      return this[kPluginNameChain][0];
    }
  }); // Install and configure Avvio
  // Avvio will update the following Fastify methods:
  // - register
  // - after
  // - ready
  // - onClose
  // - close

  var avvio = Avvio(fastify, {
    autostart: false,
    timeout: Number(options.pluginTimeout) || defaultInitOptions.pluginTimeout,
    expose: {
      use: 'register'
    }
  }); // Override to allow the plugin incapsulation

  avvio.override = override;
  avvio.on('start', function () {
    return fastify[kState].started = true;
  }); // cache the closing value, since we are checking it in an hot path

  avvio.once('preReady', function () {
    fastify.onClose(function (instance, done) {
      fastify[kState].closing = true;
      router.closeRoutes();

      if (fastify[kState].listening) {
        // No new TCP connections are accepted
        instance.server.close(done);
      } else {
        done(null);
      }
    });
  }); // Set the default 404 handler

  fastify.setNotFoundHandler();
  fourOhFour.arrange404(fastify);
  router.setup(options, {
    avvio: avvio,
    fourOhFour: fourOhFour,
    logger: logger,
    hasLogger: hasLogger,
    setupResponseListeners: setupResponseListeners,
    throwIfAlreadyStarted: throwIfAlreadyStarted
  });
  return fastify;

  function throwIfAlreadyStarted(msg) {
    if (fastify[kState].started) throw new Error(msg);
  } // HTTP injection handling
  // If the server is not ready yet, this
  // utility will automatically force it.


  function inject(opts, cb) {
    // lightMyRequest is dynamically laoded as it seems very expensive
    // because of Ajv
    if (lightMyRequest === undefined) {
      lightMyRequest = require('light-my-request');
    }

    if (fastify[kState].started) {
      if (fastify[kState].closing) {
        // Force to return an error
        var error = new Error('Server is closed');

        if (cb) {
          cb(error);
          return;
        } else {
          return Promise.reject(error);
        }
      }

      return lightMyRequest(httpHandler, opts, cb);
    }

    if (cb) {
      this.ready(function (err) {
        if (err) cb(err, null);else lightMyRequest(httpHandler, opts, cb);
      });
    } else {
      return this.ready().then(function () {
        return lightMyRequest(httpHandler, opts);
      });
    }
  } // wrapper tha we expose to the user for middlewares handling


  function use(url, fn) {
    var _this = this;

    throwIfAlreadyStarted('Cannot call "use" when fastify instance is already started!');

    if (typeof url === 'string') {
      var prefix = this[kRoutePrefix];
      url = prefix + (url === '/' && prefix.length > 0 ? '' : url);
    }

    return this.after(function (err, done) {
      addMiddleware.call(_this, [url, fn]);
      done(err);
    });

    function addMiddleware(middleware) {
      this[kMiddlewares].push(middleware);
      this[kChildren].forEach(function (child) {
        return addMiddleware.call(child, middleware);
      });
    }
  } // wrapper that we expose to the user for hooks handling


  function addHook(name, fn) {
    var _this2 = this;

    throwIfAlreadyStarted('Cannot call "addHook" when fastify instance is already started!'); // TODO: v3 instead of log a warning, throw an error

    if (name === 'onSend' || name === 'preSerialization' || name === 'onError') {
      if (fn.constructor.name === 'AsyncFunction' && fn.length === 4) {
        fastify.log.warn("Async function has too many arguments. Async hooks should not use the 'next' argument.", new Error().stack);
      }
    } else {
      if (fn.constructor.name === 'AsyncFunction' && fn.length === 3) {
        fastify.log.warn("Async function has too many arguments. Async hooks should not use the 'next' argument.", new Error().stack);
      }
    }

    if (name === 'onClose') {
      this[kHooks].validate(name, fn);
      this.onClose(fn);
    } else if (name === 'onRoute') {
      this[kHooks].validate(name, fn);
      this[kGlobalHooks].onRoute.push(fn);
    } else if (name === 'onRegister') {
      this[kHooks].validate(name, fn);
      this[kGlobalHooks].onRegister.push(fn);
    } else {
      this.after(function (err, done) {
        _addHook.call(_this2, name, fn);

        done(err);
      });
    }

    return this;

    function _addHook(name, fn) {
      this[kHooks].add(name, fn.bind(this));
      this[kChildren].forEach(function (child) {
        return _addHook.call(child, name, fn);
      });
    }
  } // wrapper that we expose to the user for schemas handling


  function addSchema(schema) {
    throwIfAlreadyStarted('Cannot call "addSchema" when fastify instance is already started!');
    this[kSchemas].add(schema);
    this[kChildren].forEach(function (child) {
      return child.addSchema(schema);
    });
    return this;
  }

  function handleClientError(err, socket) {
    var body = JSON.stringify({
      error: http.STATUS_CODES['400'],
      message: 'Client Error',
      statusCode: 400
    });
    logger.debug({
      err: err
    }, 'client error');
    socket.end("HTTP/1.1 400 Bad Request\r\nContent-Length: ".concat(body.length, "\r\nContent-Type: application/json\r\n\r\n").concat(body));
  } // If the router does not match any route, every request will land here
  // req and res are Node.js core objects


  function defaultRoute(req, res) {
    if (req.headers['accept-version'] !== undefined) {
      req.headers['accept-version'] = undefined;
    }

    fourOhFour.router.lookup(req, res);
  }

  function setNotFoundHandler(opts, handler) {
    throwIfAlreadyStarted('Cannot call "setNotFoundHandler" when fastify instance is already started!');
    fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
  } // wrapper that we expose to the user for schemas compiler handling


  function setSchemaCompiler(schemaCompiler) {
    throwIfAlreadyStarted('Cannot call "setSchemaCompiler" when fastify instance is already started!');
    this[kSchemaCompiler] = schemaCompiler;
    return this;
  }

  function setSchemaResolver(schemaRefResolver) {
    throwIfAlreadyStarted('Cannot call "setSchemaResolver" when fastify instance is already started!');
    this[kSchemaResolver] = schemaRefResolver;
    return this;
  }

  function setReplySerializer(replySerializer) {
    throwIfAlreadyStarted('Cannot call "setReplySerializer" when fastify instance is already started!');
    this[kReplySerializerDefault] = replySerializer;
    return this;
  } // wrapper that we expose to the user for configure the custom error handler


  function setErrorHandler(func) {
    throwIfAlreadyStarted('Cannot call "setErrorHandler" when fastify instance is already started!');
    this._errorHandler = func;
    return this;
  }
} // Function that runs the encapsulation magic.
// Everything that need to be encapsulated must be handled in this function.


function override(old, fn, opts) {
  var shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn);

  if (shouldSkipOverride) {
    // after every plugin registration we will enter a new name
    old[kPluginNameChain].push(pluginUtils.getDisplayName(fn));
    return old;
  }

  var instance = Object.create(old);
  old[kChildren].push(instance);
  instance[kChildren] = [];
  instance[kReply] = Reply.buildReply(instance[kReply]);
  instance[kRequest] = Request.buildRequest(instance[kRequest]);
  instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
  instance[kHooks] = buildHooks(instance[kHooks]);
  instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
  instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
  instance[kMiddlewares] = old[kMiddlewares].slice();
  instance[kSchemas] = buildSchemas(old[kSchemas]);
  instance.getSchemas = instance[kSchemas].getSchemas.bind(instance[kSchemas]);
  instance[pluginUtils.registeredPlugins] = Object.create(instance[pluginUtils.registeredPlugins]);
  instance[kPluginNameChain] = [pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn)];

  if (opts.prefix) {
    instance[kFourOhFour].arrange404(instance);
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = instance[kGlobalHooks].onRegister[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var hook = _step.value;
      hook.call(this, instance);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return instance;
}

function buildRoutePrefix(instancePrefix, pluginPrefix) {
  if (!pluginPrefix) {
    return instancePrefix;
  } // Ensure that there is a '/' between the prefixes


  if (instancePrefix.endsWith('/')) {
    if (pluginPrefix[0] === '/') {
      // Remove the extra '/' to avoid: '/first//second'
      pluginPrefix = pluginPrefix.slice(1);
    }
  } else if (pluginPrefix[0] !== '/') {
    pluginPrefix = '/' + pluginPrefix;
  }

  return instancePrefix + pluginPrefix;
}

module.exports = build;