'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.bind");

require("core-js/modules/es.map");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.number.is-integer");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.ends-with");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.iterator");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FindMyWay = require('find-my-way');

var proxyAddr = require('proxy-addr');

var Context = require('./context');

var _require = require('./middleware'),
    buildMiddie = _require.buildMiddie,
    onRunMiddlewares = _require.onRunMiddlewares;

var _require2 = require('./hooks'),
    hookRunner = _require2.hookRunner,
    hookIterator = _require2.hookIterator;

var supportedMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'OPTIONS'];
var supportedHooks = ['preParsing', 'preValidation', 'onRequest', 'preHandler', 'preSerialization', 'onResponse'];

var validation = require('./validation');

var buildSchema = validation.build;
var buildSchemaCompiler = validation.buildSchemaCompiler;

var _require3 = require('./warnings'),
    beforeHandlerWarning = _require3.beforeHandlerWarning;

var _require4 = require('./errors'),
    _require4$codes = _require4.codes,
    FST_ERR_SCH_BUILD = _require4$codes.FST_ERR_SCH_BUILD,
    FST_ERR_SCH_MISSING_COMPILER = _require4$codes.FST_ERR_SCH_MISSING_COMPILER;

var _require5 = require('./symbols.js'),
    kRoutePrefix = _require5.kRoutePrefix,
    kLogLevel = _require5.kLogLevel,
    kHooks = _require5.kHooks,
    kSchemas = _require5.kSchemas,
    kSchemaCompiler = _require5.kSchemaCompiler,
    kSchemaResolver = _require5.kSchemaResolver,
    kContentTypeParser = _require5.kContentTypeParser,
    kReply = _require5.kReply,
    kReplySerializerDefault = _require5.kReplySerializerDefault,
    kRequest = _require5.kRequest,
    kMiddlewares = _require5.kMiddlewares,
    kGlobalHooks = _require5.kGlobalHooks,
    kDisableRequestLogging = _require5.kDisableRequestLogging;

function buildRouting(options) {
  var router = FindMyWay(options.config);
  var schemaCache = new Map();
  schemaCache.put = schemaCache.set;
  var avvio;
  var fourOhFour;
  var trustProxy;
  var requestIdHeader;
  var querystringParser;
  var requestIdLogLabel;
  var logger;
  var hasLogger;
  var setupResponseListeners;
  var throwIfAlreadyStarted;
  var proxyFn;
  var modifyCoreObjects;
  var genReqId;
  var disableRequestLogging;
  var ignoreTrailingSlash;
  var return503OnClosing;
  var closing = false;
  return {
    setup: function setup(options, fastifyArgs) {
      avvio = fastifyArgs.avvio;
      fourOhFour = fastifyArgs.fourOhFour;
      logger = fastifyArgs.logger;
      hasLogger = fastifyArgs.hasLogger;
      setupResponseListeners = fastifyArgs.setupResponseListeners;
      throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
      proxyFn = getTrustProxyFn(options);
      trustProxy = options.trustProxy;
      requestIdHeader = options.requestIdHeader;
      querystringParser = options.querystringParser;
      requestIdLogLabel = options.requestIdLogLabel;
      modifyCoreObjects = options.modifyCoreObjects;
      genReqId = options.genReqId;
      disableRequestLogging = options.disableRequestLogging;
      ignoreTrailingSlash = options.ignoreTrailingSlash;
      return503OnClosing = Object.prototype.hasOwnProperty.call(options, 'return503OnClosing') ? options.return503OnClosing : true;
    },
    routing: router.lookup.bind(router),
    // router func to find the right handler to call
    route: route,
    // configure a route in the fastify instance
    prepareRoute: prepareRoute,
    routeHandler: routeHandler,
    closeRoutes: function closeRoutes() {
      closing = true;
    },
    printRoutes: router.prettyPrint.bind(router)
  }; // Convert shorthand to extended route declaration

  function prepareRoute(method, url, options, handler) {
    if (!handler && typeof options === 'function') {
      handler = options;
      options = {};
    } else if (handler && typeof handler === 'function') {
      if (Object.prototype.toString.call(options) !== '[object Object]') {
        throw new Error("Options for ".concat(method, ":").concat(url, " route must be an object"));
      } else if (options.handler) {
        if (typeof options.handler === 'function') {
          throw new Error("Duplicate handler for ".concat(method, ":").concat(url, " route is not allowed!"));
        } else {
          throw new Error("Handler for ".concat(method, ":").concat(url, " route must be a function"));
        }
      }
    }

    options = Object.assign({}, options, {
      method: method,
      url: url,
      handler: handler || options && options.handler
    });
    return route.call(this, options);
  } // Route management


  function route(opts) {
    var _this = this;

    throwIfAlreadyStarted('Cannot add route when fastify instance is already started!');

    if (Array.isArray(opts.method)) {
      for (var i = 0; i < opts.method.length; i++) {
        if (supportedMethods.indexOf(opts.method[i]) === -1) {
          throw new Error("".concat(opts.method[i], " method is not supported!"));
        }
      }
    } else {
      if (supportedMethods.indexOf(opts.method) === -1) {
        throw new Error("".concat(opts.method, " method is not supported!"));
      }
    }

    if (!opts.handler) {
      throw new Error("Missing handler function for ".concat(opts.method, ":").concat(opts.url, " route."));
    }

    validateBodyLimitOption(opts.bodyLimit);

    if (opts.preHandler == null && opts.beforeHandler != null) {
      beforeHandlerWarning();
      opts.preHandler = opts.beforeHandler;
    }

    var prefix = this[kRoutePrefix];
    this.after(function (notHandledErr, done) {
      var path = opts.url || opts.path;

      if (path === '/' && prefix.length > 0) {
        switch (opts.prefixTrailingSlash) {
          case 'slash':
            afterRouteAdded.call(_this, path, notHandledErr, done);
            break;

          case 'no-slash':
            afterRouteAdded.call(_this, '', notHandledErr, done);
            break;

          case 'both':
          default:
            afterRouteAdded.call(_this, '', notHandledErr, done); // If ignoreTrailingSlash is set to true we need to add only the '' route to prevent adding an incomplete one.

            if (ignoreTrailingSlash !== true) {
              afterRouteAdded.call(_this, path, notHandledErr, done);
            }

        }
      } else if (path[0] === '/' && prefix.endsWith('/')) {
        // Ensure that '/prefix/' + '/route' gets registered as '/prefix/route'
        afterRouteAdded.call(_this, path.slice(1), notHandledErr, done);
      } else {
        afterRouteAdded.call(_this, path, notHandledErr, done);
      }
    }); // chainable api

    return this;

    function afterRouteAdded(path, notHandledErr, done) {
      var _this2 = this;

      var url = prefix + path;
      opts.url = url;
      opts.path = url;
      opts.prefix = prefix;
      opts.logLevel = opts.logLevel || this[kLogLevel];

      if (opts.attachValidation == null) {
        opts.attachValidation = false;
      } // run 'onRoute' hooks


      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this[kGlobalHooks].onRoute[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var hook = _step.value;

          try {
            hook.call(this, opts);
          } catch (error) {
            done(error);
            return;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var config = opts.config || {};
      config.url = url;
      var context = new Context(opts.schema, opts.handler.bind(this), this[kReply], this[kRequest], this[kContentTypeParser], config, this._errorHandler, opts.bodyLimit, opts.logLevel, opts.attachValidation, this[kReplySerializerDefault]); // TODO this needs to be refactored so that buildSchemaCompiler is
      // not called for every single route. Creating a new one for every route
      // is going to be very expensive.

      if (opts.schema) {
        if (this[kSchemaCompiler] == null && this[kSchemaResolver]) {
          done(new FST_ERR_SCH_MISSING_COMPILER(opts.method, url));
          return;
        }

        try {
          if (opts.schemaCompiler == null && this[kSchemaCompiler] == null) {
            var externalSchemas = this[kSchemas].getJsonSchemas({
              onlyAbsoluteUri: true
            });
            this.setSchemaCompiler(buildSchemaCompiler(externalSchemas, schemaCache));
          }

          buildSchema(context, opts.schemaCompiler || this[kSchemaCompiler], this[kSchemas], this[kSchemaResolver]);
        } catch (error) {
          // bubble up the FastifyError instance
          done(error.code ? error : new FST_ERR_SCH_BUILD(opts.method, url, error.message));
          return;
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = supportedHooks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _hook = _step2.value;

          if (opts[_hook]) {
            if (Array.isArray(opts[_hook])) {
              opts[_hook] = opts[_hook].map(function (fn) {
                return fn.bind(_this2);
              });
            } else {
              opts[_hook] = opts[_hook].bind(this);
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      try {
        router.on(opts.method, url, {
          version: opts.version
        }, routeHandler, context);
      } catch (err) {
        done(err);
        return;
      } // It can happen that a user register a plugin with some hooks/middlewares *after*
      // the route registration. To be sure to load also that hooks/middlewares,
      // we must listen for the avvio's preReady event, and update the context object accordingly.


      avvio.once('preReady', function () {
        var onResponse = _this2[kHooks].onResponse;
        var onSend = _this2[kHooks].onSend;
        var onError = _this2[kHooks].onError;
        context.onSend = onSend.length ? onSend : null;
        context.onError = onError.length ? onError : null;
        context.onResponse = onResponse.length ? onResponse : null;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = supportedHooks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var hook = _step3.value;

            var toSet = _this2[kHooks][hook].concat(opts[hook] || []);

            context[hook] = toSet.length ? toSet : null;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        context._middie = buildMiddie(_this2[kMiddlewares]); // Must store the 404 Context in 'preReady' because it is only guaranteed to
        // be available after all of the plugins and routes have been loaded.

        fourOhFour.setContext(_this2, context);
      });
      done(notHandledErr);
    }
  } // HTTP request entry point, the routing has already been executed


  function routeHandler(req, res, params, context) {
    var _logger$child;

    if (closing === true) {
      if (req.httpVersionMajor !== 2) {
        res.once('finish', function () {
          return req.destroy();
        });
        res.setHeader('Connection', 'close');
      }

      if (return503OnClosing) {
        var headers = {
          'Content-Type': 'application/json',
          'Content-Length': '80'
        };
        res.writeHead(503, headers);
        res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
        return;
      }
    }

    req.id = req.headers[requestIdHeader] || genReqId(req);
    req.originalUrl = req.url;
    var hostname = req.headers.host;
    var ip = req.connection.remoteAddress;
    var ips;

    if (trustProxy) {
      ip = proxyAddr(req, proxyFn);
      ips = proxyAddr.all(req, proxyFn);

      if (ip !== undefined && req.headers['x-forwarded-host']) {
        hostname = req.headers['x-forwarded-host'];
      }
    }

    var childLogger = logger.child((_logger$child = {}, _defineProperty(_logger$child, requestIdLogLabel, req.id), _defineProperty(_logger$child, "level", context.logLevel), _logger$child));
    childLogger[kDisableRequestLogging] = disableRequestLogging; // added hostname, ip, and ips back to the Node req object to maintain backward compatibility

    if (modifyCoreObjects) {
      req.hostname = hostname;
      req.ip = ip;
      req.ips = ips;
      req.log = res.log = childLogger;
    }

    if (disableRequestLogging === false) {
      childLogger.info({
        req: req
      }, 'incoming request');
    }

    var queryPrefix = req.url.indexOf('?');
    var query = querystringParser(queryPrefix > -1 ? req.url.slice(queryPrefix + 1) : '');
    var request = new context.Request(params, req, query, req.headers, childLogger, ip, ips, hostname);
    var reply = new context.Reply(res, context, request, childLogger);

    if (hasLogger === true || context.onResponse !== null) {
      setupResponseListeners(reply);
    }

    if (context.onRequest !== null) {
      hookRunner(context.onRequest, hookIterator, request, reply, middlewareCallback);
    } else {
      middlewareCallback(null, request, reply);
    }
  }
}

function validateBodyLimitOption(bodyLimit) {
  if (bodyLimit === undefined) return;

  if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
    throw new TypeError("'bodyLimit' option must be an integer > 0. Got '".concat(bodyLimit, "'"));
  }
}

function middlewareCallback(err, request, reply) {
  if (reply.sent === true) return;

  if (err != null) {
    reply.send(err);
    return;
  }

  if (reply.context._middie !== null) {
    reply.context._middie.run(request.raw, reply.res, reply);
  } else {
    onRunMiddlewares(null, null, null, reply);
  }
}

function getTrustProxyFn(options) {
  var tp = options.trustProxy;

  if (typeof tp === 'function') {
    return tp;
  }

  if (tp === true) {
    // Support plain true/false
    return function () {
      return true;
    };
  }

  if (typeof tp === 'number') {
    // Support trusting hop count
    return function (a, i) {
      return i < tp;
    };
  }

  if (typeof tp === 'string') {
    // Support comma-separated tps
    var vals = tp.split(',').map(function (it) {
      return it.trim();
    });
    return proxyAddr.compile(vals);
  }

  return proxyAddr.compile(tp || []);
}

module.exports = {
  buildRouting: buildRouting,
  validateBodyLimitOption: validateBodyLimitOption
};