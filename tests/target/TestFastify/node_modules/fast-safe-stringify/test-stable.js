"use strict";

require("core-js/modules/es.date.to-json");

require("core-js/modules/es.object.define-property");

require("core-js/modules/web.url.to-json");

var test = require('tap').test;

var fss = require('./').stable;

var clone = require('clone');

var s = JSON.stringify;
test('circular reference to root', function (assert) {
  var fixture = {
    name: 'Tywin Lannister'
  };
  fixture.circle = fixture;
  var expected = s({
    circle: '[Circular]',
    name: 'Tywin Lannister'
  });
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('circular getter reference to root', function (assert) {
  var fixture = {
    name: 'Tywin Lannister',

    get circle() {
      return fixture;
    }

  };
  var expected = s({
    circle: '[Circular]',
    name: 'Tywin Lannister'
  });
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('nested circular reference to root', function (assert) {
  var fixture = {
    name: 'Tywin Lannister'
  };
  fixture.id = {
    circle: fixture
  };
  var expected = s({
    id: {
      circle: '[Circular]'
    },
    name: 'Tywin Lannister'
  });
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('child circular reference', function (assert) {
  var fixture = {
    name: 'Tywin Lannister',
    child: {
      name: 'Tyrion Lannister'
    }
  };
  fixture.child.dinklage = fixture.child;
  var expected = s({
    child: {
      dinklage: '[Circular]',
      name: 'Tyrion Lannister'
    },
    name: 'Tywin Lannister'
  });
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('nested child circular reference', function (assert) {
  var fixture = {
    name: 'Tywin Lannister',
    child: {
      name: 'Tyrion Lannister'
    }
  };
  fixture.child.actor = {
    dinklage: fixture.child
  };
  var expected = s({
    child: {
      actor: {
        dinklage: '[Circular]'
      },
      name: 'Tyrion Lannister'
    },
    name: 'Tywin Lannister'
  });
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('circular objects in an array', function (assert) {
  var fixture = {
    name: 'Tywin Lannister'
  };
  fixture.hand = [fixture, fixture];
  var expected = s({
    hand: ['[Circular]', '[Circular]'],
    name: 'Tywin Lannister'
  });
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('nested circular references in an array', function (assert) {
  var fixture = {
    name: 'Tywin Lannister',
    offspring: [{
      name: 'Tyrion Lannister'
    }, {
      name: 'Cersei Lannister'
    }]
  };
  fixture.offspring[0].dinklage = fixture.offspring[0];
  fixture.offspring[1].headey = fixture.offspring[1];
  var expected = s({
    name: 'Tywin Lannister',
    offspring: [{
      dinklage: '[Circular]',
      name: 'Tyrion Lannister'
    }, {
      headey: '[Circular]',
      name: 'Cersei Lannister'
    }]
  });
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('circular arrays', function (assert) {
  var fixture = [];
  fixture.push(fixture, fixture);
  var expected = s(['[Circular]', '[Circular]']);
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('nested circular arrays', function (assert) {
  var fixture = [];
  fixture.push({
    name: 'Jon Snow',
    bastards: fixture
  }, {
    name: 'Ramsay Bolton',
    bastards: fixture
  });
  var expected = s([{
    bastards: '[Circular]',
    name: 'Jon Snow'
  }, {
    bastards: '[Circular]',
    name: 'Ramsay Bolton'
  }]);
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('repeated non-circular references in objects', function (assert) {
  var daenerys = {
    name: 'Daenerys Targaryen'
  };
  var fixture = {
    motherOfDragons: daenerys,
    queenOfMeereen: daenerys
  };
  var expected = s(fixture);
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('repeated non-circular references in arrays', function (assert) {
  var daenerys = {
    name: 'Daenerys Targaryen'
  };
  var fixture = [daenerys, daenerys];
  var expected = s(fixture);
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});
test('double child circular reference', function (assert) {
  // create circular reference
  var child = {
    name: 'Tyrion Lannister'
  };
  child.dinklage = child; // include it twice in the fixture

  var fixture = {
    name: 'Tywin Lannister',
    childA: child,
    childB: child
  };
  var cloned = clone(fixture);
  var expected = s({
    childA: {
      dinklage: '[Circular]',
      name: 'Tyrion Lannister'
    },
    childB: {
      dinklage: '[Circular]',
      name: 'Tyrion Lannister'
    },
    name: 'Tywin Lannister'
  });
  var actual = fss(fixture);
  assert.is(actual, expected); // check if the fixture has not been modified

  assert.deepEqual(fixture, cloned);
  assert.end();
});
test('child circular reference with toJSON', function (assert) {
  // Create a test object that has an overriden `toJSON` property
  TestObject.prototype.toJSON = function () {
    return {
      special: 'case'
    };
  };

  function TestObject(content) {} // Creating a simple circular object structure


  var parentObject = {};
  parentObject.childObject = new TestObject();
  parentObject.childObject.parentObject = parentObject; // Creating a simple circular object structure

  var otherParentObject = new TestObject();
  otherParentObject.otherChildObject = {};
  otherParentObject.otherChildObject.otherParentObject = otherParentObject; // Making sure our original tests work

  assert.deepEqual(parentObject.childObject.parentObject, parentObject);
  assert.deepEqual(otherParentObject.otherChildObject.otherParentObject, otherParentObject); // Should both be idempotent

  assert.equal(fss(parentObject), '{"childObject":{"special":"case"}}');
  assert.equal(fss(otherParentObject), '{"special":"case"}'); // Therefore the following assertion should be `true`

  assert.deepEqual(parentObject.childObject.parentObject, parentObject);
  assert.deepEqual(otherParentObject.otherChildObject.otherParentObject, otherParentObject);
  assert.end();
});
test('null object', function (assert) {
  var expected = s(null);
  var actual = fss(null);
  assert.is(actual, expected);
  assert.end();
});
test('null property', function (assert) {
  var expected = s({
    f: null
  });
  var actual = fss({
    f: null
  });
  assert.is(actual, expected);
  assert.end();
});
test('nested child circular reference in toJSON', function (assert) {
  var circle = {
    some: 'data'
  };
  circle.circle = circle;
  var a = {
    b: {
      toJSON: function toJSON() {
        a.b = 2;
        return '[Redacted]';
      }
    },
    baz: {
      circle: circle,
      toJSON: function toJSON() {
        a.baz = circle;
        return '[Redacted]';
      }
    }
  };
  var o = {
    a: a,
    bar: a
  };
  var expected = s({
    a: {
      b: '[Redacted]',
      baz: '[Redacted]'
    },
    bar: {
      // TODO: This is a known limitation of the current implementation.
      // The ideal result would be:
      //
      // b: 2,
      // baz: {
      //   circle: '[Circular]',
      //   some: 'data'
      // }
      //
      b: '[Redacted]',
      baz: '[Redacted]'
    }
  });
  var actual = fss(o);
  assert.is(actual, expected);
  assert.end();
});
test('circular getters are restored when stringified', function (assert) {
  var fixture = {
    name: 'Tywin Lannister',

    get circle() {
      return fixture;
    }

  };
  fss(fixture);
  assert.is(fixture.circle, fixture);
  assert.end();
});
test('non-configurable circular getters use a replacer instead of markers', function (assert) {
  var fixture = {
    name: 'Tywin Lannister'
  };
  Object.defineProperty(fixture, 'circle', {
    configurable: false,
    get: function get() {
      return fixture;
    },
    enumerable: true
  });
  fss(fixture);
  assert.is(fixture.circle, fixture);
  assert.end();
});
test('getter child circular reference', function (assert) {
  var fixture = {
    name: 'Tywin Lannister',
    child: {
      name: 'Tyrion Lannister',

      get dinklage() {
        return fixture.child;
      }

    },

    get self() {
      return fixture;
    }

  };
  var expected = s({
    child: {
      dinklage: '[Circular]',
      name: 'Tyrion Lannister'
    },
    name: 'Tywin Lannister',
    self: '[Circular]'
  });
  var actual = fss(fixture);
  assert.is(actual, expected);
  assert.end();
});