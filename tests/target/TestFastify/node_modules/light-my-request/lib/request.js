'use strict';
/* eslint no-prototype-builtins: 0 */

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.immediate");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.immediate");

var _require = require('readable-stream'),
    Readable = _require.Readable;

var util = require('util');

var parseURL = require('./parseURL');
/**
 * Get hostname:port
 *
 * @param {URL} parsedURL
 * @return {String}
 */


function hostHeaderFromURL(parsedURL) {
  return parsedURL.port ? parsedURL.host : parsedURL.hostname + (parsedURL.protocol === 'https:' ? ':443' : ':80');
}
/**
 * Request
 *
 * @constructor
 * @param {Object} options
 * @param {(Object|String)} options.url || options.path
 * @param {String} [options.method='GET']
 * @param {String} [options.remoteAddress]
 * @param {Object} [options.headers]
 * @param {Object} [options.query]
 * @param {any} [options.payload]
 */


function Request(options) {
  var _this = this;

  Readable.call(this);
  var parsedURL = parseURL(options.url || options.path, options.query);
  this.url = parsedURL.pathname + parsedURL.search;
  this.httpVersion = '1.1';
  this.method = options.method ? options.method.toUpperCase() : 'GET';
  this.headers = {};
  var headers = options.headers || {};
  Object.keys(headers).forEach(function (field) {
    _this.headers[field.toLowerCase()] = headers[field];
  });
  this.headers['user-agent'] = this.headers['user-agent'] || 'lightMyRequest';
  this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);
  this.connection = {
    remoteAddress: options.remoteAddress || '127.0.0.1'
  }; // we keep both payload and body for compatibility reasons

  var payload = options.payload || options.body || null;

  if (payload && typeof payload !== 'string' && !(typeof payload.resume === 'function') && !Buffer.isBuffer(payload)) {
    payload = JSON.stringify(payload);
    this.headers['content-type'] = this.headers['content-type'] || 'application/json';
  } // Set the content-length for the corresponding payload if none set


  if (payload && !(typeof payload.resume === 'function') && !this.headers.hasOwnProperty('content-length')) {
    this.headers['content-length'] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
  } // Use _lightMyRequest namespace to avoid collision with Node


  this._lightMyRequest = {
    payload: payload,
    isDone: false,
    simulate: options.simulate || {}
  };
  return this;
}

util.inherits(Request, Readable);

Request.prototype.prepare = function (next) {
  var _this2 = this;

  var payload = this._lightMyRequest.payload;

  if (!payload || typeof payload.resume !== 'function') {
    // does not quack like a stream
    return next();
  }

  var chunks = [];
  payload.on('data', function (chunk) {
    return chunks.push(Buffer.from(chunk));
  });
  payload.on('end', function () {
    var payload = Buffer.concat(chunks);
    _this2.headers['content-length'] = _this2.headers['content-length'] || '' + payload.length;
    _this2._lightMyRequest.payload = payload;
    return next();
  }); // Force to resume the stream. Needed for Stream 1

  payload.resume();
};

Request.prototype._read = function (size) {
  var _this3 = this;

  setImmediate(function () {
    if (_this3._lightMyRequest.isDone) {
      // 'end' defaults to true
      if (_this3._lightMyRequest.simulate.end !== false) {
        _this3.push(null);
      }

      return;
    }

    _this3._lightMyRequest.isDone = true;

    if (_this3._lightMyRequest.payload) {
      if (_this3._lightMyRequest.simulate.split) {
        _this3.push(_this3._lightMyRequest.payload.slice(0, 1));

        _this3.push(_this3._lightMyRequest.payload.slice(1));
      } else {
        _this3.push(_this3._lightMyRequest.payload);
      }
    }

    if (_this3._lightMyRequest.simulate.error) {
      _this3.emit('error', new Error('Simulated'));
    }

    if (_this3._lightMyRequest.simulate.close) {
      _this3.emit('close');
    } // 'end' defaults to true


    if (_this3._lightMyRequest.simulate.end !== false) {
      _this3.push(null);
    }
  });
};

Request.prototype.destroy = function () {};

module.exports = Request;