'use strict';

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.immediate");

var http = require('http');

var _require = require('readable-stream'),
    Writable = _require.Writable;

var util = require('util');

function Response(req, onEnd, reject) {
  var _this = this;

  http.ServerResponse.call(this, {
    method: req.method,
    httpVersionMajor: 1,
    httpVersionMinor: 1
  });
  this._lightMyRequest = {
    headers: null,
    trailers: {},
    payloadChunks: []
  }; // This forces node@8 to always render the headers

  this.setHeader('foo', 'bar');
  this.removeHeader('foo');
  this.assignSocket(getNullSocket());
  this._promiseCallback = typeof reject === 'function';

  var onEndSuccess = function onEndSuccess(payload) {
    if (_this._promiseCallback) {
      return process.nextTick(function () {
        return onEnd(payload);
      });
    }

    process.nextTick(function () {
      return onEnd(null, payload);
    });
  };

  var onEndFailure = function onEndFailure(err) {
    if (_this._promiseCallback) {
      return process.nextTick(function () {
        return reject(err);
      });
    }

    process.nextTick(function () {
      return onEnd(err, null);
    });
  };

  this.once('finish', function () {
    var res = generatePayload(_this);
    res.raw.req = req;
    onEndSuccess(res);
  });
  this.connection.once('error', onEndFailure);
  this.once('error', onEndFailure);
}

util.inherits(Response, http.ServerResponse);

Response.prototype.writeHead = function () {
  var _this2 = this;

  var result = http.ServerResponse.prototype.writeHead.apply(this, arguments);

  var _headers = this.getHeaders ? this.getHeaders() : this._headers;

  this._lightMyRequest.headers = Object.assign({}, _headers) // Add raw headers
  ;
  ['Date', 'Connection', 'Transfer-Encoding'].forEach(function (name) {
    var regex = new RegExp('\\r\\n' + name + ': ([^\\r]*)\\r\\n');

    var field = _this2._header.match(regex);

    if (field) {
      _this2._lightMyRequest.headers[name.toLowerCase()] = field[1];
    }
  });
  return result;
};

Response.prototype.write = function (data, encoding, callback) {
  http.ServerResponse.prototype.write.call(this, data, encoding, callback);

  this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding));

  return true;
};

Response.prototype.end = function (data, encoding, callback) {
  if (data) {
    this.write(data, encoding);
  }

  http.ServerResponse.prototype.end.call(this, callback);
  this.emit('finish');
};

Response.prototype.destroy = function () {};

Response.prototype.addTrailers = function (trailers) {
  for (var key in trailers) {
    this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
  }
};

function generatePayload(response) {
  // Prepare response object
  var res = {
    raw: {
      res: response
    },
    headers: response._lightMyRequest.headers,
    statusCode: response.statusCode,
    statusMessage: response.statusMessage,
    trailers: {}
  }; // Prepare payload and trailers

  var rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks);
  res.rawPayload = rawBuffer; // we keep both of them for compatibility reasons

  res.payload = rawBuffer.toString();
  res.body = res.payload;
  res.trailers = response._lightMyRequest.trailers; // Prepare payload parsers

  res.json = function parseJsonPayload() {
    if (this.headers['content-type'].indexOf('application/json') < 0) {
      throw new Error('The content-type of the response is not application/json');
    }

    return JSON.parse(this.payload);
  };

  return res;
} // Throws away all written data to prevent response from buffering payload


function getNullSocket() {
  return new Writable({
    write: function write(chunk, encoding, callback) {
      setImmediate(callback);
    }
  });
}

module.exports = Response;