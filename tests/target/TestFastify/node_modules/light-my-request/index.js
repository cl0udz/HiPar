'use strict';

var assert = require('assert');

var http = require('http');

var Ajv = require('ajv');

var Request = require('./lib/request');

var Response = require('./lib/response');

var errorMessage = 'The dispatch function has already been invoked';
var urlSchema = {
  oneOf: [{
    type: 'string'
  }, {
    type: 'object',
    properties: {
      protocol: {
        type: 'string'
      },
      hostname: {
        type: 'string'
      },
      pathname: {
        type: 'string'
      } // port type => any
      // query type => any

    },
    additionalProperties: true,
    required: ['pathname']
  }]
};
var ajv = new Ajv();
var schema = {
  type: 'object',
  properties: {
    url: urlSchema,
    path: urlSchema,
    headers: {
      type: 'object',
      additionalProperties: true
    },
    query: {
      type: 'object',
      additionalProperties: true
    },
    simulate: {
      type: 'object',
      properties: {
        end: {
          type: 'boolean'
        },
        split: {
          type: 'boolean'
        },
        error: {
          type: 'boolean'
        },
        close: {
          type: 'boolean'
        }
      }
    },
    authority: {
      type: 'string'
    },
    remoteAddress: {
      type: 'string'
    },
    method: {
      type: 'string',
      enum: http.METHODS.concat(http.METHODS.map(toLowerCase))
    },
    validate: {
      type: 'boolean'
    } // payload type => any

  },
  additionalProperties: true,
  oneOf: [{
    required: ['url']
  }, {
    required: ['path']
  }]
};
var optsValidator = ajv.compile(schema);

function inject(dispatchFunc, options, callback) {
  if (typeof callback === 'undefined') {
    return new Chain(dispatchFunc, options);
  } else {
    return doInject(dispatchFunc, options, callback);
  }
}

function doInject(dispatchFunc, options, callback) {
  options = typeof options === 'string' ? {
    url: options
  } : options;

  if (options.validate !== false) {
    assert(typeof dispatchFunc === 'function', 'dispatchFunc should be a function');
    var isOptionValid = optsValidator(options);

    if (!isOptionValid) {
      throw new Error(optsValidator.errors.map(function (e) {
        return e.message;
      }));
    }
  }

  var server = options.server || {};

  if (typeof callback === 'function') {
    var req = new Request(options);
    var res = new Response(req, callback);
    return req.prepare(function () {
      return dispatchFunc.call(server, req, res);
    });
  } else {
    return new Promise(function (resolve, reject) {
      var req = new Request(options);
      var res = new Response(req, resolve, reject);
      req.prepare(function () {
        return dispatchFunc.call(server, req, res);
      });
    });
  }
}

function Chain(dispatch, option) {
  var _this = this;

  if (typeof option === 'string') {
    this.option = {
      url: option
    };
  } else {
    this.option = Object.assign({}, option);
  }

  this.dispatch = dispatch;
  this._hasInvoked = false;
  this._promise = null;

  if (this.option.autoStart !== false) {
    process.nextTick(function () {
      if (!_this._hasInvoked) {
        _this.end();
      }
    });
  }
}

var httpMethods = ['delete', 'get', 'head', 'options', 'patch', 'post', 'put', 'trace'];
httpMethods.forEach(function (method) {
  Chain.prototype[method] = function (url) {
    if (this._hasInvoked === true || this._promise) {
      throw new Error(errorMessage);
    }

    this.option.url = url;
    this.option.method = method.toUpperCase();
    return this;
  };
});
var chainMethods = ['body', 'headers', 'payload', 'query'];
chainMethods.forEach(function (method) {
  Chain.prototype[method] = function (value) {
    if (this._hasInvoked === true || this._promise) {
      throw new Error(errorMessage);
    }

    this.option[method] = value;
    return this;
  };
});

Chain.prototype.end = function (callback) {
  if (this._hasInvoked === true || this._promise) {
    throw new Error(errorMessage);
  }

  this._hasInvoked = true;

  if (typeof callback === 'function') {
    doInject(this.dispatch, this.option, callback);
  } else {
    this._promise = doInject(this.dispatch, this.option);
    return this._promise;
  }
};

Object.getOwnPropertyNames(Promise.prototype).forEach(function (method) {
  if (method === 'constructor') return;

  Chain.prototype[method] = function () {
    if (!this._promise) {
      if (this._hasInvoked === true) {
        throw new Error(errorMessage);
      }

      this._hasInvoked = true;
      this._promise = doInject(this.dispatch, this.option);
    }

    return this._promise[method](...arguments);
  };
});

function isInjection(obj) {
  return obj instanceof Request || obj instanceof Response;
}

function toLowerCase(m) {
  return m.toLowerCase();
}

module.exports = inject;
module.exports.isInjection = isInjection;