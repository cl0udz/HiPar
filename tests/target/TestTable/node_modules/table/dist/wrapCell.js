"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.splice.js");

require("core-js/modules/es.date.to-string.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/es.string.split.js");

require("core-js/modules/web.dom-collections.iterator.js");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.string.split");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _wrapString = _interopRequireDefault(require("./wrapString"));

var _wrapWord = _interopRequireDefault(require("./wrapWord"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Wrap a single cell value into a list of lines
 *
 * Always wraps on newlines, for the remainder uses either word or string wrapping
 * depending on user configuration.
 *
 * @param {string} cellValue
 * @param {number} columnWidth
 * @param {boolean} useWrapWord
 * @returns {Array}
 */


var wrapCell = function wrapCell(cellValue, columnWidth, useWrapWord) {
  // First split on literal newlines
  var cellLines = cellValue.split('\n'); // Then iterate over the list and word-wrap every remaining line if necessary.

  for (var lineNr = 0; lineNr < cellLines.length;) {
    var lineChunks = void 0;

    if (useWrapWord) {
      lineChunks = (0, _wrapWord["default"])(cellLines[lineNr], columnWidth);
    } else {
      lineChunks = (0, _wrapString["default"])(cellLines[lineNr], columnWidth);
    } // Replace our original array element with whatever the wrapping returned


    cellLines.splice.apply(cellLines, [lineNr, 1].concat(_toConsumableArray(lineChunks)));
    lineNr += lineChunks.length;
  }

  return cellLines;
};

var _default = wrapCell;
exports["default"] = _default;