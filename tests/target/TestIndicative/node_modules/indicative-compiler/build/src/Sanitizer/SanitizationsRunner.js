"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_get_1 = __importDefault(require("lodash.get"));
const isobject_1 = __importDefault(require("isobject"));
class SanitizationsRunner {
    constructor(_field, _dotPath, rules, sanitizations) {
        this._field = _field;
        this._dotPath = _dotPath;
        this._sanitizations = [];
        this._computeSanitizations(sanitizations, rules);
    }
    _computeSanitizations(sanitizations, rules) {
        this._sanitizations = rules.map((rule) => {
            const sanitization = sanitizations[rule.name];
            if (!sanitization) {
                throw new Error(`${rule.name} is not a registered as a sanitization`);
            }
            if (typeof (sanitization.sanitize) !== 'function') {
                throw new Error(`${rule.name} is missing sanitize function`);
            }
            if (typeof (sanitization.compile) === 'function') {
                rule.args = sanitization.compile(rule.args);
            }
            return { rule: rule, fn: sanitization.sanitize };
        });
    }
    _getDataCopy(data) {
        const tip = this._dotPath.length ? lodash_get_1.default(data.tip, this._dotPath) : data.tip;
        return Object.assign({}, data, {
            tip: this._field === '::tip::' ? { [this._field]: tip } : tip,
        });
    }
    exec(data, config) {
        const dataCopy = this._getDataCopy(data);
        if (!isobject_1.default(dataCopy.tip)) {
            return true;
        }
        this._sanitizations.forEach((sanitization) => {
            sanitization.fn(dataCopy, this._field, sanitization.rule.args, config);
        });
    }
}
exports.SanitizationsRunner = SanitizationsRunner;
