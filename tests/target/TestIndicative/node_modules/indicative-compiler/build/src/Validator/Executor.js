"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Collector_1 = require("./Collector");

var Executor =
/*#__PURE__*/
function () {
  function Executor(_fns) {
    _classCallCheck(this, Executor);

    this._fns = _fns;
  }

  _createClass(Executor, [{
    key: "exec",
    value: function exec(data, Formatter, config, bail, removeAdditional) {
      var root, collector, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, fn, passed, errors;

      return regeneratorRuntime.async(function exec$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              root = {
                tip: data,
                original: data,
                pointer: ''
              };
              collector = new Collector_1.Collector(new Formatter(), removeAdditional);
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 5;
              _iterator = this._fns[Symbol.iterator]();

            case 7:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context.next = 22;
                break;
              }

              fn = _step.value;
              passed = false;

              if (!fn.async) {
                _context.next = 16;
                break;
              }

              _context.next = 13;
              return regeneratorRuntime.awrap(fn.execAsync(root, collector, config, bail));

            case 13:
              passed = _context.sent;
              _context.next = 17;
              break;

            case 16:
              passed = fn.exec(root, collector, config, bail);

            case 17:
              if (!(!passed && bail)) {
                _context.next = 19;
                break;
              }

              return _context.abrupt("break", 22);

            case 19:
              _iteratorNormalCompletion = true;
              _context.next = 7;
              break;

            case 22:
              _context.next = 28;
              break;

            case 24:
              _context.prev = 24;
              _context.t0 = _context["catch"](5);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 28:
              _context.prev = 28;
              _context.prev = 29;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 31:
              _context.prev = 31;

              if (!_didIteratorError) {
                _context.next = 34;
                break;
              }

              throw _iteratorError;

            case 34:
              return _context.finish(31);

            case 35:
              return _context.finish(28);

            case 36:
              errors = collector.getErrors();

              if (errors) {
                _context.next = 39;
                break;
              }

              return _context.abrupt("return", removeAdditional ? collector.getData() : data);

            case 39:
              throw errors;

            case 40:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[5, 24, 28, 36], [29,, 31, 35]]);
    }
  }]);

  return Executor;
}();

exports.Executor = Executor;