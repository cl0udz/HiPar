"use strict";

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var lodash_get_1 = __importDefault(require("lodash.get"));

var isobject_1 = __importDefault(require("isobject"));

var ValidationsRunner =
/*#__PURE__*/
function () {
  function ValidationsRunner(_field, _type, _dotPath, rules, validations, _fieldMessages, _genericMessages) {
    _classCallCheck(this, ValidationsRunner);

    this._field = _field;
    this._type = _type;
    this._dotPath = _dotPath;
    this._fieldMessages = _fieldMessages;
    this._genericMessages = _genericMessages;
    this.async = false;
    this._validations = [];
    this._pointer = this._dotPath.concat(this._field).join('.');

    this._computeValidations(validations, rules);
  }

  _createClass(ValidationsRunner, [{
    key: "_computeValidations",
    value: function _computeValidations(validations, rules) {
      var _this = this;

      this._validations = rules.map(function (rule) {
        var validation = validations[rule.name];

        if (!validation) {
          throw new Error("".concat(rule.name, " is not a registered as a validation"));
        }

        if (typeof validation.validate !== 'function') {
          throw new Error("".concat(rule.name, " is missing validate function"));
        }

        if (typeof validation.compile === 'function') {
          rule.args = validation.compile(rule.args);
        }

        if (validation.async) {
          _this.async = true;
        }

        return {
          rule: rule,
          fn: validation.validate,
          async: validation.async
        };
      });
    }
  }, {
    key: "_getDataCopy",
    value: function _getDataCopy(data) {
      var tip = this._dotPath.length ? lodash_get_1["default"](data.tip, this._dotPath) : data.tip;
      var pointer = data.arrayPointer ? this._pointer === '::tip::' ? "".concat(data.arrayPointer, ".").concat(data.currentIndex) : "".concat(data.arrayPointer, ".").concat(data.currentIndex, ".").concat(this._pointer) : this._pointer;
      return Object.assign({}, data, {
        tip: this._field === '::tip::' ? _defineProperty({}, this._field, tip) : tip,
        pointer: pointer
      });
    }
  }, {
    key: "_reportValueToCollector",
    value: function _reportValueToCollector(passed, data, collector) {
      if (!passed || this._type !== 'literal') {
        return;
      }

      collector.setValue(data.pointer, data.tip[this._field]);
    }
  }, {
    key: "_reportErrorToCollector",
    value: function _reportErrorToCollector(pointer, rule, collector, exception) {
      var message = exception || this._fieldMessages[rule.name] || this._genericMessages[rule.name];
      collector.setError(pointer, rule, message);
    }
  }, {
    key: "exec",
    value: function exec(data, collector, config) {
      var bail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var dataCopy = this._getDataCopy(data);

      if (!isobject_1["default"](dataCopy.tip)) {
        return true;
      }

      var hasFailures = false;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._validations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var validation = _step.value;
          var exception = null;
          var passed = true;

          try {
            passed = validation.fn(dataCopy, this._field, validation.rule.args, config);
          } catch (error) {
            exception = error;
            passed = false;
          }

          if (!passed) {
            hasFailures = true;

            this._reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);

            if (bail) {
              break;
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._reportValueToCollector(!hasFailures, dataCopy, collector);

      return !hasFailures;
    }
  }, {
    key: "execAsync",
    value: function execAsync(data, collector, config) {
      var bail,
          dataCopy,
          hasFailures,
          _iteratorNormalCompletion2,
          _didIteratorError2,
          _iteratorError2,
          _iterator2,
          _step2,
          validation,
          exception,
          passed,
          _args = arguments;

      return regeneratorRuntime.async(function execAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              bail = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;
              dataCopy = this._getDataCopy(data);

              if (isobject_1["default"](dataCopy.tip)) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", true);

            case 4:
              hasFailures = false;
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 8;
              _iterator2 = this._validations[Symbol.iterator]();

            case 10:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 36;
                break;
              }

              validation = _step2.value;
              exception = null;
              passed = true;
              _context.prev = 14;

              if (!validation.async) {
                _context.next = 21;
                break;
              }

              _context.next = 18;
              return regeneratorRuntime.awrap(validation.fn(dataCopy, this._field, validation.rule.args, config));

            case 18:
              passed = _context.sent;
              _context.next = 22;
              break;

            case 21:
              passed = validation.fn(dataCopy, this._field, validation.rule.args, config);

            case 22:
              _context.next = 28;
              break;

            case 24:
              _context.prev = 24;
              _context.t0 = _context["catch"](14);
              passed = false;
              exception = _context.t0;

            case 28:
              if (passed) {
                _context.next = 33;
                break;
              }

              hasFailures = true;

              this._reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);

              if (!bail) {
                _context.next = 33;
                break;
              }

              return _context.abrupt("break", 36);

            case 33:
              _iteratorNormalCompletion2 = true;
              _context.next = 10;
              break;

            case 36:
              _context.next = 42;
              break;

            case 38:
              _context.prev = 38;
              _context.t1 = _context["catch"](8);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t1;

            case 42:
              _context.prev = 42;
              _context.prev = 43;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 45:
              _context.prev = 45;

              if (!_didIteratorError2) {
                _context.next = 48;
                break;
              }

              throw _iteratorError2;

            case 48:
              return _context.finish(45);

            case 49:
              return _context.finish(42);

            case 50:
              this._reportValueToCollector(!hasFailures, dataCopy, collector);

              return _context.abrupt("return", !hasFailures);

            case 52:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[8, 38, 42, 50], [14, 24], [43,, 45, 49]]);
    }
  }]);

  return ValidationsRunner;
}();

exports.ValidationsRunner = ValidationsRunner;