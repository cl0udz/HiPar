"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const haye_pipe_1 = __importDefault(require("haye/dist/haye-pipe"));
const haye_array_presenter_1 = __importDefault(require("haye/dist/haye-array-presenter"));
function toCamelCase(ruleName) {
    return ruleName.replace(/_(\w)/g, (_match, group) => group.toUpperCase());
}
function setLiteral(source, key, rules) {
    const item = (source[key] || { type: 'literal' });
    item.rules = rules;
    source[key] = item;
    return item;
}
function setObject(source, key) {
    if (source[key] && source[key].type === 'array') {
        throw new Error(`cannot reshape ${key} array to an object`);
    }
    const item = (source[key] || { rules: [] });
    item.type = 'object';
    item.children = item.children || {};
    source[key] = item;
    return item;
}
function setArray(source, key, index) {
    if (source[key] && source[key].type === 'object') {
        throw new Error(`cannot reshape ${key} object to an array`);
    }
    const item = (source[key] || { rules: [] });
    item.each = item.each || {};
    item.each[index] = item.each[index] || { children: {}, rules: [] };
    item.type = 'array';
    source[key] = item;
    return item;
}
function parseFieldForRules(tokens, rules, out, index = 0) {
    const token = tokens[index++];
    const isLast = tokens.length === index;
    const isIndexedArray = /^\d+$/.test(tokens[index]);
    const isArray = tokens[index] === '*' || isIndexedArray;
    if (token === '*' || /^\d+$/.test(token)) {
        if (isLast) {
            out.each[token].rules = rules;
            return;
        }
        return parseFieldForRules(tokens, rules, out.each[token].children, index);
    }
    if (isLast) {
        setLiteral(out, token, rules);
        return;
    }
    if (isArray) {
        const item = setArray(out, token, isIndexedArray ? tokens[index] : '*');
        return parseFieldForRules(tokens, rules, item, index);
    }
    const item = setObject(out, token);
    return parseFieldForRules(tokens, rules, item.children, index);
}
function rulesParser(schema) {
    return Object
        .keys(schema)
        .reduce((result, field) => {
        const rules = schema[field];
        let parsedRules = [];
        if (!rules) {
            throw new Error(`make sure to define rules for ${field}`);
        }
        if (typeof (rules) === 'string') {
            parsedRules = new haye_pipe_1.default(rules, new haye_array_presenter_1.default()).map((rule) => {
                return { name: toCamelCase(rule.name), args: rule.args };
            });
        }
        else {
            parsedRules = rules;
        }
        parseFieldForRules(field.split('.'), parsedRules, result);
        return result;
    }, {});
}
exports.rulesParser = rulesParser;
function messagesParser(schema) {
    return Object
        .keys(schema)
        .reduce((result, field) => {
        const message = schema[field];
        const tokens = field.split('.');
        const rule = toCamelCase(tokens.pop());
        if (!tokens.length) {
            result.rules[rule] = message;
            return result;
        }
        const qualifiedName = tokens.join('.');
        result.fields[qualifiedName] = result.fields[qualifiedName] || {};
        result.fields[qualifiedName][rule] = message;
        return result;
    }, { fields: {}, rules: {} });
}
exports.messagesParser = messagesParser;
