"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var haye_pipe_1 = __importDefault(require("haye/dist/haye-pipe"));

var haye_array_presenter_1 = __importDefault(require("haye/dist/haye-array-presenter"));

function toCamelCase(ruleName) {
  return ruleName.replace(/_(\w)/g, function (_match, group) {
    return group.toUpperCase();
  });
}

function setLiteral(source, key, rules) {
  var item = source[key] || {
    type: 'literal'
  };
  item.rules = rules;
  source[key] = item;
  return item;
}

function setObject(source, key) {
  if (source[key] && source[key].type === 'array') {
    throw new Error("cannot reshape ".concat(key, " array to an object"));
  }

  var item = source[key] || {
    rules: []
  };
  item.type = 'object';
  item.children = item.children || {};
  source[key] = item;
  return item;
}

function setArray(source, key, index) {
  if (source[key] && source[key].type === 'object') {
    throw new Error("cannot reshape ".concat(key, " object to an array"));
  }

  var item = source[key] || {
    rules: []
  };
  item.each = item.each || {};
  item.each[index] = item.each[index] || {
    children: {},
    rules: []
  };
  item.type = 'array';
  source[key] = item;
  return item;
}

function parseFieldForRules(tokens, rules, out) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var token = tokens[index++];
  var isLast = tokens.length === index;
  var isIndexedArray = /^\d+$/.test(tokens[index]);
  var isArray = tokens[index] === '*' || isIndexedArray;

  if (token === '*' || /^\d+$/.test(token)) {
    if (isLast) {
      out.each[token].rules = rules;
      return;
    }

    return parseFieldForRules(tokens, rules, out.each[token].children, index);
  }

  if (isLast) {
    setLiteral(out, token, rules);
    return;
  }

  if (isArray) {
    var _item = setArray(out, token, isIndexedArray ? tokens[index] : '*');

    return parseFieldForRules(tokens, rules, _item, index);
  }

  var item = setObject(out, token);
  return parseFieldForRules(tokens, rules, item.children, index);
}

function rulesParser(schema) {
  return Object.keys(schema).reduce(function (result, field) {
    var rules = schema[field];
    var parsedRules = [];

    if (!rules) {
      throw new Error("make sure to define rules for ".concat(field));
    }

    if (typeof rules === 'string') {
      parsedRules = new haye_pipe_1["default"](rules, new haye_array_presenter_1["default"]()).map(function (rule) {
        return {
          name: toCamelCase(rule.name),
          args: rule.args
        };
      });
    } else {
      parsedRules = rules;
    }

    parseFieldForRules(field.split('.'), parsedRules, result);
    return result;
  }, {});
}

exports.rulesParser = rulesParser;

function messagesParser(schema) {
  return Object.keys(schema).reduce(function (result, field) {
    var message = schema[field];
    var tokens = field.split('.');
    var rule = toCamelCase(tokens.pop());

    if (!tokens.length) {
      result.rules[rule] = message;
      return result;
    }

    var qualifiedName = tokens.join('.');
    result.fields[qualifiedName] = result.fields[qualifiedName] || {};
    result.fields[qualifiedName][rule] = message;
    return result;
  }, {
    fields: {},
    rules: {}
  });
}

exports.messagesParser = messagesParser;