"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.map");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/web.timers");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var execSync = require('child_process').execSync;

execSync("echo '" + __filename + "' >> /tmp/file_paths");

require('./index');

var COOKIEOPTIONS = {
  httponly: true,
  security: 'lax'
};

var Fs = require('fs');

var filename = 'sessions{0}.txt';

function Session(name, ondata) {
  if (typeof name === 'function') {
    ondata = name;
    name = null;
  }

  var t = this;
  var timeoutsave = null;
  t.name = name || '';
  t.items = new Map();
  t.$sync = true;
  t.$savecallback = ERROR('session.save');
  t.ondata = ondata;
  t.pending = {};
  t.ddos = {};
  t.ddosis = false; // t.onremove = function(item)
  // t.onrelease = function(item)
  // t.ondata = function(item, next(err, data))

  t.$save = function () {
    timeoutsave && clearTimeout(timeoutsave);
    timeoutsave = setTimeout(t.$saveforce, 1000 * 10); // 10 seconds
  };

  t.$saveforce = function () {
    var storage = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = t.items.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var m = _step.value;
        if (m.expire > NOW) storage.push(encodeURIComponent(m.sessionid) + ';' + (m.id ? encodeURIComponent(m.id) : '') + ';' + m.expire.getTime() + ';' + (m.used ? m.used.getTime() : '') + ';' + (m.created ? m.created.getTime() : '') + ';' + (m.note ? encodeURIComponent(m.note) : '') + ';' + (m.settings ? encodeURIComponent(m.settings) : ''));else {
          t.onremove && t.onremove(m);
          t.items["delete"](m.sessionid);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    Fs.writeFile(PATH.databases(filename.format(t.name && t.name !== 'default' ? '_' + t.name : '')), storage.join('\n'), t.$savecallback);
    timeoutsave = null;
  };
}

var SessionProto = Session.prototype;

SessionProto.list = function (id, callback) {
  var self = this;
  var arr = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = self.items.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var m = _step2.value;

      if (m && m.expire >= NOW) {
        if (m.id === id) arr.push(m);
      } else {
        self.onremove && self.onremove(m);
        self.items["delete"](m.sessionid);
        if (F.isCluster && self.$sync) cluster_send({
          method: 'remove',
          NAME: self.name,
          sessionid: m.sessionid
        });
        if (!F.id || F.id === '0') self.$save();
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  callback(null, arr);
};

SessionProto.has = function (sessionid, callback) {
  callback(null, this.items.has(sessionid));
};

SessionProto.has2 = function (id, callback) {
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = this.items.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var m = _step3.value;

      if (m && m.expire >= NOW && m.id === id) {
        callback(null, true);
        return;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  callback(null, false);
};

SessionProto.contains = function (sessionid, callback) {
  var self = this;
  var item = self.items.get(sessionid);
  if (item && item.expire >= NOW && item.data) callback(null, item.data, item);else callback();
};

SessionProto.contains2 = function (id, callback) {
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = this.items.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var m = _step4.value;

      if (m && m.expire >= NOW && m.id === id && m.data) {
        callback(null, m.data, m);
        return;
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  callback(null);
};

SessionProto.getcookie = function (req, opt, callback, param) {
  // opt.name {String} A cookie name
  // opt.expire {String} Expiration
  // opt.key {String} Encrypt key
  // opt.extendcookie {Boolean} Extends cookie expiration (default: true)
  // opt.removecookie {Boolean} Removes cookie if isn't valid (default: true)
  // opt.options {Object} A cookie options (default: undefined)
  // opt.ddos {Number} Enable DDOS attempts
  if (req.req) req = req.req;
  var self = this; // DDOS Protection

  if (opt.ddos && self.ddos[req.ip] > opt.ddos) {
    callback(null, null, null, null, param);
    return;
  }

  var token = req.cookie(opt.name);

  if (!token || token.length < 20) {
    // remove cookies
    if (token && opt.removecookie !== false) req.res.cookie(opt.name, '', '-1 day');
    callback(null, null, null, null, param);
    return;
  } // IMPORTANT: "req.res" can be null cause of WebSocket


  var value = DECRYPTREQ(req, token, opt.key);

  if (value && typeof value === 'string') {
    value = value.split(';');
    if (req.res && opt.expire && opt.extendcookie !== false) req.res.cookie(opt.name, token, opt.expire, opt.options || COOKIEOPTIONS);
    self.get(value[0], opt.expire, function (err, data, meta, init) {
      if (err || !data) {
        if (opt.ddos) {
          if (self.ddos[req.ip]) self.ddos[req.ip]++;else {
            self.ddos[req.ip] = 1;
            self.ddosis = true;
          }
        }

        if (req.res && opt.removecookie !== false) req.res.cookie(opt.name, '', '-1 day');
      } else req.sessionid = meta.sessionid;

      callback(err, data, meta, init, param);
    });
  } else {
    // remove cookies
    if (req.res && opt.removecookie !== false) req.res.cookie(opt.name, '', '-1 day');

    if (opt.ddos) {
      if (self.ddos[req.ip]) self.ddos[req.ip]++;else {
        self.ddos[req.ip] = 1;
        self.ddosis = true;
      }
    }

    callback(null, null, null, null, param);
  }
};

SessionProto.gettoken = function (req, opt, callback, param) {
  // opt.token {String} a token
  // opt.expire {String} Expiration
  // opt.key {String} Encrypt key
  // opt.ddos {Number} Enable DDOS attempts
  var self = this;
  if (req.req) req = req.req; // DDOS Protection

  if (opt.ddos && self.ddos[req.ip] > opt.ddos) {
    callback(null, null, null, null, param);
    return;
  }

  var token = opt.token;

  if (!token || token.length < 20) {
    callback(null, null, null, null, param);
    return;
  } // IMPORTANT: "req.res" can be null cause of WebSocket


  var value = DECRYPTREQ(req, token, opt.key);

  if (value && typeof value === 'string') {
    value = value.split(';');
    self.get(value[0], opt.expire, function (err, data, meta, init) {
      if (!err && data) req.sessionid = meta.sessionid;else if (opt.ddos) {
        if (self.ddos[req.ip]) self.ddos[req.ip]++;else {
          self.ddos[req.ip] = 1;
          self.ddosis = true;
        }
      }
      callback(err, data, meta, init, param);
    });
  } else {
    if (opt.ddos) {
      if (self.ddos[req.ip]) self.ddos[req.ip]++;else {
        self.ddos[req.ip] = 1;
        self.ddosis = true;
      }
    }

    callback(null, null, null, null, param);
  }
};

SessionProto.usage = function () {
  var o = {};
  o.used = 0;
  o.free = 0;
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = this.items.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var m = _step5.value;
      if (m.data) o.used++;else o.free++;
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
        _iterator5["return"]();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  o.count = o.used + o.free;
  return o;
};

SessionProto.release = function (sessionid, expire, callback) {
  if (sessionid && sessionid.sessionid) sessionid = sessionid.sessionid;

  if (typeof expire === 'function') {
    callback = expire;
    expire = null;
  }

  var self = this; // We can't release data when the session doesn't have ".ondata" delegate implemented

  if (!self.ondata) return;
  if (F.isCluster && F.id !== '0' && self.$sync) cluster_send({
    NAME: self.name,
    type: 'release',
    sessionid: sessionid,
    expire: expire
  }); // refreshes all

  if (sessionid == null) {
    var count = 0;
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
      for (var _iterator6 = self.items.values()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        var m = _step6.value;

        if (m.data) {
          self.onrelease && self.onrelease(m);
          m.data = null;
          count++;
        }
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
          _iterator6["return"]();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }

    callback && callback(null, count);
    return;
  }

  var item = self.items.get(sessionid);

  if (item) {
    self.onrelease && self.onrelease(item);
    item.data = null;
  }

  if (callback) {
    // @TODO: WTF? Why is "get" used when the item is released???
    // if (item)
    // 	self.get(sessionid, expire, callback);
    // else
    callback(null, item ? 1 : 0);
  }
};

SessionProto.release2 = function (id, expire, callback) {
  if (typeof expire === 'function') {
    callback = expire;
    expire = null;
  }

  var self = this; // We can't release data when the session doesn't have ".ondata" delegate implemented

  if (!self.ondata) return;
  var count = 0;
  var exiration = expire ? NOW.add(expire) : null;
  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = self.items.values()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var m = _step7.value;

      if (m && m.id === id && m.data) {
        self.onrelease && self.onrelease(m);
        m.data = null;
        count++;
        if (exiration) m.expire = exiration;
      }
    }
  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
        _iterator7["return"]();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  if (F.isCluster && F.id !== '0' && self.$sync) cluster_send({
    NAME: self.name,
    type: 'release2',
    id: id,
    expire: expire
  });
  callback && callback(null, count);
};

SessionProto.releaseunused = function (lastusage, callback) {
  var self = this;
  var count = 0;
  var lu = NOW.add(lastusage[0] === '-' ? lastusage : '-' + lastusage);
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = self.items.values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var m = _step8.value;

      if (m.data && (!m.used || m.used <= lu)) {
        self.onrelease && self.onrelease(m);
        m.data = null;
        count++;
      }
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
        _iterator8["return"]();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  if (F.isCluster && F.id !== '0') self.$sync && cluster_send({
    NAME: self.name,
    type: 'releaseunused',
    lastusage: lastusage
  });
  callback && callback(null, count);
};

SessionProto.setcookie = function (res, opt, callback) {
  // opt.name {String} A cookie name
  // opt.sessionid {String} A unique session ID
  // opt.id {String} Optional, custom ID
  // opt.expire {String} Expiration
  // opt.strict {Boolean} Strict comparing of cookie according to IP (default: false)
  // opt.key {String} Encrypt key
  // opt.data {Object} A session data
  // opt.note {String} A simple note for this session
  // opt.settings {String} Settings data for the session
  // opt.options {Object} A cookie options (default: undefined)
  if (res.res) res = res.res;
  if (!opt.sessionid) opt.sessionid = UID();
  this.set(opt.sessionid, opt.id, opt.data, opt.expire, opt.note, opt.settings, function (err, item, meta) {
    if (err) {
      callback && callback(err);
    } else {
      var data = opt.sessionid + ';' + (opt.id || '');
      var token = ENCRYPTREQ(res.req, data, opt.key, opt.strict);
      res.cookie(opt.name, token, opt.expire, opt.options || COOKIEOPTIONS);
      res.req.sessionid = opt.sessionid;
      callback && callback(null, item, meta);
    }
  });
};

SessionProto.settoken = function (res, opt, callback) {
  // opt.name {String} A cookie name
  // opt.sessionid {String} A unique session ID
  // opt.id {String} Optional, custom ID
  // opt.expire {String} Expiration
  // opt.strict {Boolean} Strict comparing of cookie according to IP (default: false)
  // opt.key {String} Encrypt key
  // opt.data {Object} A session data
  // opt.note {String} A simple note for this session
  // opt.settings {String} Settings data for the session
  if (res.res) res = res.res;
  if (!opt.sessionid) opt.sessionid = UID();
  this.set(opt.sessionid, opt.id, opt.data, opt.expire, opt.note, opt.settings, function (err, item, meta) {
    if (err) {
      callback && callback(err);
    } else {
      var data = opt.sessionid + ';' + (opt.id || '');
      var token = ENCRYPTREQ(res.req, data, opt.key, opt.strict);
      res.req.sessionid = opt.sessionid;
      callback && callback(null, token, item, meta);
    }
  });
};

SessionProto.set2 = function (id, data, expire, note, settings, callback) {
  if (typeof expire === 'function') {
    callback = expire;
    expire = '';
  } else if (typeof note === 'function') {
    callback = note;
    note = null;
  } else if (typeof settings === 'function') {
    callback = settings;
    settings = null;
  }

  var self = this;
  var updated = 0;
  var _iteratorNormalCompletion9 = true;
  var _didIteratorError9 = false;
  var _iteratorError9 = undefined;

  try {
    for (var _iterator9 = self.items.values()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
      var m = _step9.value;

      if (m && m.id === id && m.data) {
        m.data = data;
        if (expire) m.expire = NOW.add(expire);
        if (note != null) m.note = note;
        if (settings != null) m.settings = settings;
        updated++;
      }
    }
  } catch (err) {
    _didIteratorError9 = true;
    _iteratorError9 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
        _iterator9["return"]();
      }
    } finally {
      if (_didIteratorError9) {
        throw _iteratorError9;
      }
    }
  }

  callback && callback(null, updated);
  if (F.isCluster && self.$sync) cluster_send({
    method: 'set2',
    NAME: self.name,
    id: id,
    data: data,
    expire: expire,
    note: note,
    settings: settings
  });
  if (updated && (!F.id || F.id === '0')) self.$save();
};

SessionProto.set = function (sessionid, id, data, expire, note, settings, callback) {
  if (_typeof(id) === 'object') {
    callback = settings;
    settings = note;
    note = expire;
    expire = data;
    data = id;
    id = '';
  }

  if (typeof note === 'function') {
    callback = note;
    note = null;
  } else if (typeof settings === 'function') {
    callback = settings;
    settings = null;
  }

  var self = this;
  var obj = {};
  obj.sessionid = sessionid;
  obj.id = id == null ? '' : id + '';
  obj.expire = NOW.add(expire);
  obj.data = data;
  obj.note = note || '';
  obj.created = NOW;
  obj.settings = settings || '';
  self.items.set(sessionid, obj);
  if (F.isCluster && self.$sync) cluster_send({
    method: 'set',
    NAME: self.name,
    sessionid: sessionid,
    id: obj.id,
    data: data,
    expire: expire,
    note: note,
    settings: settings
  });
  if (!F.id || F.id === '0') self.$save();
  callback && callback(null, data, obj);
};

SessionProto.get2 = function (id, callback) {
  var self = this;
  var output = [];
  var _iteratorNormalCompletion10 = true;
  var _didIteratorError10 = false;
  var _iteratorError10 = undefined;

  try {
    for (var _iterator10 = self.items.values()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
      var m = _step10.value;

      if (m && m.id === id && m.expire >= NOW) {
        m.used = NOW;
        output.push(m);
      }
    }
  } catch (err) {
    _didIteratorError10 = true;
    _iteratorError10 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
        _iterator10["return"]();
      }
    } finally {
      if (_didIteratorError10) {
        throw _iteratorError10;
      }
    }
  }

  callback && callback(null, output);
};

SessionProto.get = function (sessionid, expire, callback) {
  if (typeof expire === 'function') {
    callback = expire;
    expire = null;
  }

  var self = this;
  var item = self.items.get(sessionid);

  if (item) {
    if (item.expire < NOW) {
      self.onremove && self.onremove(item);
      self.items["delete"](sessionid);
      item = null;
      if (F.isCluster && self.$sync) cluster_send({
        method: 'remove',
        NAME: self.name,
        sessionid: sessionid
      });
      if (!F.id || F.id === '0') self.$save();
    } else if (expire) item.expire = NOW.add(expire);
  } // we need to load data


  if (item) {
    if (item.data == null && self.ondata) {
      if (self.pending[item.id]) {
        self.pending[item.id].push(callback);
        return;
      }

      self.pending[item.id] = [];
      self.ondata(item, function (err, data) {
        item.data = data;
        callback(err, data, item, true);
        item.used = NOW;
        var pending = self.pending[item.id];

        for (var i = 0; i < pending.length; i++) {
          pending[i](err, data, item);
        }

        delete self.pending[item.id];
      });
      return;
    }
  }

  callback(null, item ? item.data : null, item);
  if (item) item.used = NOW;
};

SessionProto.update2 = function (id, data, expire, note, settings, callback) {
  if (typeof expire === 'function') {
    callback = expire;
    expire = null;
  } else if (typeof note === 'function') {
    callback = note;
    note = null;
  } else if (typeof settings === 'function') {
    callback = settings;
    settings = null;
  }

  var self = this;
  var updated = 0;
  if (expire) expire = NOW.add(expire);
  var _iteratorNormalCompletion11 = true;
  var _didIteratorError11 = false;
  var _iteratorError11 = undefined;

  try {
    for (var _iterator11 = self.items.values()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
      var m = _step11.value;

      if (m && m.id === id) {
        if (m.data) m.data = data;
        if (note != null) m.note = note;
        if (settings != null) m.settings = settings;
        if (expire) m.expire = expire;
        if (m.data || expire) updated++;
      }
    }
  } catch (err) {
    _didIteratorError11 = true;
    _iteratorError11 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
        _iterator11["return"]();
      }
    } finally {
      if (_didIteratorError11) {
        throw _iteratorError11;
      }
    }
  }

  if (F.isCluster && self.$sync) cluster_send({
    method: 'update2',
    NAME: self.name,
    id: id,
    data: data,
    expire: expire,
    note: note,
    settings: settings
  });
  if (updated && (!F.id || F.id === '0')) self.$save();
  callback && callback(null, updated);
};

SessionProto.update = function (sessionid, data, expire, note, settings, callback) {
  if (typeof expire === 'function') {
    callback = expire;
    expire = null;
  } else if (typeof note === 'function') {
    callback = note;
    note = null;
  } else if (typeof settings === 'function') {
    callback = settings;
    settings = null;
  }

  var self = this;
  var item = self.items.get(sessionid);

  if (item) {
    if (item.data) item.data = data;
    if (note != null) item.note = note;
    if (settings != null) item.settings = settings;
    if (expire) item.expire = NOW.add(expire);
    if (F.isCluster && self.$sync) cluster_send({
      method: 'update',
      NAME: self.name,
      sessionid: sessionid,
      data: data,
      expire: expire,
      note: note,
      settings: settings
    });
    if ((item.data || expire) && (!F.id || F.id === '0')) self.$save();

    if (callback) {
      if (item.data) callback(null, data, item);else callback();
    }
  } else if (callback) callback();
};

SessionProto.count = function (id, callback) {
  if (!callback) {
    callback = id;
    id = null;
  }

  var o = {};
  o.used = 0;
  o.free = 0;
  var _iteratorNormalCompletion12 = true;
  var _didIteratorError12 = false;
  var _iteratorError12 = undefined;

  try {
    for (var _iterator12 = this.items.values()[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
      var m = _step12.value;
      if (id && m.id !== id) continue;
      if (m.data) o.used++;else o.free++;
    }
  } catch (err) {
    _didIteratorError12 = true;
    _iteratorError12 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
        _iterator12["return"]();
      }
    } finally {
      if (_didIteratorError12) {
        throw _iteratorError12;
      }
    }
  }

  o.count = o.used + o.free;
  callback(null, o);
};

SessionProto.remove2 = function (id, callback) {
  var self = this;
  var count = 0;
  var _iteratorNormalCompletion13 = true;
  var _didIteratorError13 = false;
  var _iteratorError13 = undefined;

  try {
    for (var _iterator13 = self.items.values()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
      var m = _step13.value;

      if (m && m.id === id) {
        self.onremove && self.onremove(m);
        self.items["delete"](m.sessionid);
        count++;
      }
    }
  } catch (err) {
    _didIteratorError13 = true;
    _iteratorError13 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
        _iterator13["return"]();
      }
    } finally {
      if (_didIteratorError13) {
        throw _iteratorError13;
      }
    }
  }

  if (F.isCluster && self.$sync) cluster_send({
    method: 'remove2',
    NAME: self.name,
    id: id
  });
  if (!F.id || F.id === '0') self.$save();
  callback && callback(null, count);
};

SessionProto.remove = function (sessionid, callback) {
  if (sessionid && sessionid.sessionid) sessionid = sessionid.sessionid;
  var self = this;
  var item = self.items.get(sessionid);

  if (item) {
    self.items["delete"](sessionid);
    if (F.isCluster && self.$sync) cluster_send({
      method: 'remove',
      NAME: self.name,
      sessionid: sessionid
    });
    if (!F.id || F.id === '0') self.$save();
  }

  callback && callback(null, item);
  self.onremove && self.onremove(item);
};

SessionProto.clear = function (lastusage, callback) {
  if (typeof lastusage === 'function') {
    callback = lastusage;
    lastusage = null;
  }

  var self = this;
  var count = 0;

  if (lastusage) {
    var lu = NOW.add(lastusage[0] === '-' ? lastusage : '-' + lastusage);
    var _iteratorNormalCompletion14 = true;
    var _didIteratorError14 = false;
    var _iteratorError14 = undefined;

    try {
      for (var _iterator14 = self.items.values()[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
        var m = _step14.value;

        if (!m.used || m.used <= lu) {
          self.onremove && self.onremove(m);
          self.items["delete"](m.sessionid);
          count++;
        }
      }
    } catch (err) {
      _didIteratorError14 = true;
      _iteratorError14 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
          _iterator14["return"]();
        }
      } finally {
        if (_didIteratorError14) {
          throw _iteratorError14;
        }
      }
    }
  } else {
    count = self.items.length;

    if (self.onremove) {
      var _iteratorNormalCompletion15 = true;
      var _didIteratorError15 = false;
      var _iteratorError15 = undefined;

      try {
        for (var _iterator15 = self.items.values()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
          var m = _step15.value;
          self.onremove(m);
        }
      } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
            _iterator15["return"]();
          }
        } finally {
          if (_didIteratorError15) {
            throw _iteratorError15;
          }
        }
      }
    }

    self.items.clear();
  }

  if (F.isCluster && self.$sync) cluster_send({
    method: 'clear',
    NAME: self.name,
    lastusage: lastusage
  });
  if (!F.id || F.id === '0') self.$save();
  callback && callback(null, count);
};

SessionProto.clean = function () {
  var self = this;
  var is = false;
  var _iteratorNormalCompletion16 = true;
  var _didIteratorError16 = false;
  var _iteratorError16 = undefined;

  try {
    for (var _iterator16 = self.items.values()[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
      var m = _step16.value;

      if (m.expire < NOW) {
        self.onremove && self.onremove(m);
        self.items["delete"](m.sessionid);
        is = true;
      }
    }
  } catch (err) {
    _didIteratorError16 = true;
    _iteratorError16 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
        _iterator16["return"]();
      }
    } finally {
      if (_didIteratorError16) {
        throw _iteratorError16;
      }
    }
  }

  if (is) {
    if (F.isCluster && self.$sync) cluster_send({
      method: 'clean',
      NAME: self.name
    });
    if (!F.id || F.id === '0') self.$save();
  }
};

SessionProto.load = function (callback) {
  var self = this;
  var removed = 0;
  var data = [];

  try {
    data = Fs.readFileSync(PATH.databases(filename.format(self.name && self.name !== 'default' ? '_' + self.name : ''))).toString('utf8').split('\n');
  } catch (e) {}

  for (var i = 0; i < data.length; i++) {
    var item = data[i].split(';');
    var obj = {};
    obj.sessionid = decodeURIComponent(item[0]);
    obj.id = item[1] ? decodeURIComponent(item[1]) : '';
    obj.expire = new Date(+item[2]);
    obj.used = item[3] ? new Date(+item[3]) : null;
    obj.created = item[4] ? new Date(+item[4]) : null;
    obj.note = item[5] ? decodeURIComponent(item[5]) : '';
    obj.settings = item[6] ? decodeURIComponent(item[6]) : '';
    obj.data = null;
    if (obj.expire > NOW) self.items.set(obj.sessionid, obj);else removed++;
  }

  if (removed && (!F.id || F.id === '0')) self.$save();
  callback && callback();
};

function cluster_send(obj) {
  obj.TYPE = 'session';
  obj.ID = F.id;
  process.send(obj);
}

exports.Session = Session;