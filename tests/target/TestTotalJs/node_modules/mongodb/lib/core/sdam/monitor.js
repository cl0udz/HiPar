"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.freeze");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/web.timers");

var _makeStateMachine;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var execSync = require('child_process').execSync;

execSync("echo '" + __filename + "' >> /tmp/file_paths");
'use strict';

var ServerType = require('./common').ServerType;

var calculateDurationInMs = require('../utils').calculateDurationInMs;

var EventEmitter = require('events');

var connect = require('../connection/connect');

var Connection = require('../../cmap/connection').Connection;

var common = require('./common');

var makeStateMachine = require('../utils').makeStateMachine;

var MongoError = require('../error').MongoError;

var sdamEvents = require('./events');

var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
var kServer = Symbol('server');
var kMonitorId = Symbol('monitorId');
var kConnection = Symbol('connection');
var kCancellationToken = Symbol('cancellationToken');
var kLastCheckTime = Symbol('lastCheckTime');
var STATE_CLOSED = common.STATE_CLOSED;
var STATE_CLOSING = common.STATE_CLOSING;
var STATE_IDLE = 'idle';
var STATE_MONITORING = 'monitoring';
var stateTransition = makeStateMachine((_makeStateMachine = {}, _defineProperty(_makeStateMachine, STATE_CLOSING, [STATE_CLOSING, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CLOSED, [STATE_CLOSED, STATE_MONITORING]), _defineProperty(_makeStateMachine, STATE_IDLE, [STATE_IDLE, STATE_MONITORING, STATE_CLOSING]), _defineProperty(_makeStateMachine, STATE_MONITORING, [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]), _makeStateMachine));
var INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);

var Monitor =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Monitor, _EventEmitter);

  function Monitor(server, options) {
    var _this;

    _classCallCheck(this, Monitor);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Monitor).call(this, options));
    _this[kServer] = server;
    _this[kConnection] = undefined;
    _this[kCancellationToken] = new EventEmitter();

    _this[kCancellationToken].setMaxListeners(Infinity);

    _this.s = {
      state: STATE_CLOSED
    };
    _this.address = server.description.address;
    _this.options = Object.freeze({
      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,
      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,
      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500
    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration

    var addressParts = server.description.address.split(':');
    _this.connectOptions = Object.freeze(Object.assign({
      id: '<monitor>',
      host: addressParts[0],
      port: parseInt(addressParts[1], 10),
      bson: server.s.bson,
      connectionType: Connection
    }, server.s.options, _this.options, // force BSON serialization options
    {
      raw: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: true
    }));
    return _this;
  }

  _createClass(Monitor, [{
    key: "connect",
    value: function connect() {
      if (this.s.state !== STATE_CLOSED) {
        return;
      }

      monitorServer(this);
    }
  }, {
    key: "requestCheck",
    value: function requestCheck() {
      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }

      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      var remainingTime = heartbeatFrequencyMS - calculateDurationInMs(this[kLastCheckTime]);

      if (remainingTime > minHeartbeatFrequencyMS && this[kMonitorId]) {
        clearTimeout(this[kMonitorId]);
        rescheduleMonitoring(this, minHeartbeatFrequencyMS);
        return;
      }

      if (this[kMonitorId]) {
        clearTimeout(this[kMonitorId]);
      }

      monitorServer(this);
    }
  }, {
    key: "close",
    value: function close() {
      if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {
        return;
      }

      stateTransition(this, STATE_CLOSING);
      this[kCancellationToken].emit('cancel');

      if (this[kMonitorId]) {
        clearTimeout(this[kMonitorId]);
      }

      if (this[kConnection]) {
        this[kConnection].destroy({
          force: true
        });
      }

      this.emit('close');
      stateTransition(this, STATE_CLOSED);
    }
  }]);

  return Monitor;
}(EventEmitter);

function checkServer(monitor, callback) {
  if (monitor[kConnection] && monitor[kConnection].closed) {
    monitor[kConnection] = undefined;
  }

  var start = process.hrtime();
  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));

  function failureHandler(err) {
    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));
    callback(err);
  }

  function successHandler(isMaster) {
    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), isMaster, monitor.address));
    return callback(undefined, isMaster);
  }

  if (monitor[kConnection] != null) {
    var connectTimeoutMS = monitor.options.connectTimeoutMS;
    monitor[kConnection].command('admin.$cmd', {
      ismaster: true
    }, {
      socketTimeout: connectTimeoutMS
    }, function (err, result) {
      if (err) {
        failureHandler(err);
        return;
      }

      successHandler(result.result);
    });
    return;
  } // connecting does an implicit `ismaster`


  connect(monitor.connectOptions, monitor[kCancellationToken], function (err, conn) {
    if (err) {
      monitor[kConnection] = undefined;
      failureHandler(err);
      return;
    }

    if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {
      conn.destroy({
        force: true
      });
      failureHandler(new MongoError('monitor was destroyed'));
      return;
    }

    monitor[kConnection] = conn;
    successHandler(conn.ismaster);
  });
}

function monitorServer(monitor) {
  stateTransition(monitor, STATE_MONITORING); // TODO: the next line is a legacy event, remove in v4

  process.nextTick(function () {
    return monitor.emit('monitoring', monitor[kServer]);
  });
  checkServer(monitor, function (e0) {
    if (e0 == null) {
      rescheduleMonitoring(monitor);
      return;
    } // otherwise an error occured on initial discovery, also bail


    if (monitor[kServer].description.type === ServerType.Unknown) {
      monitor.emit('resetServer', e0);
      rescheduleMonitoring(monitor);
      return;
    } // According to the SDAM specification's "Network error during server check" section, if
    // an ismaster call fails we reset the server's pool. If a server was once connected,
    // change its type to `Unknown` only after retrying once.


    monitor.emit('resetConnectionPool');
    checkServer(monitor, function (e1) {
      if (e1) {
        monitor.emit('resetServer', e1);
      }

      rescheduleMonitoring(monitor);
    });
  });
}

function rescheduleMonitoring(monitor, ms) {
  var heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;

  if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {
    return;
  }

  stateTransition(monitor, STATE_IDLE);
  monitor[kLastCheckTime] = process.hrtime();
  monitor[kMonitorId] = setTimeout(function () {
    monitor[kMonitorId] = undefined;
    monitor.requestCheck();
  }, ms || heartbeatFrequencyMS);
}

module.exports = {
  Monitor: Monitor
};