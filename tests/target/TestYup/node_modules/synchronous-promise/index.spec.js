/*
* linting omitted on spec mainly because jslint doesn"t seem to allow the
* mocha expression-like syntax
*/
"use strict";

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.promise.finally");

require("core-js/modules/web.timers");

require("regenerator-runtime/runtime");

var expect = require("chai").expect,
    sut = require("./index"),
    SynchronousPromise = sut.SynchronousPromise;

describe("synchronous-promise", function () {
  it("should be constructable", function () {
    expect(SynchronousPromise).to.exist;
    expect(new SynchronousPromise(function () {})).to.exist;
  });
  it("should have a then function", function () {
    expect(SynchronousPromise.prototype.then).to.be.a("function");
  });
  it("should have a catch function", function () {
    expect(SynchronousPromise.prototype["catch"]).to.be.a("function");
  });

  function create(ctor) {
    return new SynchronousPromise(ctor);
  }

  function createResolved(data) {
    return SynchronousPromise.resolve(data);
  }

  function createRejected(data) {
    return SynchronousPromise.reject(data);
  }

  describe("then", function () {
    it("when resolved, should return a new resolved promise", function () {
      var sut = createResolved();
      expect(sut.then(null, function () {})).to.be.instanceOf(SynchronousPromise);
    });
    it("should return the new resolved promise v2", function () {
      var result = createResolved().then(function () {
        /* purposely don't return anything */
      });
      expect(result).to.be.instanceOf(SynchronousPromise);
    });
    it("should return a new rejected promise", function () {
      var sut = createRejected();
      expect(sut.then(function () {})).to.be.instanceOf(SynchronousPromise);
    });
    it("should return a new rejected promise v2", function () {
      var result = createRejected().then(function () {
        /* purposely don't return anything */
      });
      expect(result).to.be.instanceOf(SynchronousPromise);
    });
    it("should bring the first resolve value into the first then", function () {
      var initial = "123";
      var captured = null;
      createResolved(initial).then(function (data) {
        captured = data;
      });
      expect(captured).to.equal(initial);
    });
    it("should call into the immediate catch function when the function given to then throws", function () {
      var sut = createResolved(),
          expected = "the error";
      var received = null;
      sut.then(function () {
        throw new Error(expected);
      })["catch"](function (err) {
        received = err;
      });
      expect(received.message).to.equal(expected);
    });
    it("should allow re-throwing in a .catch and re-catching later", function () {
      // Arrange
      var sut = createResolved(),
          error1 = "moo";
      var received = null;
      var expected = "moo-cow"; // Act

      sut.then(function () {
        throw new Error(error1);
      })["catch"](function (err) {
        debugger;
        throw new Error(err.message + "-cow");
      })["catch"](function (err) {
        received = err.message;
      }); // Assert

      expect(received).to.equal(expected);
    });
    it("should call the catch from a rejection invoke", function () {
      // Arrange
      var expected = "moo",
          sut = new SynchronousPromise(function (resolve, reject) {
        reject(expected);
      });
      var captured = null; // Act

      sut["catch"](function (e) {
        captured = e;
      }); // Assert

      expect(captured).to.equal(expected);
    });
    it("should call into the later catch function when the function given to then throws", function () {
      var sut = createResolved(),
          expected = "the error";
      var received = null;
      sut.then(function () {
        throw new Error(expected);
      }).then(function () {
        return 42; // not a thrower
      })["catch"](function (err) {
        received = err;
      });
      expect(received.message).to.equal(expected);
    });
    it("should prefer to call into onRejected over the .catch handler on failure", function () {
      var sut = createResolved(),
          expected = "the error";
      var captured = null,
          catchCaptured = null;
      sut.then(function () {
        throw expected;
      }, function (e) {
        captured = e;
      })["catch"](function (e) {
        console.log(".catch handler");
        catchCaptured = e;
      });
      expect(captured).to.equal(expected);
      expect(catchCaptured).to.be["null"];
    });
    it("should bring the first rejected value into the first onRejected then handler", function () {
      var initial = new Error("123");
      var captured = null;
      createRejected(initial).then(function () {}, function (e) {
        captured = e;
      });
      expect(captured).to.equal(initial);
    });
    it("should resolve when the first resolution is a resolved promise", function () {
      var initial = createResolved("123");
      var captured = null;
      createResolved(initial).then(function (data) {
        captured = data;
      });
      expect(captured).to.equal("123");
    });
    it("should catch when the first resolution is a rejected promise", function () {
      var initial = createRejected("123");
      var captured = null;
      createResolved(initial)["catch"](function (data) {
        captured = data;
      });
      expect(captured).to.equal("123");
    });
    it("should catch when a subsequent resolution returns a rejected promise", function () {
      var initial = createResolved("123");
      var captured = null;
      var expected = "le error";
      initial.then(function () {
        return createRejected(expected);
      })["catch"](function (e) {
        captured = e;
      });
      expect(captured).to.equal(expected);
    });
    it("should run a simple chain", function () {
      var initial = "123",
          second = "abc";
      var captured = null;
      createResolved(initial).then(function () {
        return createResolved(second);
      }).then(function (data) {
        captured = data;
      });
      expect(captured).to.equal(second);
    });
    it("should run a longer chain", function () {
      var initial = "123",
          second = "abc",
          third = "---",
          expected = second + third;
      var captured = null;
      createResolved(initial).then(function () {
        return createResolved(second);
      }).then(function () {
        return second;
      }).then(function (data) {
        captured = data + third;
      });
      expect(captured).to.equal(expected);
    });
    it("should run a longer chain v2", function () {
      var initial = "123",
          second = "abc",
          third = "---",
          expected = second + third;
      var captured = null;
      createResolved(initial).then(function () {
        return createResolved(second);
      }).then(function () {
        return createResolved(second);
      }).then(function (data) {
        captured = data + third;
      });
      expect(captured).to.equal(expected);
    });
    it("should run a longer chain v3", function () {
      var initial = "123",
          second = "abc",
          third = "---",
          expected = second + third;
      var captured = null;
      createResolved(initial).then(function () {
        return second;
      }).then(function () {
        return createResolved(second);
      }).then(function (data) {
        captured = data + third;
      });
      expect(captured).to.equal(expected);
    });
    it("should resolve when the ctor function resolves", function () {
      var providedResolve = null,
          captured = null;
      var expected = "xyz",
          promise = create(function (resolve) {
        providedResolve = resolve;
      }).then(function (data) {
        captured = data;
      });
      expect(promise).to.exist;
      expect(captured).to.be["null"];
      expect(providedResolve).to.be.a("function");
      providedResolve(expected);
      expect(captured).to.equal(expected);
    });
    it("should resolve the same value from the same promise multiple times", function () {
      // Arrange
      var expected = "multi-pass",
          sut = SynchronousPromise.resolve(expected);
      var captured1 = null,
          captured2 = null; // Act

      sut.then(function (result) {
        return captured1 = result;
      });
      sut.then(function (result) {
        return captured2 = result;
      }); // Assert

      expect(captured1).to.equal(expected);
      expect(captured2).to.equal(expected);
    });
  });
  describe("catch", function () {
    it("should be called if the initial reject is called", function () {
      var expected = "123";
      var captured = null;
      createRejected(expected)["catch"](function (e) {
        captured = e;
      });
      expect(captured).to.equal(expected);
    });
    it("should call handler if the promise resolves", function () {
      // Arrange
      var sut = SynchronousPromise.unresolved();
      var resolved = false,
          caught = false; // Act

      sut.then(function () {
        return resolved = true;
      })["catch"](function () {
        return caught = true;
      });
      sut.resolve(); // Assert

      expect(resolved).to.be["true"];
      expect(caught).to.be["false"];
    });
    it("should be called on a delayed rejection", function () {
      var providedReject = null,
          captured = null;
      var expected = "123",
          promise = create(function (resolve, reject) {
        providedReject = reject;
      })["catch"](function (e) {
        captured = e;
      });
      expect(promise).to.exist;
      expect(captured).to.be["null"];
      expect(providedReject).to.be.a("function");
      providedReject(expected);
      expect(captured).to.equal(expected);
    });
    it("should return a resolved promise if doesn't throw an error", function () {
      var promise = createRejected("123"),
          result = promise["catch"](function (data) {
        expect(data).to.equal("123");
      });
      expect(result).to.exist;
      expect(result).to.be.instanceOf(SynchronousPromise);
      expect(result.status).to.be.equal("resolved");
    });
    it("should not interfere with a later then if there is no error", function () {
      var captured = null;
      var expected = "123";
      var capturedError = null;
      createResolved(expected)["catch"](function (e) {
        capturedError = e;
      }).then(function (data) {
        captured = data;
      });
      expect(capturedError).to.be["null"];
      expect(captured).to.equal(expected);
    });
    it("should not be called if the promise is handled successful by a previous onRejected handler", function () {
      var expected = new Error("123"),
          notExpected = new Error("Not expected");
      var capturedError = null;
      createRejected(expected).then(function () {}, function (e) {
        capturedError = e;
      })["catch"](function () {
        /* purposely don't return anything */
        capturedError = notExpected;
      });
      expect(capturedError).to.equal(expected);
    });
    it("should prevent the handlers after the error from being called", function () {
      var captured = null;
      createResolved("123")["catch"](function (e) {}).then(function () {
        throw "foo";
      }).then(function () {
        captured = "abc";
      });
      expect(captured).to.be["null"];
    });
    it("should re-catch if a catch handler returns a rejected promise", function (done) {
      // Arrange
      var expected = "123",
          pausedRejectedPromise = SynchronousPromise.reject(expected).pause();
      var capturedA = null,
          capturedB = null;
      pausedRejectedPromise["catch"](function (e) {
        capturedA = e; // prove that this works even from an async promise

        return Promise.reject(e);
      })["catch"](function (e) {
        capturedB = e;
      }); // Act

      pausedRejectedPromise.resume(); // Assert

      setTimeout(function () {
        try {
          expect(capturedA).to.equal(expected);
          expect(capturedB).to.equal(expected);
          done();
        } catch (e) {
          done(e);
        }
      }, 100);
    });
    it("should re-catch if a then onRejected handler returns a rejected promise", function (done) {
      // Arrange
      var expected = "123",
          pausedRejectedPromise = SynchronousPromise.reject(expected).pause();
      var capturedA = null,
          capturedB = null;
      pausedRejectedPromise.then(function () {
        /* purposely don't return anything */
      }, function (e) {
        capturedA = e; // prove that this works even from an async promise

        return Promise.reject(e);
      })["catch"](function (e) {
        capturedB = e;
      }); // Act

      pausedRejectedPromise.resume(); // Assert

      setTimeout(function () {
        expect(capturedA).to.equal(expected);
        expect(capturedB).to.equal(expected);
        done();
      }, 100);
    });
    it("should continue if a catch handler returns a resolved promise", function (done) {
      // Arrange
      var expected = "123",
          pausedRejectedPromise = SynchronousPromise.reject(expected).pause();
      var capturedA = null,
          capturedB = null,
          secondResolve;
      pausedRejectedPromise["catch"](function (e) {
        capturedA = e; // prove that this works even from an async promise

        return Promise.resolve("456");
      })["catch"](function (e) {
        capturedB = e;
      }).then(function (data) {
        secondResolve = data;
      }); // Act

      pausedRejectedPromise.resume(); // Assert

      setTimeout(function () {
        try {
          expect(capturedA).to.equal(expected);
          expect(capturedB).to.be["null"];
          expect(secondResolve).to.equal("456");
          done();
        } catch (e) {
          done(e);
        }
      }, 100);
    });
  });
  describe("prototype pause", function () {
    it("should exist as a function on the prototype", function () {
      expect(SynchronousPromise.prototype.pause).to.be.a("function");
    });
    it("should return the promise", function () {
      var promise = createResolved("123"),
          result = promise.pause();
      expect(result).to.equal(promise);
    });
    it("should prevent resolution from continuing at that point", function () {
      var calls = 0;
      createResolved("123").then(function () {
        return calls++;
      }).pause().then(function () {
        return calls++;
      });
      expect(calls).to.equal(1);
    });
    it("should prevent rejection from being caught at that point", function () {
      var calls = 0;
      createRejected("123").pause()["catch"](function () {
        calls++;
      });
      expect(calls).to.equal(0);
    });
    it("should prevent rejection from continuing past at that point", function () {
      var calls = 0,
          captured = null;
      createRejected("123").then(function () {
        // should not be called
        calls++;
      })["catch"](function (e) {
        captured = e;
      }).pause().then(function () {
        calls++;
      });
      expect(captured).to.equal("123");
      expect(calls).to.equal(0);
    });
    describe("starting paused", function () {
      it("should return a promise in paused state with no initial data and being resolved on resume", function () {
        var captured = undefined;
        var promise = SynchronousPromise.resolve().pause().then(function () {
          return "moo";
        }).then(function (data) {
          captured = data;
        });
        expect(captured).to.be.undefined;
        promise.resume();
        expect(captured).to.equal("moo");
      });
      it("should return a promise in paused state with no initial data and being rejected on resume", function () {
        var captured = undefined;
        var expected = new Error("moon"),
            promise = SynchronousPromise.resolve().pause().then(function () {
          throw expected;
        })["catch"](function (e) {
          captured = e;
        });
        expect(captured).to.be.undefined;
        promise.resume();
        expect(captured).to.equal(expected);
      });
      it("should return a promise in paused state with no initial data and being resolved after a catch on resume", function () {
        var captured = undefined;
        var error = new Error("moon"),
            promise = SynchronousPromise.resolve().pause().then(function () {
          throw error;
        })["catch"](function (e) {
          return e.message;
        }).then(function (m) {
          captured = m;
        });
        expect(captured).to.be.undefined;
        promise.resume();
        expect(captured).to.equal("moon");
      });
    });
  });
  describe("resume", function () {
    it("should exist as a function on the prototype", function () {
      expect(SynchronousPromise.prototype.resume).to.be.a("function");
    });
    it("should return the promise", function () {
      var promise = createResolved("123").pause(),
          result = promise.resume();
      expect(result).to.equal(promise);
    });
    it("should not barf if the promise is not already paused", function () {
      var promise = createResolved("123");
      expect(function () {
        promise.resume();
      }).not.to["throw"];
    });
    it("should resume resolution operations after the last pause", function () {
      var calls = 0;
      var promise = createResolved("123").then(function () {
        return calls++;
      }).pause().then(function () {
        return calls++;
      });
      expect(calls).to.equal(1);
      promise.resume();
      expect(calls).to.equal(2);
    });
    it("should resume rejection operations after the last pause", function () {
      var calls = 0,
          captured = null;
      var expected = "die, scum!",
          promise = createResolved("123").then(function () {
        throw expected;
      }).pause().then(function () {
        return calls++;
      })["catch"](function (e) {
        captured = e;
      });
      expect(calls).to.equal(0);
      expect(captured).to.be["null"];
      promise.resume();
      expect(calls).to.equal(0);
      expect(captured).to.equal(expected);
    });
    it("should resume a promise which was started rejected as rejected", function () {
      var calls = 0,
          captured = null;
      var expected = "it\"s the end of the world!",
          promise = SynchronousPromise.reject(expected).pause().then(function () {
        calls++;
      })["catch"](function (e) {
        captured = e;
      });
      expect(calls).to.equal(0);
      expect(captured).to.be["null"];
      promise.resume();
      expect(calls).to.equal(0);
      expect(captured).to.equal(expected);
    });
  });
  describe("static resolve", function () {
    it("should be a function", function () {
      expect(SynchronousPromise.resolve).to.be.a("function");
    });
    it("should return a resolved promise", function () {
      var expected = "foo",
          result = SynchronousPromise.resolve(expected);
      expect(result.status).to.equal("resolved");
      var captured = null;
      result.then(function (data) {
        captured = data;
      });
      expect(captured).to.equal(expected);
    });
  });
  describe("static reject", function () {
    it("should be a function", function () {
      expect(SynchronousPromise.reject).to.be.a("function");
    });
    it("should return a rejected promise", function () {
      var expected = "moo",
          result = SynchronousPromise.reject(expected);
      expect(result.status).to.equal("rejected");
      var captured = null;
      result["catch"](function (err) {
        captured = err;
      });
      expect(captured).to.equal(expected);
    });
  });
  describe("static all", function () {
    it("should be a function", function () {
      expect(SynchronousPromise.all).to.be.a("function");
    });
    it("should resolve with all values from given resolved promises as variable args", function () {
      var p1 = createResolved("abc"),
          p2 = createResolved("123"),
          all = SynchronousPromise.all(p1, p2);
      var captured = null;
      all.then(function (data) {
        captured = data;
      });
      expect(captured).to.have.length(2);
      expect(captured).to.contain("abc");
      expect(captured).to.contain("123");
    });
    it("should resolve with all values from given promise or none promise variable args", function () {
      var all = SynchronousPromise.all(["123", createResolved("abc")]);
      var captured = null;
      all.then(function (data) {
        captured = data;
      });
      expect(captured).to.have.length(2);
      expect(captured).to.contain("abc");
      expect(captured).to.contain("123");
    });
    it("should resolve with all values from given resolved promises as an array", function () {
      var p1 = createResolved("abc"),
          p2 = createResolved("123"),
          all = SynchronousPromise.all([p1, p2]);
      var captured = null;
      all.then(function (data) {
        captured = data;
      });
      expect(captured).to.have.length(2);
      expect(captured).to.contain("abc");
      expect(captured).to.contain("123");
    });
    it("should resolve empty promise array", function () {
      var all = SynchronousPromise.all([]);
      var captured = null;
      all.then(function (data) {
        captured = data;
      });
      expect(captured).to.have.length(0);
    });
    it("should resolve with values in the correct order", function () {
      var resolve1 = undefined,
          resolve2 = undefined,
          captured = undefined;
      var p1 = create(function (resolve) {
        resolve1 = resolve;
      });
      var p2 = create(function (resolve) {
        resolve2 = resolve;
      });
      SynchronousPromise.all([p1, p2]).then(function (data) {
        captured = data;
      });
      resolve2("a");
      resolve1("b");
      expect(captured).to.deep.equal(["b", "a"]);
    });
    it("should reject if any promise rejects", function () {
      var p1 = createResolved("abc"),
          p2 = createRejected("123"),
          all = SynchronousPromise.all(p1, p2);
      var capturedData = null,
          capturedError = null;
      all.then(function (data) {
        capturedData = data;
      })["catch"](function (err) {
        capturedError = err;
      });
      expect(capturedData).to.be["null"];
      expect(capturedError).to.equal("123");
    });
  });
  describe("static unresolved", function () {
    it("should exist as a function", function () {
      // Arrange
      // Act
      // Assert
      expect(SynchronousPromise.unresolved).to.exist;
      expect(SynchronousPromise.unresolved).to.be.a("function");
    });
    it("should return a new SynchronousPromise", function () {
      // Arrange
      // Act
      var result1 = SynchronousPromise.unresolved(),
          result2 = SynchronousPromise.unresolved(); // Assert

      expect(result1).to.exist;
      expect(result2).to.exist;
      expect(Object.getPrototypeOf(result1)).to.equal(SynchronousPromise.prototype);
      expect(Object.getPrototypeOf(result2)).to.equal(SynchronousPromise.prototype);
      expect(result1).not.to.equal(result2);
    });
    describe("result", function () {
      it("should not be resolved or rejected", function () {
        // Arrange
        var resolved = false,
            rejected = false; // Act

        SynchronousPromise.unresolved().then(function () {
          resolved = true;
        })["catch"](function () {
          rejected = true;
        }); // Assert

        expect(resolved).to.be["false"];
        expect(rejected).to.be["false"];
      });
      describe("resolve", function () {
        it("should be a function", function () {
          // Arrange
          // Act
          var sut = SynchronousPromise.unresolved(); // Assert

          expect(sut.resolve).to.exist;
          expect(sut.resolve).to.be.a("function");
        });
        it("should resolve the promise when invoked", function () {
          // Arrange
          var resolved = undefined,
              error = undefined;
          var sut = SynchronousPromise.unresolved().then(function (result) {
            resolved = result;
          })["catch"](function (err) {
            error = err;
          }),
              expected = {
            key: "value"
          }; // Act

          debugger;
          sut.resolve(expected); // Assert

          expect(resolved).to.equal(expected);
          expect(error).not.to.exist;
        });
        it("should resolve all thens when invoked", function () {
          // Arrange
          var sut = SynchronousPromise.unresolved();
          var captured1 = undefined,
              captured2 = undefined;
          var next1 = sut.then(function (result) {
            return captured1 = result;
          }),
              next2 = sut.then(function (result) {
            return captured2 = result;
          }),
              expected = "cake-moo";
          expect(next1).to.exist;
          expect(next2).to.exist; // Act

          sut.resolve(expected); // Assert

          expect(captured1).to.equal(expected);
          expect(captured2).to.equal(expected);
        });
      });
      describe("reject property", function () {
        it("should be a function", function () {
          // Arrange
          // Act
          var sut = SynchronousPromise.unresolved(); // Assert

          expect(sut.reject).to.exist;
          expect(sut.reject).to.be.a("function");
        });
        it("should reject the promise when invoked", function () {
          // Arrange
          var resolved = undefined,
              error = undefined;
          var sut = SynchronousPromise.unresolved().then(function (result) {
            resolved = result;
          })["catch"](function (err) {
            error = err;
          }),
              expected = {
            key: "value"
          }; // Act

          sut.reject(expected); // Assert

          expect(error).to.equal(expected);
          expect(resolved).not.to.exist;
        });
      });
      describe("with timeout in ctor", function () {
        it("should complete when the timeout does", function (done) {
          // Arrange
          var captured; // Act

          new SynchronousPromise(function (resolve) {
            setTimeout(function () {
              resolve("moo");
            }, 0);
          }).then(function (result) {
            captured = result;
          }); // Assert

          setTimeout(function () {
            expect(captured).to.equal("moo");
            done();
          }, 500);
        });
      });
    });
  });
  describe("finally", function () {
    it("should call the provided function when the promise resolves", function _callee() {
      var called;
      return regeneratorRuntime.async(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // Arrange
              called = false; // Act

              SynchronousPromise.resolve("foo")["finally"](function () {
                called = true;
              }); // Assert

              expect(called).to.be["true"];

            case 3:
            case "end":
              return _context.stop();
          }
        }
      });
    });
    it("should call the provided function when the promise rejects", function _callee2() {
      var called;
      return regeneratorRuntime.async(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              // Arrange
              called = false; // Act

              SynchronousPromise.reject("foo")["finally"](function () {
                called = true;
              }); // Assert

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      });
    });
    it("should call the provided function when the promise is rejected then caught", function _callee3() {
      var catchCalled, finallyCalled;
      return regeneratorRuntime.async(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              // Arrange
              catchCalled = false, finallyCalled = false; // Act

              SynchronousPromise.reject("error")["catch"](function () {
                catchCalled = true;
              })["finally"](function () {
                finallyCalled = true;
              }); // Assert

              expect(catchCalled).to.be["true"];
              expect(finallyCalled).to.be["true"];

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      });
    });
    it("should start a new promise chain after resolution, with non-throwing finally", function _callee4() {
      var captured;
      return regeneratorRuntime.async(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              // Arrange
              captured = null; // Act

              SynchronousPromise.resolve("first value")["finally"](function () {
                return "second value";
              }).then(function (data) {
                captured = data;
              }); // Assert

              expect(captured).to.equal("second value");

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      });
    });
    it("should start a new promise chain after resolution, with resolving finally", function _callee5() {
      var captured;
      return regeneratorRuntime.async(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              // Arrange
              captured = null; // Act

              SynchronousPromise.resolve("first value")["finally"](function () {
                return SynchronousPromise.resolve("second value");
              }).then(function (data) {
                captured = data;
              }); // Assert

              expect(captured).to.equal("second value");

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      });
    });
    it("should start a new promise chain after resolution, with throwing finally", function _callee6() {
      var captured;
      return regeneratorRuntime.async(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              // Arrange
              captured = null; // Act

              SynchronousPromise.reject("first error")["finally"](function () {
                throw "finally data";
              })["catch"](function (data) {
                captured = data;
              }); // Assert

              expect(captured).to.equal("finally data");

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      });
    });
    it("should start a new promise chain after resolution, with rejecting finally", function _callee7() {
      var captured;
      return regeneratorRuntime.async(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              // Arrange
              captured = null; // Act

              SynchronousPromise.reject("first error")["finally"](function () {
                return SynchronousPromise.reject("finally data");
              })["catch"](function (data) {
                captured = data;
              }); // Assert

              expect(captured).to.equal("finally data");

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      });
    });
    it("should start a new promise chain after rejection, with non-throwing finally", function _callee8() {
      var called;
      return regeneratorRuntime.async(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              // Arrange
              called = false; // Act

              SynchronousPromise.reject("le error")["finally"](function () {}).then(function () {
                called = true;
              }); // Assert

              expect(called).to.be["true"];

            case 3:
            case "end":
              return _context8.stop();
          }
        }
      });
    });
    it("should start a new promise chain after rejection, with resolving finally", function _callee9() {
      var captured;
      return regeneratorRuntime.async(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              // Arrange
              captured = null; // Act

              SynchronousPromise.reject("le error")["finally"](function () {
                return SynchronousPromise.resolve("le data");
              }).then(function (data) {
                captured = data;
              }); // Assert

              expect(captured).to.equal("le data");

            case 3:
            case "end":
              return _context9.stop();
          }
        }
      });
    });
    it("should start a new promise chain after rejection, with throwing finally", function _callee10() {
      var finallyError;
      return regeneratorRuntime.async(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              // Arrange
              finallyError = null; // Act

              SynchronousPromise.reject("another error")["finally"](function () {
                throw "moo cakes";
              })["catch"](function (err) {
                finallyError = err;
              }); // Assert

              expect(finallyError).to.equal("moo cakes");

            case 3:
            case "end":
              return _context10.stop();
          }
        }
      });
    });
    it("should start a new promise chain after rejection, with rejecting finally", function _callee11() {
      var finallyError;
      return regeneratorRuntime.async(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              // Arrange
              finallyError = null; // Act

              SynchronousPromise.reject("another error")["finally"](function () {
                return SynchronousPromise.reject("moo cakes");
              })["catch"](function (err) {
                finallyError = err;
              }); // Assert

              expect(finallyError).to.equal("moo cakes");

            case 3:
            case "end":
              return _context11.stop();
          }
        }
      });
    });
    describe("issues", function () {
      it("should be called after one then from resolved()", function _callee12() {
        var events;
        return regeneratorRuntime.async(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                // Arrange
                events = []; // Act

                SynchronousPromise.resolve("initial").then(function (result) {
                  events.push(result);
                  events.push("then");
                })["finally"](function () {
                  events.push("finally");
                }); // Assert

                expect(events).to.eql(["initial", "then", "finally"]);

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        });
      });
      it("should be called after two thens from resolved()", function _callee13() {
        var events;
        return regeneratorRuntime.async(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                // Arrange
                events = []; // Act

                SynchronousPromise.resolve("initial").then(function (result) {
                  events.push(result);
                  events.push("then1");
                  return "then1";
                }).then(function (result) {
                  events.push("then2 received: ".concat(result));
                  events.push("then2");
                  console.log(events);
                })["finally"](function () {
                  events.push("finally");
                }); // Assert

                expect(events).to.eql(["initial", "then1", "then2 received: then1", "then2", "finally"]);

              case 3:
              case "end":
                return _context13.stop();
            }
          }
        });
      });
      it("should not be called from an unresolved promise", function _callee14() {
        var events;
        return regeneratorRuntime.async(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                // Arrange
                events = []; // Act

                SynchronousPromise.unresolved().then(function (result) {
                  debugger;
                  events.push("result: ".concat(result));
                })["catch"](function () {
                  return events.push("catch");
                })["finally"](function () {
                  return events.push("finally");
                }); // Assert

                expect(events).to.be.empty;

              case 3:
              case "end":
                return _context14.stop();
            }
          }
        });
      });
      it("should not be run if chain is paused", function _callee15() {
        var events, promise;
        return regeneratorRuntime.async(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                // Arrange
                events = [];
                promise = SynchronousPromise.resolve('init').then(function (result) {
                  events.push("result: ".concat(result));
                }).pause().then(function () {
                  events.push('resumed');
                })["finally"](function () {
                  events.push('finally');
                });
                expect(events).to.eql(["result: init"]); // Act

                promise.resume(); // Assert

                expect(events).to.eql(["result: init", "resumed", "finally"]);

              case 5:
              case "end":
                return _context15.stop();
            }
          }
        });
      });
      describe("imported specs from blalasaadri", function () {
        // these relate to https://github.com/fluffynuts/synchronous-promise/issues/15
        // reported by https://github.com/blalasaadri
        describe('SynchronousPromise', function () {
          describe('new SynchronousPromise', function () {
            it('calls .then() after being resolved', function () {
              var events = [];
              new SynchronousPromise(function (resolve) {
                events.push('init');
                resolve('resolve');
              }).then(function (result) {
                events.push("result: ".concat(result));
              }).then(function () {
                events.push('then');
              });
              expect(events).to.eql(['init', 'result: resolve', 'then']);
            });
            it('calls .catch() but not previous .then()s after being rejected', function () {
              var events = [];
              new SynchronousPromise(function (resolve, reject) {
                events.push('init');
                reject('reject');
              }).then(function (result) {
                events.push("result: ".concat(result));
              }).then(function () {
                events.push('then');
              })["catch"](function (error) {
                events.push("error: ".concat(error));
              });
              expect(events).to.eql(['init', 'error: reject']);
            });
            it('calls .finally() after .then()', function () {
              var events = [];
              new SynchronousPromise(function (resolve) {
                resolve('init');
              }).then(function (result) {
                events.push("result: ".concat(result));
              }).then(function () {
                events.push('then');
              })["finally"](function () {
                events.push('finally');
              });
              expect(events).to.eql(['result: init', 'then', 'finally']);
            });
            it('calls .finally() after .catch()', function () {
              var events = [];
              new SynchronousPromise(function (resolve, reject) {
                reject('init');
              }).then(function (result) {
                events.push("result: ".concat(result));
              }).then(function () {
                events.push('then');
              })["catch"](function (error) {
                events.push("error: ".concat(error));
              })["finally"](function () {
                events.push('finally');
              });
              expect(events).to.eql(['error: init', 'finally']);
            });
          });
          describe('SynchronousPromise.unresolved', function () {
            describe('calls .then() only after being resolved', function () {
              it('calls nothing before promise.resolve is called', function () {
                var events = [];
                SynchronousPromise.unresolved().then(function (result) {
                  events.push("result: ".concat(result));
                }).then(function () {
                  events.push('then');
                });
                expect(events).to.eql([]);
              });
              it('calls .then() once promise.resolve is called', function () {
                var events = [];
                var promise = SynchronousPromise.unresolved().then(function (result) {
                  events.push("result: ".concat(result));
                }).then(function () {
                  events.push('then');
                });
                promise.resolve('resolve');
                expect(events).to.eql(['result: resolve', 'then']);
              });
            });
            it('calls .catch() but not previous .then()s after being rejected', function () {
              var events = [];
              var promise = SynchronousPromise.unresolved().then(function (result) {
                events.push("result: ".concat(result));
              }).then(function () {
                events.push('then');
              })["catch"](function (error) {
                events.push("error: ".concat(error));
              });
              promise.reject('reject');
              expect(events).to.eql(['error: reject']);
            });
            describe('calls .finally() after .then()', function () {
              it('calls nothing before promise.resolve is called', function () {
                var events = [];
                SynchronousPromise.unresolved().then(function (result) {
                  events.push("result: ".concat(result));
                }).then(function () {
                  events.push('then');
                })["finally"](function () {
                  events.push('finally');
                });
                expect(events).not.to.contain('finally');
                expect(events).to.eql([]);
              });
              it('calls .then() and .finally() once promise.resolve is called', function () {
                var events = [];
                var promise = SynchronousPromise.unresolved().then(function (result) {
                  events.push("result: ".concat(result));
                }).then(function () {
                  events.push('then');
                })["finally"](function () {
                  events.push('finally');
                });
                promise.resolve('resolve');
                expect(events).not.to.eql(['finally', 'result: undefined', 'then']);
                expect(events).to.eql(['result: resolve', 'then', 'finally']);
              });
            });
            describe('calls .finally() after .catch()', function () {
              it('calls nothing before promise.reject is called', function () {
                var events = [];
                SynchronousPromise.unresolved().then(function (result) {
                  events.push("result: ".concat(result));
                })["catch"](function () {
                  events.push('catch');
                })["finally"](function () {
                  events.push('finally');
                });
                expect(events).not.to.contain('finally');
                expect(events).to.eql([]);
              });
              it('calls .catch() and .finally() once promise.reject is called', function () {
                var events = [];
                var promise = SynchronousPromise.unresolved().then(function (result) {
                  events.push("result: ".concat(result));
                })["catch"](function (error) {
                  events.push("error: ".concat(error));
                })["finally"](function () {
                  events.push('finally');
                });
                promise.reject('reject');
                expect(events).not.to.eql(['finally', 'result: undefined']);
                expect(events).to.eql(['error: reject', 'finally']);
              });
            });
          });
          describe('SynchronousPromise.resolve(...).pause', function () {
            describe('calls .then() only after being resolved', function () {
              it('calls nothing after the initial initialization before promise.resume is called', function () {
                var events = [];
                SynchronousPromise.resolve('init').then(function (result) {
                  events.push("result: ".concat(result));
                }).pause().then(function () {
                  events.push('resumed');
                });
                expect(events).to.eql(['result: init']);
              });
              it('calls .then() after the inital initialization after promise.resume is called', function () {
                var events = [];
                var promise = SynchronousPromise.resolve('init').then(function (result) {
                  events.push("result: ".concat(result));
                }).pause().then(function () {
                  events.push('resumed');
                });
                promise.resume();
                expect(events).to.eql(['result: init', 'resumed']);
              });
            });
            describe('calls .catch() only after being resolved', function () {
              it('calls nothing after the inital initialization before promise.resume is called', function () {
                var events = [];
                SynchronousPromise.resolve('init').then(function (result) {
                  events.push("result: ".concat(result));
                  throw Error('resumed');
                }).pause()["catch"](function (_ref) {
                  var message = _ref.message;
                  events.push("catch: ".concat(message));
                });
                expect(events).to.eql(['result: init']);
              });
              it('calls .catch() after the inital initialization after promise.resume is called', function () {
                var events = [];
                var promise = SynchronousPromise.resolve('init').then(function (result) {
                  events.push("result: ".concat(result));
                  throw Error('resumed');
                }).pause()["catch"](function (_ref2) {
                  var message = _ref2.message;
                  events.push("catch: ".concat(message));
                });
                promise.resume();
                expect(events).to.eql(['result: init', 'catch: resumed']);
              });
            });
            describe('calls .finally() after .then()', function () {
              it('calls nothing before promise.resume is called', function () {
                var events = [];
                SynchronousPromise.resolve('init').then(function (result) {
                  events.push("result: ".concat(result));
                }).pause().then(function () {
                  events.push('resumed');
                })["finally"](function () {
                  events.push('finally');
                });
                expect(events).not.to.contain('finally');
                expect(events).to.eql(['result: init']);
              });
              it('calls .then() and .finally() once promise.resume is called', function () {
                var events = [];
                var promise = SynchronousPromise.resolve('init').then(function (result) {
                  events.push("result: ".concat(result));
                }).pause().then(function () {
                  events.push('resumed');
                })["finally"](function () {
                  events.push('finally');
                });
                promise.resume();
                expect(events).not.to.eql(['result: init', 'finally', 'resumed']);
                expect(events).to.eql(['result: init', 'resumed', 'finally']);
              });
            });
            describe('calls .finally() after .catch()', function () {
              it('calls nothing before promise.resume is called', function () {
                var events = [];
                SynchronousPromise.resolve('init').then(function (result) {
                  events.push("result: ".concat(result));
                  throw Error('resumed');
                }).pause()["catch"](function (_ref3) {
                  var message = _ref3.message;
                  events.push("catch: ".concat(message));
                })["finally"](function () {
                  events.push('finally');
                });
                expect(events).not.to.contain('finally');
                expect(events).to.eql(['result: init']);
              });
              it('calls .catch() and .finally() once promise.resume is called', function () {
                var events = [];
                var promise = SynchronousPromise.resolve('init').then(function (result) {
                  events.push("result: ".concat(result));
                  throw Error('resumed');
                }).pause()["catch"](function (_ref4) {
                  var message = _ref4.message;
                  events.push("catch: ".concat(message));
                })["finally"](function () {
                  events.push('finally');
                });
                promise.resume();
                expect(events).not.to.eql(['result: init', 'finally', 'catch: resumed']);
                expect(events).to.eql(['result: init', 'catch: resumed', 'finally']);
              });
            });
          });
        });
      });
    });
  });
});