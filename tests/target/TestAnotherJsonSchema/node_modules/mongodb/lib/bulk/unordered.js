'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var common = require('./common');

var BulkOperationBase = common.BulkOperationBase;

var utils = require('../utils');

var toError = utils.toError;
var handleCallback = utils.handleCallback;
var BulkWriteResult = common.BulkWriteResult;
var Batch = common.Batch;
var mergeBatchResults = common.mergeBatchResults;
var executeOperation = utils.executeOperation;

var MongoWriteConcernError = require('mongodb-core').MongoWriteConcernError;

var handleMongoWriteConcernError = require('./common').handleMongoWriteConcernError;

var bson = common.bson;
/**
 * Add to internal list of Operations
 *
 * @param {UnorderedBulkOperation} bulkOperation
 * @param {number} docType number indicating the document type
 * @param {object} document
 * @return {UnorderedBulkOperation}
 */

function addToOperationsList(bulkOperation, docType, document) {
  // Get the bsonSize
  var bsonSize = bson.calculateObjectSize(document, {
    checkKeys: false
  }); // Throw error if the doc is bigger than the max BSON size

  if (bsonSize >= bulkOperation.s.maxBatchSizeBytes) throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBatchSizeBytes); // Holds the current batch

  bulkOperation.s.currentBatch = null; // Get the right type of batch

  if (docType === common.INSERT) {
    bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;
  } else if (docType === common.UPDATE) {
    bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;
  } else if (docType === common.REMOVE) {
    bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;
  } // Create a new batch object if we don't have a current one


  if (bulkOperation.s.currentBatch == null) bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Check if we need to create a new batch

  if (bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatch.sizeBytes + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
    // Save the batch to the execution stack
    bulkOperation.s.batches.push(bulkOperation.s.currentBatch); // Create a new batch

    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
  } // We have an array of documents


  if (Array.isArray(document)) {
    throw toError('operation passed in cannot be an Array');
  } else {
    bulkOperation.s.currentBatch.operations.push(document);
    bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
    bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
  } // Save back the current Batch to the right type


  if (docType === common.INSERT) {
    bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;
    bulkOperation.s.bulkResult.insertedIds.push({
      index: bulkOperation.s.bulkResult.insertedIds.length,
      _id: document._id
    });
  } else if (docType === common.UPDATE) {
    bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;
  } else if (docType === common.REMOVE) {
    bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;
  } // Update current batch size


  bulkOperation.s.currentBatch.size = bulkOperation.s.currentBatch.size + 1;
  bulkOperation.s.currentBatch.sizeBytes = bulkOperation.s.currentBatch.sizeBytes + bsonSize; // Return bulkOperation

  return bulkOperation;
}
/**
 * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)
 * @class
 * @property {number} length Get the number of operations in the bulk.
 * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.
 */


var UnorderedBulkOperation =
/*#__PURE__*/
function (_BulkOperationBase) {
  _inherits(UnorderedBulkOperation, _BulkOperationBase);

  function UnorderedBulkOperation(topology, collection, options) {
    _classCallCheck(this, UnorderedBulkOperation);

    options = options || {};
    options = Object.assign(options, {
      addToOperationsList: addToOperationsList
    });
    return _possibleConstructorReturn(this, _getPrototypeOf(UnorderedBulkOperation).call(this, topology, collection, options, false));
  }
  /**
   * The callback format for results
   * @callback UnorderedBulkOperation~resultCallback
   * @param {MongoError} error An error instance representing the error during the execution.
   * @param {BulkWriteResult} result The bulk write result.
   */

  /**
   * Execute the ordered bulk operation
   *
   * @method
   * @param {object} [options] Optional settings.
   * @param {(number|string)} [options.w] The write concern.
   * @param {number} [options.wtimeout] The write concern timeout.
   * @param {boolean} [options.j=false] Specify a journal write concern.
   * @param {boolean} [options.fsync=false] Specify a file sync write concern.
   * @param {UnorderedBulkOperation~resultCallback} [callback] The result callback
   * @throws {MongoError}
   * @return {Promise} returns Promise if no callback passed
   */


  _createClass(UnorderedBulkOperation, [{
    key: "execute",
    value: function execute(_writeConcern, options, callback) {
      var ret = this.bulkExecute(_writeConcern, options, callback);
      options = ret.options;
      callback = ret.callback;
      return executeOperation(this.s.topology, executeBatches, [this, options, callback]);
    }
  }]);

  return UnorderedBulkOperation;
}(BulkOperationBase);
/**
 * Execute the command
 *
 * @param {UnorderedBulkOperation} bulkOperation
 * @param {object} batch
 * @param {object} options
 * @param {function} callback
 */


function executeBatch(bulkOperation, batch, options, callback) {
  function resultHandler(err, result) {
    // Error is a driver related error not a bulk op error, terminate
    if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
      return handleCallback(callback, err);
    } // If we have and error


    if (err) err.ok = 0;

    if (err instanceof MongoWriteConcernError) {
      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, false, err, callback);
    }

    handleCallback(callback, null, mergeBatchResults(false, batch, bulkOperation.s.bulkResult, err, result));
  }

  bulkOperation.finalOptionsHandler({
    options: options,
    batch: batch,
    resultHandler: resultHandler
  }, callback);
}
/**
 * Execute all the commands
 *
 * @param {UnorderedBulkOperation} bulkOperation
 * @param {object} options
 * @param {function} callback
 */


function executeBatches(bulkOperation, options, callback) {
  var numberOfCommandsToExecute = bulkOperation.s.batches.length; // Execute over all the batches

  for (var i = 0; i < bulkOperation.s.batches.length; i++) {
    executeBatch(bulkOperation, bulkOperation.s.batches[i], options, function (err) {
      // Count down the number of commands left to execute
      numberOfCommandsToExecute = numberOfCommandsToExecute - 1; // Execute

      if (numberOfCommandsToExecute === 0) {
        // Driver level error
        if (err) return handleCallback(callback, err);
        var writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
        if (bulkOperation.handleWriteError(callback, writeResult)) return;
        return handleCallback(callback, null, writeResult);
      }
    });
  }
}
/**
 * Returns an unordered batch object
 * @ignore
 */


function initializeUnorderedBulkOp(topology, collection, options) {
  return new UnorderedBulkOperation(topology, collection, options);
}

initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
module.exports = initializeUnorderedBulkOp;
module.exports.Bulk = UnorderedBulkOperation;