'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var common = require('./common');

var BulkOperationBase = common.BulkOperationBase;

var utils = require('../utils');

var toError = utils.toError;
var handleCallback = utils.handleCallback;
var BulkWriteResult = common.BulkWriteResult;
var Batch = common.Batch;
var mergeBatchResults = common.mergeBatchResults;
var executeOperation = utils.executeOperation;

var MongoWriteConcernError = require('mongodb-core').MongoWriteConcernError;

var handleMongoWriteConcernError = require('./common').handleMongoWriteConcernError;

var bson = common.bson;
/**
 * Add to internal list of Operations
 *
 * @param {OrderedBulkOperation} bulkOperation
 * @param {number} docType number indicating the document type
 * @param {object} document
 * @return {OrderedBulkOperation}
 */

function addToOperationsList(bulkOperation, docType, document) {
  // Get the bsonSize
  var bsonSize = bson.calculateObjectSize(document, {
    checkKeys: false
  }); // Throw error if the doc is bigger than the max BSON size

  if (bsonSize >= bulkOperation.s.maxBatchSizeBytes) throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBatchSizeBytes); // Create a new batch object if we don't have a current one

  if (bulkOperation.s.currentBatch == null) bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Check if we need to create a new batch

  if (bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatchSizeBytes + bulkOperation.s.currentBatchSizeBytes >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
    // Save the batch to the execution stack
    bulkOperation.s.batches.push(bulkOperation.s.currentBatch); // Create a new batch

    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Reset the current size trackers

    bulkOperation.s.currentBatchSize = 0;
    bulkOperation.s.currentBatchSizeBytes = 0;
  } else {
    // Update current batch size
    bulkOperation.s.currentBatchSize = bulkOperation.s.currentBatchSize + 1;
    bulkOperation.s.currentBatchSizeBytes = bulkOperation.s.currentBatchSizeBytes + bsonSize;
  }

  if (docType === common.INSERT) {
    bulkOperation.s.bulkResult.insertedIds.push({
      index: bulkOperation.s.currentIndex,
      _id: document._id
    });
  } // We have an array of documents


  if (Array.isArray(document)) {
    throw toError('operation passed in cannot be an Array');
  } else {
    bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
    bulkOperation.s.currentBatch.operations.push(document);
    bulkOperation.s.currentBatchSizeBytes = bulkOperation.s.currentBatchSizeBytes + bsonSize;
    bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
  } // Return bulkOperation


  return bulkOperation;
}
/**
 * Create a new OrderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)
 * @class
 * @property {number} length Get the number of operations in the bulk.
 * @return {OrderedBulkOperation} a OrderedBulkOperation instance.
 */


var OrderedBulkOperation =
/*#__PURE__*/
function (_BulkOperationBase) {
  _inherits(OrderedBulkOperation, _BulkOperationBase);

  function OrderedBulkOperation(topology, collection, options) {
    _classCallCheck(this, OrderedBulkOperation);

    options = options || {};
    options = Object.assign(options, {
      addToOperationsList: addToOperationsList
    });
    return _possibleConstructorReturn(this, _getPrototypeOf(OrderedBulkOperation).call(this, topology, collection, options, true));
  }
  /**
   * The callback format for results
   * @callback OrderedBulkOperation~resultCallback
   * @param {MongoError} error An error instance representing the error during the execution.
   * @param {BulkWriteResult} result The bulk write result.
   */

  /**
   * Execute the ordered bulk operation
   *
   * @method
   * @param {object} [options] Optional settings.
   * @param {(number|string)} [options.w] The write concern.
   * @param {number} [options.wtimeout] The write concern timeout.
   * @param {boolean} [options.j=false] Specify a journal write concern.
   * @param {boolean} [options.fsync=false] Specify a file sync write concern.
   * @param {OrderedBulkOperation~resultCallback} [callback] The result callback
   * @throws {MongoError}
   * @return {Promise} returns Promise if no callback passed
   */


  _createClass(OrderedBulkOperation, [{
    key: "execute",
    value: function execute(_writeConcern, options, callback) {
      var ret = this.bulkExecute(_writeConcern, options, callback);
      options = ret.options;
      callback = ret.callback;
      return executeOperation(this.s.topology, executeCommands, [this, options, callback]);
    }
  }]);

  return OrderedBulkOperation;
}(BulkOperationBase);
/**
 * Execute next write command in a chain
 *
 * @param {OrderedBulkOperation} bulkOperation
 * @param {object} options
 * @param {function} callback
 */


function executeCommands(bulkOperation, options, callback) {
  if (bulkOperation.s.batches.length === 0) {
    return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
  } // Ordered execution of the command


  var batch = bulkOperation.s.batches.shift();

  function resultHandler(err, result) {
    // Error is a driver related error not a bulk op error, terminate
    if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
      return handleCallback(callback, err);
    } // If we have and error


    if (err) err.ok = 0;

    if (err instanceof MongoWriteConcernError) {
      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, true, err, callback);
    } // Merge the results together


    var writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
    var mergeResult = mergeBatchResults(true, batch, bulkOperation.s.bulkResult, err, result);

    if (mergeResult != null) {
      return handleCallback(callback, null, writeResult);
    }

    if (bulkOperation.handleWriteError(callback, writeResult)) return; // Execute the next command in line

    executeCommands(bulkOperation, options, callback);
  }

  bulkOperation.finalOptionsHandler({
    options: options,
    batch: batch,
    resultHandler: resultHandler
  }, callback);
}
/**
 * Returns an unordered batch object
 * @ignore
 */


function initializeOrderedBulkOp(topology, collection, options) {
  return new OrderedBulkOperation(topology, collection, options);
}

initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
module.exports = initializeOrderedBulkOp;
module.exports.Bulk = OrderedBulkOperation;