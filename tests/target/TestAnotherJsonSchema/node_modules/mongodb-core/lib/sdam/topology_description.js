'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ServerType = require('./server_description').ServerType;

var ServerDescription = require('./server_description').ServerDescription;

var ReadPreference = require('../topologies/read_preference'); // contstants related to compatability checks


var MIN_SUPPORTED_SERVER_VERSION = '2.6';
var MIN_SUPPORTED_WIRE_VERSION = 2;
var MAX_SUPPORTED_WIRE_VERSION = 5; // An enumeration of topology types we know about

var TopologyType = {
  Single: 'Single',
  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',
  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',
  Sharded: 'Sharded',
  Unknown: 'Unknown'
}; // Representation of a deployment of servers

var TopologyDescription =
/*#__PURE__*/
function () {
  /**
   * Create a TopologyDescription
   *
   * @param {string} topologyType
   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription
   * @param {string} setName
   * @param {number} maxSetVersion
   * @param {ObjectId} maxElectionId
   */
  function TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, options) {
    _classCallCheck(this, TopologyDescription);

    options = options || {}; // TODO: consider assigning all these values to a temporary value `s` which
    //       we use `Object.freeze` on, ensuring the internal state of this type
    //       is immutable.

    this.type = topologyType || TopologyType.Unknown;
    this.setName = setName || null;
    this.maxSetVersion = maxSetVersion || null;
    this.maxElectionId = maxElectionId || null;
    this.servers = serverDescriptions || new Map();
    this.stale = false;
    this.compatible = true;
    this.compatibilityError = null;
    this.logicalSessionTimeoutMinutes = null;
    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;
    this.localThresholdMS = options.localThresholdMS || 0;
    this.options = options; // determine server compatibility

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = this.servers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var serverDescription = _step.value;

        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = "Server at ".concat(serverDescription.address, " requires wire version ").concat(serverDescription.minWireVersion, ", but this version of the driver only supports up to ").concat(MAX_SUPPORTED_WIRE_VERSION, ".");
        }

        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = "Server at ".concat(serverDescription.address, " reports wire version ").concat(serverDescription.maxWireVersion, ", but this version of the driver requires at least ").concat(MIN_SUPPORTED_WIRE_VERSION, " (MongoDB ").concat(MIN_SUPPORTED_SERVER_VERSION, ").");
          break;
        }
      } // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set
      // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes
      // value among ServerDescriptions of all data-bearing server types. If any have a null
      // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be
      // set to null.

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var readableServers = Array.from(this.servers.values()).filter(function (s) {
      return s.isReadable;
    });
    this.logicalSessionTimeoutMinutes = readableServers.reduce(function (result, server) {
      if (server.logicalSessionTimeoutMinutes == null) return null;
      if (result == null) return server.logicalSessionTimeoutMinutes;
      return Math.min(result, server.logicalSessionTimeoutMinutes);
    }, null);
  }
  /**
   * @returns The minimum reported wire version of all known servers
   */


  _createClass(TopologyDescription, [{
    key: "update",

    /**
     * Returns a copy of this description updated with a given ServerDescription
     *
     * @param {ServerDescription} serverDescription
     */
    value: function update(serverDescription) {
      var address = serverDescription.address; // NOTE: there are a number of prime targets for refactoring here
      //       once we support destructuring assignments
      // potentially mutated values

      var topologyType = this.type;
      var setName = this.setName;
      var maxSetVersion = this.maxSetVersion;
      var maxElectionId = this.maxElectionId;
      var serverType = serverDescription.type;
      var serverDescriptions = new Map(this.servers); // update the actual server description

      serverDescriptions.set(address, serverDescription);

      if (topologyType === TopologyType.Single) {
        // once we are defined as single, that never changes
        return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, this.options);
      }

      if (topologyType === TopologyType.Unknown) {
        if (serverType === ServerType.Standalone) {
          serverDescriptions["delete"](address);
        } else {
          topologyType = topologyTypeForServerType(serverType);
        }
      }

      if (topologyType === TopologyType.Sharded) {
        if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {
          serverDescriptions["delete"](address);
        }
      }

      if (topologyType === TopologyType.ReplicaSetNoPrimary) {
        if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) >= 0) {
          serverDescriptions["delete"](address);
        }

        if (serverType === ServerType.RSPrimary) {
          var result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
          topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
          var _result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);

          topologyType = _result[0], setName = _result[1];
        }
      }

      if (topologyType === TopologyType.ReplicaSetWithPrimary) {
        if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
          serverDescriptions["delete"](address);
          topologyType = checkHasPrimary(serverDescriptions);
        } else if (serverType === ServerType.RSPrimary) {
          var _result2 = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);

          topologyType = _result2[0], setName = _result2[1], maxSetVersion = _result2[2], maxElectionId = _result2[3];
        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);
        } else {
          topologyType = checkHasPrimary(serverDescriptions);
        }
      }

      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, this.options);
    }
    /**
     * Determines if the topology has a readable server available. See the table in the
     * following section for behaviour rules.
     *
     * @param {ReadPreference} [readPreference] An optional read preference for determining if a readable server is present
     * @return {Boolean} Whether there is a readable server in this topology
     */

  }, {
    key: "hasReadableServer",
    value: function hasReadableServer()
    /* readPreference */
    {} // To be implemented when server selection is implemented

    /**
     * Determines if the topology has a writable server available. See the table in the
     * following section for behaviour rules.
     *
     * @return {Boolean} Whether there is a writable server in this topology
     */

  }, {
    key: "hasWritableServer",
    value: function hasWritableServer() {
      return this.hasReadableServer(ReadPreference.primary);
    }
    /**
     * Determines if the topology has a definition for the provided address
     *
     * @param {String} address
     * @return {Boolean} Whether the topology knows about this server
     */

  }, {
    key: "hasServer",
    value: function hasServer(address) {
      return this.servers.has(address);
    }
  }, {
    key: "commonWireVersion",
    get: function get() {
      return Array.from(this.servers.values()).filter(function (server) {
        return server.type !== ServerType.Unknown;
      }).reduce(function (min, server) {
        return min == null ? server.maxWireVersion : Math.min(min, server.maxWireVersion);
      }, null);
    }
  }]);

  return TopologyDescription;
}();

function topologyTypeForServerType(serverType) {
  if (serverType === ServerType.Mongos) return TopologyType.Sharded;
  if (serverType === ServerType.RSPrimary) return TopologyType.ReplicaSetWithPrimary;
  return TopologyType.ReplicaSetNoPrimary;
}

function updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {
  setName = setName || serverDescription.setName;

  if (setName !== serverDescription.setName) {
    serverDescriptions["delete"](serverDescription.address);
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
  }

  var electionIdOID = serverDescription.electionId ? serverDescription.electionId.$oid : null;
  var maxElectionIdOID = maxElectionId ? maxElectionId.$oid : null;

  if (serverDescription.setVersion != null && electionIdOID != null) {
    if (maxSetVersion != null && maxElectionIdOID != null) {
      if (maxSetVersion > serverDescription.setVersion || maxElectionIdOID > electionIdOID) {
        // this primary is stale, we must remove it
        serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
    }

    maxElectionId = serverDescription.electionId;
  }

  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
    maxSetVersion = serverDescription.setVersion;
  } // We've heard from the primary. Is it the same primary as before?


  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = serverDescriptions.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var address = _step2.value;
      var server = serverDescriptions.get(address);

      if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {
        // Reset old primary's type to Unknown.
        serverDescriptions.set(address, new ServerDescription(server.address)); // There can only be one primary

        break;
      }
    } // Discover new hosts from this primary's response.

  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  serverDescription.allHosts.forEach(function (address) {
    if (!serverDescriptions.has(address)) {
      serverDescriptions.set(address, new ServerDescription(address));
    }
  }); // Remove hosts not in the response.

  var currentAddresses = Array.from(serverDescriptions.keys());
  var responseAddresses = serverDescription.allHosts;
  currentAddresses.filter(function (addr) {
    return responseAddresses.indexOf(addr) === -1;
  }).forEach(function (address) {
    serverDescriptions["delete"](address);
  });
  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
}

function updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {
  if (setName == null) {
    throw new TypeError('setName is required');
  }

  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
    serverDescriptions["delete"](serverDescription.address);
  }

  return checkHasPrimary(serverDescriptions);
}

function updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {
  var topologyType = TopologyType.ReplicaSetNoPrimary;
  setName = setName || serverDescription.setName;

  if (setName !== serverDescription.setName) {
    serverDescriptions["delete"](serverDescription.address);
    return [topologyType, setName];
  }

  serverDescription.allHosts.forEach(function (address) {
    if (!serverDescriptions.has(address)) {
      serverDescriptions.set(address, new ServerDescription(address));
    }
  });

  if (serverDescription.me && serverDescription.address !== serverDescription.me) {
    serverDescriptions["delete"](serverDescription.address);
  }

  return [topologyType, setName];
}

function checkHasPrimary(serverDescriptions) {
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = serverDescriptions.keys()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var addr = _step3.value;

      if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {
        return TopologyType.ReplicaSetWithPrimary;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return TopologyType.ReplicaSetNoPrimary;
}

module.exports = {
  TopologyType: TopologyType,
  TopologyDescription: TopologyDescription
};