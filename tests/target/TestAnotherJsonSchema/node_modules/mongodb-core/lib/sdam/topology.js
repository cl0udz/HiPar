'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = require('events');

var ServerDescription = require('./server_description').ServerDescription;

var TopologyDescription = require('./topology_description').TopologyDescription;

var TopologyType = require('./topology_description').TopologyType;

var monitoring = require('./monitoring');

var calculateDurationInMs = require('../utils').calculateDurationInMs;

var MongoTimeoutError = require('../error').MongoTimeoutError;

var MongoNetworkError = require('../error').MongoNetworkError;

var Server = require('./server');

var relayEvents = require('../utils').relayEvents;

var ReadPreference = require('../topologies/read_preference');

var readPreferenceServerSelector = require('./server_selectors').readPreferenceServerSelector;

var writableServerSelector = require('./server_selectors').writableServerSelector;

var isRetryableWritesSupported = require('../topologies/shared').isRetryableWritesSupported;

var Cursor = require('./cursor');

var deprecate = require('util').deprecate;

var BSON = require('../connection/utils').retrieveBSON();

var createCompressionInfo = require('../topologies/shared').createCompressionInfo; // Global state


var globalTopologyCounter = 0; // Constants

var TOPOLOGY_DEFAULTS = {
  localThresholdMS: 15,
  serverSelectionTimeoutMS: 10000,
  heartbeatFrequencyMS: 30000,
  minHeartbeatIntervalMS: 500
};
/**
 * A container of server instances representing a connection to a MongoDB topology.
 *
 * @fires Topology#serverOpening
 * @fires Topology#serverClosed
 * @fires Topology#serverDescriptionChanged
 * @fires Topology#topologyOpening
 * @fires Topology#topologyClosed
 * @fires Topology#topologyDescriptionChanged
 * @fires Topology#serverHeartbeatStarted
 * @fires Topology#serverHeartbeatSucceeded
 * @fires Topology#serverHeartbeatFailed
 */

var Topology =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Topology, _EventEmitter);

  /**
   * Create a topology
   *
   * @param {Array|String} [seedlist] a string list, or array of Server instances to connect to
   * @param {Object} [options] Optional settings
   * @param {Number} [options.localThresholdMS=15] The size of the latency window for selecting among multiple suitable servers
   * @param {Number} [options.serverSelectionTimeoutMS=30000] How long to block for server selection before throwing an error
   * @param {Number} [options.heartbeatFrequencyMS=10000] The frequency with which topology updates are scheduled
   */
  function Topology(seedlist, options) {
    var _this;

    _classCallCheck(this, Topology);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Topology).call(this));

    if (typeof options === 'undefined') {
      options = seedlist;
      seedlist = []; // this is for legacy single server constructor support

      if (options.host) {
        seedlist.push({
          host: options.host,
          port: options.port
        });
      }
    }

    seedlist = seedlist || [];
    options = Object.assign({}, TOPOLOGY_DEFAULTS, options);
    var topologyType = topologyTypeFromSeedlist(seedlist, options);
    var topologyId = globalTopologyCounter++;
    var serverDescriptions = seedlist.reduce(function (result, seed) {
      var address = seed.port ? "".concat(seed.host, ":").concat(seed.port) : "".concat(seed.host, ":27017");
      result.set(address, new ServerDescription(address));
      return result;
    }, new Map());
    _this.s = {
      // the id of this topology
      id: topologyId,
      // passed in options
      options: Object.assign({}, options),
      // initial seedlist of servers to connect to
      seedlist: seedlist,
      // the topology description
      description: new TopologyDescription(topologyType, serverDescriptions, options.replicaSet, null, null, options),
      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
      heartbeatFrequencyMS: options.heartbeatFrequencyMS,
      minHeartbeatIntervalMS: options.minHeartbeatIntervalMS,
      // allow users to override the cursor factory
      Cursor: options.cursorFactory || Cursor,
      // the bson parser
      bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp])
    }; // amend options for server instance creation

    _this.s.options.compression = {
      compressors: createCompressionInfo(options)
    };
    return _this;
  }
  /**
   * @return A `TopologyDescription` for this topology
   */


  _createClass(Topology, [{
    key: "connections",

    /**
     * All raw connections
     * @method
     * @return {Connection[]}
     */
    value: function connections() {
      return Array.from(this.s.servers.values()).reduce(function (result, server) {
        return result.concat(server.s.pool.allConnections());
      }, []);
    }
    /**
     * Initiate server connect
     *
     * @param {Object} [options] Optional settings
     * @param {Array} [options.auth=null] Array of auth options to apply on connect
     */

  }, {
    key: "connect",
    value: function connect()
    /* options */
    {
      // emit SDAM monitoring events
      this.emit('topologyOpening', new monitoring.TopologyOpeningEvent(this.s.id)); // emit an event for the topology change

      this.emit('topologyDescriptionChanged', new monitoring.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown), // initial is always Unknown
      this.s.description));
      connectServers(this, Array.from(this.s.description.servers.values()));
      this.s.connected = true;
    }
    /**
     * Close this topology
     */

  }, {
    key: "close",
    value: function close(callback) {
      // destroy all child servers
      this.s.servers.forEach(function (server) {
        return server.destroy();
      }); // emit an event for close

      this.emit('topologyClosed', new monitoring.TopologyClosedEvent(this.s.id));
      this.s.connected = false;

      if (typeof callback === 'function') {
        callback(null, null);
      }
    }
    /**
     * Selects a server according to the selection predicate provided
     *
     * @param {function} [selector] An optional selector to select servers by, defaults to a random selection within a latency window
     * @return {Server} An instance of a `Server` meeting the criteria of the predicate provided
     */

  }, {
    key: "selectServer",
    value: function selectServer(selector, options, callback) {
      if (typeof options === 'function') callback = options, options = {};
      options = Object.assign({}, {
        serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS
      }, options);
      selectServers(this, selector, options.serverSelectionTimeoutMS, process.hrtime(), function (err, servers) {
        if (err) return callback(err, null);
        callback(null, randomSelection(servers));
      });
    }
    /**
     * Update the internal TopologyDescription with a ServerDescription
     *
     * @param {object} serverDescription The server to update in the internal list of server descriptions
     */

  }, {
    key: "serverUpdateHandler",
    value: function serverUpdateHandler(serverDescription) {
      if (!this.s.description.hasServer(serverDescription.address)) {
        return;
      } // these will be used for monitoring events later


      var previousTopologyDescription = this.s.description;
      var previousServerDescription = this.s.description.servers.get(serverDescription.address); // first update the TopologyDescription

      this.s.description = this.s.description.update(serverDescription); // emit monitoring events for this change

      this.emit('serverDescriptionChanged', new monitoring.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address))); // update server list from updated descriptions

      updateServers(this, serverDescription);
      this.emit('topologyDescriptionChanged', new monitoring.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
    }
    /**
     * Authenticate using a specified mechanism
     *
     * @param {String} mechanism The auth mechanism used for authentication
     * @param {String} db The db we are authenticating against
     * @param {Object} options Optional settings for the authenticating mechanism
     * @param {authResultCallback} callback A callback function
     */

  }, {
    key: "auth",
    value: function auth(mechanism, db, options, callback) {
      callback(null, null);
    }
    /**
     * Logout from a database
     *
     * @param {String} db The db we are logging out from
     * @param {authResultCallback} callback A callback function
     */

  }, {
    key: "logout",
    value: function logout(db, callback) {
      callback(null, null);
    } // Basic operation support. Eventually this should be moved into command construction
    // during the command refactor.

    /**
     * Insert one or more documents
     *
     * @param {String} ns The full qualified namespace for this operation
     * @param {Array} ops An array of documents to insert
     * @param {Boolean} [options.ordered=true] Execute in order or out of order
     * @param {Object} [options.writeConcern] Write concern for the operation
     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized
     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields
     * @param {ClientSession} [options.session] Session to use for the operation
     * @param {boolean} [options.retryWrites] Enable retryable writes for this operation
     * @param {opResultCallback} callback A callback function
     */

  }, {
    key: "insert",
    value: function insert(ns, ops, options, callback) {
      executeWriteOperation({
        topology: this,
        op: 'insert',
        ns: ns,
        ops: ops
      }, options, callback);
    }
    /**
     * Perform one or more update operations
     *
     * @param {string} ns The fully qualified namespace for this operation
     * @param {array} ops An array of updates
     * @param {boolean} [options.ordered=true] Execute in order or out of order
     * @param {object} [options.writeConcern] Write concern for the operation
     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized
     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields
     * @param {ClientSession} [options.session] Session to use for the operation
     * @param {boolean} [options.retryWrites] Enable retryable writes for this operation
     * @param {opResultCallback} callback A callback function
     */

  }, {
    key: "update",
    value: function update(ns, ops, options, callback) {
      executeWriteOperation({
        topology: this,
        op: 'update',
        ns: ns,
        ops: ops
      }, options, callback);
    }
    /**
     * Perform one or more remove operations
     *
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {array} ops An array of removes
     * @param {boolean} [options.ordered=true] Execute in order or out of order
     * @param {object} [options.writeConcern={}] Write concern for the operation
     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
     * @param {ClientSession} [options.session=null] Session to use for the operation
     * @param {boolean} [options.retryWrites] Enable retryable writes for this operation
     * @param {opResultCallback} callback A callback function
     */

  }, {
    key: "remove",
    value: function remove(ns, ops, options, callback) {
      executeWriteOperation({
        topology: this,
        op: 'remove',
        ns: ns,
        ops: ops
      }, options, callback);
    }
    /**
     * Execute a command
     *
     * @method
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {object} cmd The command hash
     * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
     * @param {Connection} [options.connection] Specify connection object to execute command against
     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
     * @param {ClientSession} [options.session=null] Session to use for the operation
     * @param {opResultCallback} callback A callback function
     */

  }, {
    key: "command",
    value: function command(ns, cmd, options, callback) {
      if (typeof options === 'function') {
        callback = options, options = {}, options = options || {};
      }

      var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;
      this.selectServer(readPreferenceServerSelector(readPreference), function (err, server) {
        if (err) {
          callback(err, null);
          return;
        }

        server.command(ns, cmd, options, callback);
      });
    }
    /**
     * Create a new cursor
     *
     * @method
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId
     * @param {object} [options] Options for the cursor
     * @param {object} [options.batchSize=0] Batchsize for the operation
     * @param {array} [options.documents=[]] Initial documents list for cursor
     * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
     * @param {ClientSession} [options.session=null] Session to use for the operation
     * @param {object} [options.topology] The internal topology of the created cursor
     * @returns {Cursor}
     */

  }, {
    key: "cursor",
    value: function cursor(ns, cmd, options) {
      options = options || {};
      var topology = options.topology || this;
      var CursorClass = options.cursorFactory || this.s.Cursor;
      return new CursorClass(this.s.bson, ns, cmd, options, topology, this.s.options);
    }
  }, {
    key: "description",
    get: function get() {
      return this.s.description;
    }
  }]);

  return Topology;
}(EventEmitter); // legacy aliases


Topology.prototype.destroy = deprecate(Topology.prototype.close, 'destroy() is deprecated, please use close() instead');

function topologyTypeFromSeedlist(seedlist, options) {
  if (seedlist.length === 1 && !options.replicaSet) return TopologyType.Single;
  if (options.replicaSet) return TopologyType.ReplicaSetNoPrimary;
  return TopologyType.Unknown;
}

function randomSelection(array) {
  return array[Math.floor(Math.random() * array.length)];
}
/**
 * Selects servers using the provided selector
 *
 * @private
 * @param {Topology} topology The topology to select servers from
 * @param {function} selector The actual predicate used for selecting servers
 * @param {Number} timeout The max time we are willing wait for selection
 * @param {Number} start A high precision timestamp for the start of the selection process
 * @param {function} callback The callback used to convey errors or the resultant servers
 */


function selectServers(topology, selector, timeout, start, callback) {
  var serverDescriptions = Array.from(topology.description.servers.values());
  var descriptions;

  try {
    descriptions = selector ? selector(topology.description, serverDescriptions) : serverDescriptions;
  } catch (e) {
    return callback(e, null);
  }

  if (descriptions.length) {
    var servers = descriptions.map(function (description) {
      return topology.s.servers.get(description.address);
    });
    return callback(null, servers);
  }

  var duration = calculateDurationInMs(start);

  if (duration >= timeout) {
    return callback(new MongoTimeoutError("Server selection timed out after ".concat(timeout, " ms")));
  }

  var retrySelection = function retrySelection() {
    // ensure all server monitors attempt monitoring immediately
    topology.s.servers.forEach(function (server) {
      return server.monitor();
    });
    var iterationTimer = setTimeout(function () {
      callback(new MongoTimeoutError('Server selection timed out due to monitoring'));
    }, topology.s.minHeartbeatIntervalMS);
    topology.once('topologyDescriptionChanged', function () {
      // successful iteration, clear the check timer
      clearTimeout(iterationTimer); // topology description has changed due to monitoring, reattempt server selection

      selectServers(topology, selector, timeout, start, callback);
    });
  }; // ensure we are connected


  if (!topology.s.connected) {
    topology.connect(); // we want to make sure we're still within the requested timeout window

    var failToConnectTimer = setTimeout(function () {
      callback(new MongoTimeoutError('Server selection timed out waiting to connect'));
    }, timeout - duration);
    topology.once('connect', function () {
      clearTimeout(failToConnectTimer);
      retrySelection();
    });
    return;
  }

  retrySelection();
}
/**
 * Create `Server` instances for all initially known servers, connect them, and assign
 * them to the passed in `Topology`.
 *
 * @param {Topology} topology The topology responsible for the servers
 * @param {ServerDescription[]} serverDescriptions A list of server descriptions to connect
 */


function connectServers(topology, serverDescriptions) {
  topology.s.servers = serverDescriptions.reduce(function (servers, serverDescription) {
    // publish an open event for each ServerDescription created
    topology.emit('serverOpening', new monitoring.ServerOpeningEvent(topology.s.id, serverDescription.address));
    var server = new Server(serverDescription, topology.s.options);
    relayEvents(server, topology, ['serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed']);
    server.on('descriptionReceived', topology.serverUpdateHandler.bind(topology));
    server.on('connect', serverConnectEventHandler(server, topology));
    servers.set(serverDescription.address, server);
    server.connect();
    return servers;
  }, new Map());
}

function updateServers(topology, currentServerDescription) {
  // update the internal server's description
  if (topology.s.servers.has(currentServerDescription.address)) {
    var server = topology.s.servers.get(currentServerDescription.address);
    server.s.description = currentServerDescription;
  } // add new servers for all descriptions we currently don't know about locally


  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = topology.description.servers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var serverDescription = _step.value;

      if (!topology.s.servers.has(serverDescription.address)) {
        topology.emit('serverOpening', new monitoring.ServerOpeningEvent(topology.s.id, serverDescription.address));

        var _server = new Server(serverDescription, topology.s.options);

        relayEvents(_server, topology, ['serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed']);

        _server.on('descriptionReceived', topology.serverUpdateHandler.bind(topology));

        _server.on('connect', serverConnectEventHandler(_server, topology));

        topology.s.servers.set(serverDescription.address, _server);

        _server.connect();
      }
    } // for all servers no longer known, remove their descriptions and destroy their instances

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    var _loop = function _loop() {
      var entry = _step2.value;
      var serverAddress = entry[0];

      if (topology.description.hasServer(serverAddress)) {
        return "continue";
      }

      var server = topology.s.servers.get(serverAddress);
      topology.s.servers["delete"](serverAddress);
      server.destroy(function () {
        return topology.emit('serverClosed', new monitoring.ServerClosedEvent(topology.s.id, serverAddress));
      });
    };

    for (var _iterator2 = topology.s.servers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

function serverConnectEventHandler(server, topology) {
  return function ()
  /* ismaster */
  {
    topology.emit('connect', topology);
  };
}

function executeWriteOperation(args, options, callback) {
  if (typeof options === 'function') callback = options, options = {};
  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.

  var topology = args.topology;
  var op = args.op;
  var ns = args.ns;
  var ops = args.ops;
  var willRetryWrite = !args.retrying && options.retryWrites && options.session && isRetryableWritesSupported(topology) && !options.session.inTransaction();
  topology.selectServer(writableServerSelector(), function (err, server) {
    if (err) {
      callback(err, null);
      return;
    }

    var handler = function handler(err, result) {
      if (!err) return callback(null, result);

      if (!(err instanceof MongoNetworkError) && !err.message.match(/not master/)) {
        return callback(err);
      }

      if (willRetryWrite) {
        var newArgs = Object.assign({}, args, {
          retrying: true
        });
        return executeWriteOperation(newArgs, options, callback);
      }

      return callback(err);
    };

    if (callback.operationId) {
      handler.operationId = callback.operationId;
    } // increment and assign txnNumber


    if (willRetryWrite) {
      options.session.incrementTransactionNumber();
      options.willRetryWrite = willRetryWrite;
    } // execute the write operation


    server[op](ns, ops, options, handler); // we need to increment the statement id if we're in a transaction

    if (options.session && options.session.inTransaction()) {
      options.session.incrementStatementId(ops.length);
    }
  });
}
/**
 * A server opening SDAM monitoring event
 *
 * @event Topology#serverOpening
 * @type {ServerOpeningEvent}
 */

/**
 * A server closed SDAM monitoring event
 *
 * @event Topology#serverClosed
 * @type {ServerClosedEvent}
 */

/**
 * A server description SDAM change monitoring event
 *
 * @event Topology#serverDescriptionChanged
 * @type {ServerDescriptionChangedEvent}
 */

/**
 * A topology open SDAM event
 *
 * @event Topology#topologyOpening
 * @type {TopologyOpeningEvent}
 */

/**
 * A topology closed SDAM event
 *
 * @event Topology#topologyClosed
 * @type {TopologyClosedEvent}
 */

/**
 * A topology structure SDAM change event
 *
 * @event Topology#topologyDescriptionChanged
 * @type {TopologyDescriptionChangedEvent}
 */

/**
 * A topology serverHeartbeatStarted SDAM event
 *
 * @event Topology#serverHeartbeatStarted
 * @type {ServerHeartbeatStartedEvent}
 */

/**
 * A topology serverHeartbeatFailed SDAM event
 *
 * @event Topology#serverHeartbeatFailed
 * @type {ServerHearbeatFailedEvent}
 */

/**
 * A topology serverHeartbeatSucceeded SDAM change event
 *
 * @event Topology#serverHeartbeatSucceeded
 * @type {ServerHeartbeatSucceededEvent}
 */


module.exports = Topology;