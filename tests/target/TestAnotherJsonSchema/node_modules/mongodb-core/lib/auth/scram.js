'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var f = require('util').format,
    crypto = require('crypto'),
    retrieveBSON = require('../connection/utils').retrieveBSON,
    Query = require('../connection/commands').Query,
    MongoError = require('../error').MongoError,
    Buffer = require('safe-buffer').Buffer;

var saslprep;

try {
  saslprep = require('saslprep');
} catch (e) {// don't do anything;
}

var BSON = retrieveBSON(),
    Binary = BSON.Binary;

var AuthSession = function AuthSession(db, username, password) {
  this.db = db;
  this.username = username;
  this.password = password;
};

AuthSession.prototype.equal = function (session) {
  return session.db === this.db && session.username === this.username && session.password === this.password;
};

var id = 0;
/**
 * Creates a new ScramSHA authentication mechanism
 * @class
 * @return {ScramSHA} A cursor instance
 */

var ScramSHA = function ScramSHA(bson, cryptoMethod) {
  this.bson = bson;
  this.authStore = [];
  this.id = id++;
  this.cryptoMethod = cryptoMethod || 'sha1';
};

var parsePayload = function parsePayload(payload) {
  var dict = {};
  var parts = payload.split(',');

  for (var i = 0; i < parts.length; i++) {
    var valueParts = parts[i].split('=');
    dict[valueParts[0]] = valueParts[1];
  }

  return dict;
};

var passwordDigest = function passwordDigest(username, password) {
  if (typeof username !== 'string') throw new MongoError('username must be a string');
  if (typeof password !== 'string') throw new MongoError('password must be a string');
  if (password.length === 0) throw new MongoError('password cannot be empty'); // Use node md5 generator

  var md5 = crypto.createHash('md5'); // Generate keys used for authentication

  md5.update(username + ':mongo:' + password, 'utf8');
  return md5.digest('hex');
}; // XOR two buffers


function xor(a, b) {
  if (!Buffer.isBuffer(a)) a = Buffer.from(a);
  if (!Buffer.isBuffer(b)) b = Buffer.from(b);
  var length = Math.max(a.length, b.length);
  var res = [];

  for (var i = 0; i < length; i += 1) {
    res.push(a[i] ^ b[i]);
  }

  return Buffer.from(res).toString('base64');
}

function H(method, text) {
  return crypto.createHash(method).update(text).digest();
}

function HMAC(method, key, text) {
  return crypto.createHmac(method, key).update(text).digest();
}

var _hiCache = {};
var _hiCacheCount = 0;

var _hiCachePurge = function _hiCachePurge() {
  _hiCache = {};
  _hiCacheCount = 0;
};

var hiLengthMap = {
  sha256: 32,
  sha1: 20
};

function HI(data, salt, iterations, cryptoMethod) {
  // omit the work if already generated
  var key = [data, salt.toString('base64'), iterations].join('_');

  if (_hiCache[key] !== undefined) {
    return _hiCache[key];
  } // generate the salt


  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth

  if (_hiCacheCount >= 200) {
    _hiCachePurge();
  }

  _hiCache[key] = saltedData;
  _hiCacheCount += 1;
  return saltedData;
}
/**
 * Authenticate
 * @method
 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
 * @param {[]Connections} connections Connections to authenticate using this authenticator
 * @param {string} db Name of the database
 * @param {string} username Username
 * @param {string} password Password
 * @param {authResultCallback} callback The callback to return the result from the authentication
 * @return {object}
 */


ScramSHA.prototype.auth = function (server, connections, db, username, password, callback) {
  var self = this; // Total connections

  var count = connections.length;
  if (count === 0) return callback(null, null); // Valid connections

  var numberOfValidConnections = 0;
  var errorObject = null;
  var cryptoMethod = this.cryptoMethod;
  var mechanism = 'SCRAM-SHA-1';
  var processedPassword;

  if (cryptoMethod === 'sha256') {
    mechanism = 'SCRAM-SHA-256';
    var saslprepFn = server.s && server.s.saslprep || saslprep;

    if (saslprepFn) {
      processedPassword = saslprepFn(password);
    } else {
      console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');
      processedPassword = password;
    }
  } else {
    processedPassword = passwordDigest(username, password);
  } // Execute MongoCR


  var executeScram = function executeScram(connection) {
    // Clean up the user
    username = username.replace('=', '=3D').replace(',', '=2C'); // Create a random nonce

    var nonce = crypto.randomBytes(24).toString('base64'); // var nonce = 'MsQUY9iw0T9fx2MUEz6LZPwGuhVvWAhc'
    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
    // Since the username is not sasl-prep-d, we need to do this here.

    var firstBare = Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce, 'utf8')]); // Build command structure

    var cmd = {
      saslStart: 1,
      mechanism: mechanism,
      payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),
      autoAuthorize: 1
    }; // Handle the error

    var handleError = function handleError(err, r) {
      if (err) {
        numberOfValidConnections = numberOfValidConnections - 1;
        errorObject = err;
        return false;
      } else if (r.result['$err']) {
        errorObject = r.result;
        return false;
      } else if (r.result['errmsg']) {
        errorObject = r.result;
        return false;
      } else {
        numberOfValidConnections = numberOfValidConnections + 1;
      }

      return true;
    }; // Finish up


    var finish = function finish(_count, _numberOfValidConnections) {
      if (_count === 0 && _numberOfValidConnections > 0) {
        // Store the auth details
        addAuthSession(self.authStore, new AuthSession(db, username, password)); // Return correct authentication

        return callback(null, true);
      } else if (_count === 0) {
        if (errorObject == null) errorObject = new MongoError(f('failed to authenticate using scram'));
        return callback(errorObject, false);
      }
    };

    var handleEnd = function handleEnd(_err, _r) {
      // Handle any error
      handleError(_err, _r); // Adjust the number of connections

      count = count - 1; // Execute the finish

      finish(count, numberOfValidConnections);
    }; // Write the commmand on the connection


    server(connection, new Query(self.bson, f('%s.$cmd', db), cmd, {
      numberToSkip: 0,
      numberToReturn: 1
    }), function (err, r) {
      // Do we have an error, handle it
      if (handleError(err, r) === false) {
        count = count - 1;

        if (count === 0 && numberOfValidConnections > 0) {
          // Store the auth details
          addAuthSession(self.authStore, new AuthSession(db, username, password)); // Return correct authentication

          return callback(null, true);
        } else if (count === 0) {
          if (errorObject == null) errorObject = new MongoError(f('failed to authenticate using scram'));
          return callback(errorObject, false);
        }

        return;
      } // Get the dictionary


      var dict = parsePayload(r.result.payload.value()); // Unpack dictionary

      var iterations = parseInt(dict.i, 10);
      var salt = dict.s;
      var rnonce = dict.r; // Set up start of proof

      var withoutProof = f('c=biws,r=%s', rnonce);
      var saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);

      if (iterations && iterations < 4096) {
        var error = new MongoError("Server returned an invalid iteration count ".concat(iterations));
        return callback(error, false);
      } // Create the client key


      var clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key'); // Create the stored key

      var storedKey = H(cryptoMethod, clientKey); // Create the authentication message

      var authMessage = [firstBare, r.result.payload.value().toString('base64'), withoutProof].join(','); // Create client signature

      var clientSignature = HMAC(cryptoMethod, storedKey, authMessage); // Create client proof

      var clientProof = f('p=%s', xor(clientKey, clientSignature)); // Create client final

      var clientFinal = [withoutProof, clientProof].join(','); // Create continue message

      var cmd = {
        saslContinue: 1,
        conversationId: r.result.conversationId,
        payload: new Binary(Buffer.from(clientFinal))
      }; //
      // Execute sasl continue
      // Write the commmand on the connection

      server(connection, new Query(self.bson, f('%s.$cmd', db), cmd, {
        numberToSkip: 0,
        numberToReturn: 1
      }), function (err, r) {
        if (r && r.result.done === false) {
          var cmd = {
            saslContinue: 1,
            conversationId: r.result.conversationId,
            payload: Buffer.alloc(0)
          }; // Write the commmand on the connection

          server(connection, new Query(self.bson, f('%s.$cmd', db), cmd, {
            numberToSkip: 0,
            numberToReturn: 1
          }), function (err, r) {
            handleEnd(err, r);
          });
        } else {
          handleEnd(err, r);
        }
      });
    });
  };

  var _execute = function _execute(_connection) {
    process.nextTick(function () {
      executeScram(_connection);
    });
  }; // For each connection we need to authenticate


  while (connections.length > 0) {
    _execute(connections.shift());
  }
}; // Add to store only if it does not exist


var addAuthSession = function addAuthSession(authStore, session) {
  var found = false;

  for (var i = 0; i < authStore.length; i++) {
    if (authStore[i].equal(session)) {
      found = true;
      break;
    }
  }

  if (!found) authStore.push(session);
};
/**
 * Remove authStore credentials
 * @method
 * @param {string} db Name of database we are removing authStore details about
 * @return {object}
 */


ScramSHA.prototype.logout = function (dbName) {
  this.authStore = this.authStore.filter(function (x) {
    return x.db !== dbName;
  });
};
/**
 * Re authenticate pool
 * @method
 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
 * @param {[]Connections} connections Connections to authenticate using this authenticator
 * @param {authResultCallback} callback The callback to return the result from the authentication
 * @return {object}
 */


ScramSHA.prototype.reauthenticate = function (server, connections, callback) {
  var authStore = this.authStore.slice(0);
  var count = authStore.length; // No connections

  if (count === 0) return callback(null, null); // Iterate over all the auth details stored

  for (var i = 0; i < authStore.length; i++) {
    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function (err) {
      count = count - 1; // Done re-authenticating

      if (count === 0) {
        callback(err, null);
      }
    });
  }
};

var ScramSHA1 =
/*#__PURE__*/
function (_ScramSHA) {
  _inherits(ScramSHA1, _ScramSHA);

  function ScramSHA1(bson) {
    _classCallCheck(this, ScramSHA1);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA1).call(this, bson, 'sha1'));
  }

  return ScramSHA1;
}(ScramSHA);

var ScramSHA256 =
/*#__PURE__*/
function (_ScramSHA2) {
  _inherits(ScramSHA256, _ScramSHA2);

  function ScramSHA256(bson) {
    _classCallCheck(this, ScramSHA256);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA256).call(this, bson, 'sha256'));
  }

  return ScramSHA256;
}(ScramSHA);

module.exports = {
  ScramSHA1: ScramSHA1,
  ScramSHA256: ScramSHA256
};