'use strict';

require("core-js/modules/es.symbol");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.object.define-properties");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-own-property-descriptor");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.for-each");

require("regenerator-runtime/runtime");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('util'),
    promisify = _require.promisify;

var path = require('path');

var fs = require('graceful-fs');

var writeFileAtomic = require('write-file-atomic');

var sortKeys = require('sort-keys');

var makeDir = require('make-dir');

var detectIndent = require('detect-indent');

var isPlainObj = require('is-plain-obj');

var readFile = promisify(fs.readFile);

var hasTrailingNewline = function hasTrailingNewline(file) {
  return /\n$/.test(file);
};

var init = function init(fn, filePath, data, options) {
  if (!filePath) {
    throw new TypeError('Expected a filepath');
  }

  if (data === undefined) {
    throw new TypeError('Expected data to stringify');
  }

  options = _objectSpread({
    indent: '\t',
    sortKeys: false
  }, options);

  if (options.sortKeys && isPlainObj(data)) {
    data = sortKeys(data, {
      deep: true,
      compare: typeof options.sortKeys === 'function' ? options.sortKeys : undefined
    });
  }

  return fn(filePath, data, options);
};

var main = function main(filePath, data, options) {
  var indent, trailingNewline, file, json;
  return regeneratorRuntime.async(function main$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          indent = options.indent;
          trailingNewline = '\n';
          _context.prev = 2;
          _context.next = 5;
          return regeneratorRuntime.awrap(readFile(filePath, 'utf8'));

        case 5:
          file = _context.sent;

          if (!hasTrailingNewline(file)) {
            trailingNewline = '';
          }

          if (options.detectIndent) {
            indent = detectIndent(file).indent;
          }

          _context.next = 14;
          break;

        case 10:
          _context.prev = 10;
          _context.t0 = _context["catch"](2);

          if (!(_context.t0.code !== 'ENOENT')) {
            _context.next = 14;
            break;
          }

          throw _context.t0;

        case 14:
          json = JSON.stringify(data, options.replacer, indent);
          return _context.abrupt("return", writeFileAtomic(filePath, "".concat(json).concat(trailingNewline), {
            mode: options.mode
          }));

        case 16:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[2, 10]]);
};

var mainSync = function mainSync(filePath, data, options) {
  var indent = options.indent;
  var trailingNewline = '\n';

  try {
    var file = fs.readFileSync(filePath, 'utf8');

    if (!hasTrailingNewline(file)) {
      trailingNewline = '';
    }

    if (options.detectIndent) {
      indent = detectIndent(file).indent;
    }
  } catch (error) {
    if (error.code !== 'ENOENT') {
      throw error;
    }
  }

  var json = JSON.stringify(data, options.replacer, indent);
  return writeFileAtomic.sync(filePath, "".concat(json).concat(trailingNewline), {
    mode: options.mode
  });
};

module.exports = function _callee(filePath, data, options) {
  return regeneratorRuntime.async(function _callee$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return regeneratorRuntime.awrap(makeDir(path.dirname(filePath), {
            fs: fs
          }));

        case 2:
          return _context2.abrupt("return", init(main, filePath, data, options));

        case 3:
        case "end":
          return _context2.stop();
      }
    }
  });
};

module.exports.sync = function (filePath, data, options) {
  makeDir.sync(path.dirname(filePath), {
    fs: fs
  });
  init(mainSync, filePath, data, options);
};