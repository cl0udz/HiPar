'use strict'; // Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.map");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.repeat");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var INDENT_REGEX = /^(?:( )+|\t+)/;

function getMostUsed(indents) {
  var result = 0;
  var maxUsed = 0;
  var maxWeight = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = indents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2),
          key = _step$value[0],
          _step$value$ = _slicedToArray(_step$value[1], 2),
          usedCount = _step$value$[0],
          weight = _step$value$[1];

      if (usedCount > maxUsed || usedCount === maxUsed && weight > maxWeight) {
        maxUsed = usedCount;
        maxWeight = weight;
        result = key;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

module.exports = function (string) {
  if (typeof string !== 'string') {
    throw new TypeError('Expected a string');
  } // Remember the size of previous line's indentation


  var previousSize = 0;
  var previousIndentType; // Indents key (ident type + size of the indents/unindents)

  var key; // Remember how many indents/unindents have occurred for a given size and how many lines follow a given indentation.
  // The key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.
  //
  // indents = {
  //    t3: [1, 0],
  //    t4: [1, 5],
  //    s5: [1, 0],
  //   s12: [1, 0],
  // }

  var indents = new Map();
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = string.split(/\n/g)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var line = _step2.value;

      if (!line) {
        // Ignore empty lines
        continue;
      }

      var _indent = void 0;

      var indentType = void 0;
      var weight = void 0;
      var entry = void 0;
      var matches = line.match(INDENT_REGEX);

      if (matches === null) {
        previousSize = 0;
        previousIndentType = '';
      } else {
        _indent = matches[0].length;

        if (matches[1]) {
          indentType = 's';
        } else {
          indentType = 't';
        }

        if (indentType !== previousIndentType) {
          previousSize = 0;
        }

        previousIndentType = indentType;
        weight = 0;
        var indentDifference = _indent - previousSize;
        previousSize = _indent; // Previous line have same indent?

        if (indentDifference === 0) {
          weight++; // We use the key from previous loop
        } else {
          key = indentType + String(indentDifference > 0 ? indentDifference : -indentDifference);
        } // Update the stats


        entry = indents.get(key);

        if (entry === undefined) {
          entry = [1, 0]; // Init
        } else {
          entry = [++entry[0], entry[1] + weight];
        }

        indents.set(key, entry);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var result = getMostUsed(indents);
  var amount = 0;
  var type;
  var indent = '';

  if (result !== 0) {
    amount = Number(result.slice(1));

    if (result[0] === 's') {
      type = 'space';
      indent = ' '.repeat(amount);
    } else {
      type = 'tab';
      indent = '\t'.repeat(amount);
    }
  }

  return {
    amount: amount,
    type: type,
    indent: indent
  };
};