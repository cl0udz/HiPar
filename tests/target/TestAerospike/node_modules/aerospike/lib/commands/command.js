// *****************************************************************************
// Copyright 2013-2019 Aerospike, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// *****************************************************************************
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AerospikeError = require('../error'); // Command is an abstract template (aka "mix-in") for concrete command
// subclasses, that execute a specific database command method on the native
// Aerospike add-on. A concrete command subclass should be defined like this,
// where "getAsync" is the native command method to call:
//
//   class GetCommand extends Command("getAsync") {
//       // ...
//   }

/**
 * @class Command
 * @classdesc Database command.
 */


module.exports = function (_asCommand) {
  return (
    /*#__PURE__*/
    function () {
      /** @private */
      function Command(client, args, callback) {
        _classCallCheck(this, Command);

        /**
         * Client instance used to execute this command.
         *
         * @name Command#client
         * @type {Client}
         * @readonly
         */
        this.client = client;
        /** @private */

        this.args = args;

        if (callback) {
          /** @private */
          this.callback = callback;
        }
        /**
         * Whether debug stacktraces are enabled.
         *
         * @name Command#captureStackTraces
         * @type {boolean}
         * @readonly
         * @see {@link Client#captureStackTraces}
         */


        this.captureStackTraces = client.captureStackTraces;
        /**
         * The record key for which the command was issued. (Single-key commands only.)
         *
         * @name Command#key
         * @type {?Key}
         * @readonly
         */

        this.key = undefined;
        this.ensureConnected = true;
      }
      /** @private */


      _createClass(Command, [{
        key: "captureStackTrace",
        value: function captureStackTrace() {
          if (this.captureStackTraces) {
            AerospikeError.captureStackTrace(this, this.captureStackTrace); // this.startTime = process.hrtime()
          }
        }
        /** @private */

      }, {
        key: "connected",
        value: function connected() {
          return this.client.isConnected(false);
        }
        /** @private */

      }, {
        key: "convertError",
        value: function convertError(error) {
          return AerospikeError.fromASError(error, this);
        }
        /** @private */

      }, {
        key: "convertResult",
        value: function convertResult(arg1, arg2, arg3) {
          return arg1;
        }
        /** @private */

      }, {
        key: "convertResponse",
        value: function convertResponse(err, arg1, arg2, arg3) {
          var error = this.convertError(err);
          var result = this.convertResult(arg1, arg2, arg3);
          return [error, result];
        }
        /** @private */

      }, {
        key: "execute",
        value: function execute() {
          if (this.ensureConnected && !this.connected()) {
            return this.sendError('Not connected.');
          }

          this.captureStackTrace();

          if (this.expectsPromise()) {
            return this.executeAndReturnPromise();
          } else {
            return this.executeWithCallback(this.callback.bind(this));
          }
        }
        /** @private */

      }, {
        key: "executeWithCallback",
        value: function executeWithCallback(callback) {
          // C client will call the callback function synchronously under certain error
          // conditions; if we detect a synchronous callback we need to schedule the JS
          // callback to be called asynchronously anyway.
          var sync = true;
          this.process(function (error, result) {
            if (sync) {
              process.nextTick(callback, error, result);
            } else {
              return callback(error, result);
            }
          });
          sync = false; // if we get here before the cb was called the cb is async
        }
        /** @private */

      }, {
        key: "executeAndReturnPromise",
        value: function executeAndReturnPromise() {
          var _this = this;

          return new Promise(function (resolve, reject) {
            _this.process(function (error, result) {
              if (error) {
                reject(error);
              } else {
                resolve(result);
              }
            });
          });
        }
        /** @private */

      }, {
        key: "expectsPromise",
        value: function expectsPromise() {
          return !this.callback;
        }
        /** @private */

      }, {
        key: "asCommand",
        value: function asCommand() {
          return _asCommand;
        }
        /** @private */

      }, {
        key: "process",
        value: function process(cb) {
          var _this2 = this;

          var asCallback = function asCallback(err, arg1, arg2, arg3) {
            var tmp = _this2.convertResponse(err, arg1, arg2, arg3);

            var error = tmp[0];
            var result = tmp[1];
            return cb(error, result);
          };

          var asArgs = this.args.concat([asCallback]);
          this.client.asExec(this.asCommand(), asArgs);
        }
        /** @private */

      }, {
        key: "sendError",
        value: function sendError(message) {
          var error = new AerospikeError(message, this);

          if (this.expectsPromise()) {
            return Promise.reject(error);
          } else {
            process.nextTick(this.callback, error);
          }
        }
      }]);

      return Command;
    }()
  );
};