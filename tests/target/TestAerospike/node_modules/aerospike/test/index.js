// *****************************************************************************
// Copyright 2013-2019 Aerospike, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// *****************************************************************************
'use strict';
/* eslint-env mocha */

/* global expect */

var Aerospike = require('../lib/aerospike');

var Job = require('../lib/job');

var IndexJob = require('../lib/index_job');

var helper = require('./test_helper');

context('secondary indexes', function () {
  var client = helper.client; // generate unique index name for each test

  var testIndex = {
    name: null,
    bin: null,
    counter: 0
  };
  beforeEach(function () {
    testIndex.counter++;
    testIndex.name = 'idx-' + testIndex.counter + '-' + Math.floor(Math.random() * 10000000);
    testIndex.bin = 'bin-' + testIndex.counter + '-' + Math.floor(Math.random() * 10000000);
  });

  function verifyIndexExists(namespace, indexName) {
    var sindex = 'sindex/' + namespace + '/' + indexName;

    var checkStatus = function checkStatus() {
      return client.infoAll(sindex).then(function () {
        return true;
      })["catch"](function (error) {
        if (error.code !== Aerospike.status.ERR_INDEX_NOT_FOUND) {
          return Promise.reject(error);
        }

        return false;
      });
    };

    return Job.pollUntilDone(checkStatus, 10).then(function () {
      return helper.index.remove(indexName);
    });
  }

  describe('Client#indexCreate()', function () {
    it('returns an IndexJob instance', function () {
      var options = {
        ns: helper.namespace,
        set: helper.set,
        bin: testIndex.bin,
        index: testIndex.name,
        datatype: Aerospike.indexDataType.NUMERIC
      };
      return client.createIndex(options).then(function (job) {
        return expect(job).to.be["instanceof"](IndexJob);
      }).then(function () {
        return verifyIndexExists(helper.namespace, testIndex.name);
      });
    });
    it('should create a complex index on list', function () {
      var options = {
        ns: helper.namespace,
        set: helper.set,
        bin: testIndex.bin,
        index: testIndex.name,
        type: Aerospike.indexType.LIST,
        datatype: Aerospike.indexDataType.NUMERIC
      };
      return client.createIndex(options).then(function () {
        return verifyIndexExists(helper.namespace, testIndex.name);
      });
    });
    it('should create an integer index with info policy', function () {
      var options = {
        ns: helper.namespace,
        set: helper.set,
        bin: testIndex.bin,
        index: testIndex.name,
        datatype: Aerospike.indexDataType.NUMERIC
      };
      var policy = new Aerospike.InfoPolicy({
        totalTimeout: 100
      });
      return client.createIndex(options, policy).then(function () {
        return verifyIndexExists(helper.namespace, testIndex.name);
      });
    });
    it('re-creating an index with identical options returns an error', function () {
      var options = {
        ns: helper.namespace,
        set: helper.set,
        bin: testIndex.bin,
        index: testIndex.name,
        datatype: Aerospike.indexDataType.NUMERIC
      };
      return client.createIndex(options).then(function (job) {
        return job.wait(10);
      }).then(function () {
        return client.createIndex(options).then(function (job) {
          return Promise.reject(new Error('Recreating existing index should have returned an error'));
        })["catch"](function (error) {
          if (error.code === Aerospike.status.ERR_INDEX_FOUND) {// All good!
          } else {
            return Promise.reject(error);
          }
        });
      });
    });
  });
  describe('Client#createIntegerIndex()', function () {
    it('should create an integer index', function () {
      var options = {
        ns: helper.namespace,
        set: helper.set,
        bin: testIndex.bin,
        index: testIndex.name
      };
      return client.createIntegerIndex(options).then(function () {
        return verifyIndexExists(helper.namespace, testIndex.name);
      });
    });
  });
  describe('Client#createStringIndex()', function () {
    it('should create an string index', function () {
      var args = {
        ns: helper.namespace,
        set: helper.set,
        bin: testIndex.bin,
        index: testIndex.name
      };
      return client.createStringIndex(args).then(function () {
        return verifyIndexExists(helper.namespace, testIndex.name);
      });
    });
  });
  describe('Client#createGeo2DSphereIndex()', function () {
    it('should create a geospatial index', function () {
      var args = {
        ns: helper.namespace,
        set: helper.set,
        bin: testIndex.bin,
        index: testIndex.name
      };
      return client.createGeo2DSphereIndex(args).then(function () {
        return verifyIndexExists(helper.namespace, testIndex.name);
      });
    });
  });
  describe('Client#indexRemove()', function () {
    beforeEach(function () {
      return helper.index.create(testIndex.name, helper.set, testIndex.bin, Aerospike.indexDataType.STRING, Aerospike.indexType.DEFAULT);
    });
    it('should drop an index', function (done) {
      client.indexRemove(helper.namespace, testIndex.name, function (err) {
        expect(err).to.be["null"]();
        done();
      });
    });
    it('should return a Promise if called without callback function', function () {
      return client.indexRemove(helper.namespace, testIndex.name);
    });
  });
});