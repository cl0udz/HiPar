// *****************************************************************************
// Copyright 2013-2019 Aerospike, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// *****************************************************************************
'use strict';
/* eslint-env mocha */

var Aerospike = require('../lib/aerospike');

var helper = require('./test_helper');

var setgen = helper.valgen.string({
  prefix: 'test/trunc/',
  random: true,
  length: {
    min: 6,
    max: 6
  }
});
var keygen = helper.keygen;
var metagen = helper.metagen;
var recgen = helper.recgen;
var putgen = helper.putgen;
describe('client.truncate()', function () {
  helper.skipUnlessVersion('>= 3.12.0', this);
  var client = helper.client; // Generates a number of records; the callback function is called with a list
  // of the record keys.

  function genRecords(kgen, noRecords, done) {
    var mgen = metagen.constant({
      ttl: 300
    });
    var rgen = recgen.constant({
      a: 'foo',
      b: 'bar'
    });
    putgen.put(noRecords, kgen, rgen, mgen).then(done)["catch"](function (err) {
      throw err;
    });
  } // Checks to verify that records that are supposed to have been truncated
  // are gone and that records that are supposed to remain still exist. If some
  // truncated records still exist it will try again every pollInt ms.


  function checkRecords(truncated, remaining, pollInt, done) {
    client.batchRead(truncated.concat(remaining), function (err, results) {
      if (err) throw err;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = results[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var result = _step.value;
          var expectExist = !!remaining.find(function (record) {
            return record.key.equals(result.record.key);
          });

          switch (result.status) {
            case Aerospike.status.OK:
              if (!expectExist) {
                return setTimeout(checkRecords, pollInt, truncated, remaining, pollInt, done);
              }

              break;

            case Aerospike.status.ERR_RECORD_NOT_FOUND:
              if (expectExist) throw new Error("Truncate removed record it wasn't supposed to: " + result.record.key);
              break;

            default:
              throw new Error('Unexpected batchRead status code: ' + result.status);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      done();
    });
  }

  it('deletes all records in the set', function (done) {
    var ns = helper.namespace;
    var set = setgen();
    var noRecords = 5;
    var pollIntMs = 10; // Poll interval in ms to check whether records have been removed

    var kgen = keygen.string(ns, set, {
      prefix: 'test/trunc/',
      random: false
    });
    genRecords(kgen, noRecords, function (records) {
      setTimeout(function () {
        client.truncate(ns, set, 0, function (err) {
          if (err) throw err;
          checkRecords(records, [], pollIntMs, done);
        });
      }, 5);
    });
  });
  it('deletes all records with an older update timestamp', function (done) {
    this.timeout(10000);
    var ns = helper.namespace;
    var set = setgen();
    var noRecordsToDelete = 5;
    var noRecordsToRemain = 2;
    var pollIntMs = 10; // Poll interval in ms to check whether records have been removed

    var allowanceMs = 2000; // Test will fail if client and server clocks differ by more than this many ms!

    var kgen = keygen.string(ns, set, {
      prefix: 'test/trunc/del/',
      random: false
    });
    genRecords(kgen, noRecordsToDelete, function (batchToDelete) {
      setTimeout(function () {
        var timeNanos = new Date().getTime() * 1000000;
        setTimeout(function () {
          var kgen = keygen.string(ns, set, {
            prefix: 'test/trunc/rem/',
            random: false
          });
          genRecords(kgen, noRecordsToRemain, function (batchToRemain) {
            setTimeout(function () {
              client.truncate(ns, set, timeNanos, function (err) {
                if (err) throw err;
                checkRecords(batchToDelete, batchToRemain, pollIntMs, done);
              });
            }, 5);
          });
        }, allowanceMs);
      }, allowanceMs);
    });
  });
});