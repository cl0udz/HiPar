#!/usr/bin/env node
// *****************************************************************************
// Copyright 2013-2019 Aerospike, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// *****************************************************************************
"use strict";

var Aerospike = require('aerospike');

var shared = require('./shared');

shared.runner();

function udfParams(argv) {
  if (!argv.udf) {
    return;
  }

  var udf = {};
  udf.module = argv.udf.shift();
  udf.func = argv.udf.shift();
  udf.args = argv.udf;
  return udf;
}

function buildScanOptions(argv) {
  var options = {
    percent: argv.percent,
    concurrent: argv.concurrent
  };
  var priority;

  switch ((argv.priority || '').toUpperCase()) {
    case 'LOW':
      priority = Aerospike.scanPriority.LOW;
      break;

    case 'MEDIUM':
      priority = Aerospike.scanPriority.MEDIUM;
      break;

    case 'HIGH':
      priority = Aerospike.scanPriority.HIGH;
      break;

    case 'auto':
      priority = Aerospike.scanPriority.AUTO;
      break;
  }

  if (priority) {
    options.priority = priority;
  }

  console.info(options);
  return options;
}

function scan(client, argv) {
  var options, scan, udf;
  return regeneratorRuntime.async(function scan$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = buildScanOptions(argv);
          scan = client.scan(argv.namespace, argv.set, options);

          if (argv.bins) {
            scan.select(argv.bins);
          }

          udf = udfParams(argv);

          if (!(udf && argv.background)) {
            _context.next = 9;
            break;
          }

          _context.next = 7;
          return regeneratorRuntime.awrap(scanBackground(scan, udf));

        case 7:
          _context.next = 11;
          break;

        case 9:
          _context.next = 11;
          return regeneratorRuntime.awrap(scanForeach(scan));

        case 11:
        case "end":
          return _context.stop();
      }
    }
  });
}

function scanForeach(scan) {
  var stream;
  return regeneratorRuntime.async(function scanForeach$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          stream = scan.foreach();
          stream.on('data', shared.cli.printRecord);
          _context2.next = 4;
          return regeneratorRuntime.awrap(shared.streams.consume(stream));

        case 4:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function scanBackground(query, udf) {
  var job;
  return regeneratorRuntime.async(function scanBackground$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(scan.background(udf.module, udf.func, udf.args));

        case 2:
          job = _context3.sent;
          console.info('Running scan in background - Job ID:', job.jobID);

        case 4:
        case "end":
          return _context3.stop();
      }
    }
  });
}

exports.command = 'scan';
exports.describe = 'Execute a scan and print the results';
exports.handler = shared.run(scan);
exports.builder = {
  bins: {
    describe: 'List of bins to fetch for each record',
    type: 'array',
    group: 'Command:'
  },
  priority: {
    describe: 'Scan priority',
    choices: ['auto', 'low', 'medium', 'high'],
    group: 'Command:'
  },
  percent: {
    describe: 'Run scan on given percentage of records',
    type: 'number',
    group: 'Command:',
    "default": 100
  },
  concurrent: {
    describe: 'Scan all cluster nodes in parallel',
    type: 'boolean',
    group: 'Command:',
    "default": true
  },
  udf: {
    desc: 'UDF module, function & arguments to apply to the query',
    group: 'Command:',
    type: 'array'
  },
  background: {
    desc: 'Run the scan in the background (with Record UDF)',
    group: 'Command:',
    type: 'boolean'
  }
};