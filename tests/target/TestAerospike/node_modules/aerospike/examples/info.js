#!/usr/bin/env node
// *****************************************************************************
// Copyright 2013-2019 Aerospike, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// *****************************************************************************
"use strict";

var shared = require('./shared');

shared.runner();

function info(client, argv) {
  var request;
  return regeneratorRuntime.async(function info$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          request = argv.requests.join('\n');

          if (!argv.all) {
            _context.next = 5;
            break;
          }

          return _context.abrupt("return", infoAll(client, request));

        case 5:
          if (!argv.addr) {
            _context.next = 9;
            break;
          }

          return _context.abrupt("return", infoHost(client, request, argv.addr));

        case 9:
          return _context.abrupt("return", infoAny(client, request));

        case 10:
        case "end":
          return _context.stop();
      }
    }
  });
}

function infoAny(client, request) {
  var response;
  return regeneratorRuntime.async(function infoAny$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return regeneratorRuntime.awrap(client.infoAny(request));

        case 2:
          response = _context2.sent;

          if (response) {
            console.info(response.trim());
          } else {
            console.info('Invalid request');
          }

        case 4:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function infoAll(client, request) {
  var responses;
  return regeneratorRuntime.async(function infoAll$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(client.infoAll(request));

        case 2:
          responses = _context3.sent;

          if (responses.some(function (response) {
            return response.info;
          })) {
            responses.map(function (response) {
              console.info("".concat(response.host.node_id, ":"));
              console.info(response.info.trim());
            });
          } else {
            console.info('Invalid request');
          }

        case 4:
        case "end":
          return _context3.stop();
      }
    }
  });
}

function infoHost(client, request, host) {
  var response;
  return regeneratorRuntime.async(function infoHost$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return regeneratorRuntime.awrap(client.info(request, host));

        case 2:
          response = _context4.sent;

          if (response) {
            console.info(response.trim());
          } else {
            console.info('Invalid request');
          }

        case 4:
        case "end":
          return _context4.stop();
      }
    }
  });
}

exports.command = 'info <requests...>';
exports.describe = 'Send an info request to the cluster';
exports.handler = shared.run(info);
exports.builder = {
  any: {
    describe: 'Send request to a single, randomly selected cluster node',
    type: 'boolean',
    group: 'Command:',
    conflicts: ['all', 'addr']
  },
  all: {
    describe: 'Send request to all cluster nodes',
    type: 'boolean',
    group: 'Command:',
    conflicts: ['any', 'addr']
  },
  addr: {
    describe: 'Send request to specified cluster node',
    type: 'string',
    group: 'Command:',
    conflicts: ['any', 'all']
  }
};