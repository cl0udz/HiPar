#!/usr/bin/env node
// *****************************************************************************
// Copyright 2013-2018 Aerospike, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// *****************************************************************************
// Monte Carlo simulation to estimate the value of Pi. This example creates a
// number of database records, each containing a bin with a GeoJSON Point. The
// points lie within the square spanned by the two points (-10, -10) and (10,
// 10) and have randomly generated lat/lon coordiantes. A secondary, geospatial
// index is created on the records and a "geoWithinRadius" query is then used
// to count the number of points within a circle around the origin (0, 0). The
// radius of the circle is approxmiated by calculating the great-circle
// distance between the center (0, 0) the point (10, 0) which lies on the
// circumference of the circle (using the havesine formula). The ratio between
// the points that fall within the square and the points that fall within the
// circle can then be used to approximate the value of Pi:
//
// Sqr := Points within square
// Cir := Points in circle
// l   := Length of the square
// r   := Radius of the circle
//
// l = 2 * r
//
// ( aera of circle ) / ( aera of square ) = Sqr / Cir
// ( pi * r * r ) / ( l * l ) = Sqr / Cir
// pi * ( r * r ) / ( 2 * r * 2 * r ) = Sqr / Cir
// pi / 4 = Sqr / Cir
// pi = Sqr / Cir * 4
//
// References:
// https://en.wikipedia.org/wiki/Monte_Carlo_method
// https://en.wikipedia.org/wiki/Haversine_formula
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Aerospike = require('aerospike');

var shared = require('./shared');

var path = require('path');

shared.runner();

function monteCarlo(client, argv) {
  var game, hits, piEstimate;
  return regeneratorRuntime.async(function monteCarlo$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          game = {
            client: client,
            noDarts: argv.darts,
            // number of darts to throw
            maxInFlight: argv.maxInFlight,
            maxLatLng: 10,
            // pick coordinates between (-10, -10) and (10, 10)
            ns: argv.namespace,
            set: shared.random.identifier(),
            bin: 'geo',
            idx: shared.random.identifier()
          };
          _context.next = 3;
          return regeneratorRuntime.awrap(setup(game));

        case 3:
          _context.next = 5;
          return regeneratorRuntime.awrap(throwDarts(game));

        case 5:
          _context.next = 7;
          return regeneratorRuntime.awrap(countHits(game));

        case 7:
          hits = _context.sent;
          console.info("".concat(hits, " out of ").concat(game.noDarts, " darts landed in the circle."));
          piEstimate = calculatePi(hits, game.noDarts);
          console.info("".concat(hits, " \xF7 ").concat(game.noDarts, " \xD7 4 = ").concat(piEstimate));
          console.info();
          console.info("\uD835\uDED1 is estimated to be ".concat(piEstimate, "."));
          _context.next = 15;
          return regeneratorRuntime.awrap(cleanUp(game));

        case 15:
        case "end":
          return _context.stop();
      }
    }
  });
}

function setup(game) {
  var module, udfJob, idx, idxJob;
  return regeneratorRuntime.async(function setup$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          module = path.join(game.client.config.modlua.userPath, 'monte_carlo.lua');
          _context2.next = 3;
          return regeneratorRuntime.awrap(game.client.udfRegister(module));

        case 3:
          udfJob = _context2.sent;
          idx = {
            ns: game.ns,
            set: game.set,
            bin: game.bin,
            index: game.idx,
            datatype: Aerospike.indexDataType.GEO2DSPHERE
          };
          _context2.next = 7;
          return regeneratorRuntime.awrap(game.client.createIndex(idx));

        case 7:
          idxJob = _context2.sent;
          return _context2.abrupt("return", Promise.all([udfJob.wait(), idxJob.wait()]));

        case 9:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function cleanUp(game) {
  return regeneratorRuntime.async(function cleanUp$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;
          _context3.next = 3;
          return regeneratorRuntime.awrap(game.client.indexRemove(game.ns, game.idx));

        case 3:
          _context3.next = 9;
          break;

        case 5:
          _context3.prev = 5;
          _context3.t0 = _context3["catch"](0);

          if (!(_context3.t0.code !== Aerospike.status.ERR_INDEX_NOT_FOUND)) {
            _context3.next = 9;
            break;
          }

          throw _context3.t0;

        case 9:
          _context3.next = 11;
          return regeneratorRuntime.awrap(game.client.truncate(game.ns, game.set, 0));

        case 11:
        case "end":
          return _context3.stop();
      }
    }
  }, null, null, [[0, 5]]);
}

function throwDarts(game) {
  var start, current, inflight;
  return regeneratorRuntime.async(function throwDarts$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          console.info("Simulating throwing of ".concat(game.noDarts, " darts."));
          start = process.hrtime();
          current = 0;
          inflight = 0;
          return _context4.abrupt("return", new Promise(function (resolve, reject) {
            var cb = function cb(err) {
              if (err) {
                throw err;
              }

              process.stdout.write("\r".concat(current));
              inflight--;

              if (current < game.noDarts) {
                current++;
                inflight++;
                throwDart(game, current, cb);
              } else if (inflight === 0) {
                var elapsed = process.hrtime(start);
                var elapsedSecs = (elapsed[0] + elapsed[1] / 1e9).toFixed(1);
                console.info("\rFinished simulating ".concat(current, " dart throws in ").concat(elapsedSecs, " seconds."));
                process.stdout.write('\r              \n');
                resolve();
              }
            };

            for (var i = 0; i < Math.min(game.maxInFlight, game.noDarts); i++) {
              current++;
              inflight++;
              throwDart(game, current, cb);
            }
          }));

        case 5:
        case "end":
          return _context4.stop();
      }
    }
  });
}

function throwDart(game, id, cb) {
  var key = new Aerospike.Key(game.ns, game.set, id);
  var point = randomPoint(game.maxLatLng);

  var bins = _defineProperty({}, game.bin, point);

  game.client.put(key, bins, cb);
}

function countHits(game) {
  var query, radius, policy, count;
  return regeneratorRuntime.async(function countHits$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          query = game.client.query(game.ns, game.set);
          radius = harvesine(0, 0, 10, 0); // approximation

          query.where(Aerospike.filter.geoWithinRadius(game.bin, 0, 0, radius));
          policy = new Aerospike.QueryPolicy({
            totalTimeout: 10000
          });
          count = query.apply('monte_carlo', 'count', [], policy);
          return _context5.abrupt("return", count);

        case 6:
        case "end":
          return _context5.stop();
      }
    }
  });
}

function calculatePi(circleHits, squareHits) {
  return 4.0 * circleHits / squareHits;
}

function randomPoint(maxLatLng) {
  var lng = shared.random["float"](-maxLatLng, maxLatLng);
  var lat = shared.random["float"](-maxLatLng, maxLatLng);
  return new Aerospike.GeoJSON.Point(lng, lat);
} // Calculates distance in meters between two coordinates


function harvesine(lat1, lon1, lat2, lon2) {
  var R = 6378.137; // Radius of earth in KM

  var dLat = lat2 * Math.PI / 180 - lat1 * Math.PI / 180;
  var dLon = lon2 * Math.PI / 180 - lon1 * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d * 1000; // meters
}

exports.command = 'geospatialMonteCarlo';
exports.describe = 'Run a Monte Carlo simulation to estimate Pi using Geospatial Queries';
exports.handler = shared.run(monteCarlo);
exports.builder = {
  darts: {
    desc: 'Number of darts to throw',
    group: 'Command:',
    type: 'number',
    "default": 10000
  },
  maxInFlight: {
    desc: 'Max. number of darts to throw in parallel',
    group: 'Command:',
    type: 'number',
    "default": 150
  }
};