#!/usr/bin/env node
// *****************************************************************************
// Copyright 2013-2019 Aerospike, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// *****************************************************************************
"use strict";

var Aerospike = require('aerospike');

var shared = require('./shared');

shared.runner();

function selectBins(query, argv) {
  if (argv.bins) {
    query.select(argv.bins);
  }
}

function applyFilter(query, argv) {
  if (argv.equal) {
    var filter = argv.equal;
    var bin = filter[0];
    var value = filter[1];
    query.where(Aerospike.filter.equal(bin, value));
  } else if (argv.range) {
    var _filter = argv.range;
    var _bin = _filter[0];
    var start = _filter[1];
    var end = _filter[2];
    query.where(Aerospike.filter.range(_bin, start, end));
  } else if (argv.geoWithinRadius) {
    var _filter2 = argv.geoWithinRadius;
    var _bin2 = _filter2[0];
    var lng = _filter2[1];
    var lat = _filter2[2];
    var radius = _filter2[3];
    query.where(Aerospike.filter.geoWithinRadius(_bin2, lng, lat, radius));
  }
}

function udfParams(argv) {
  if (!argv.udf) {
    return;
  }

  var udf = {};
  udf.module = argv.udf.shift();
  udf.func = argv.udf.shift();
  udf.args = argv.udf;
  return udf;
}

function query(client, argv) {
  var query, udf;
  return regeneratorRuntime.async(function query$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          query = client.query(argv.namespace, argv.set);
          selectBins(query, argv);
          applyFilter(query, argv);
          udf = udfParams(argv);

          if (!(udf && argv.background)) {
            _context.next = 9;
            break;
          }

          _context.next = 7;
          return regeneratorRuntime.awrap(queryBackground(query, udf));

        case 7:
          _context.next = 16;
          break;

        case 9:
          if (!udf) {
            _context.next = 14;
            break;
          }

          _context.next = 12;
          return regeneratorRuntime.awrap(queryApply(query, udf));

        case 12:
          _context.next = 16;
          break;

        case 14:
          _context.next = 16;
          return regeneratorRuntime.awrap(queryForeach(query));

        case 16:
        case "end":
          return _context.stop();
      }
    }
  });
}

function queryForeach(query) {
  var stream;
  return regeneratorRuntime.async(function queryForeach$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          stream = query.foreach();
          stream.on('data', shared.cli.printRecord);
          _context2.next = 4;
          return regeneratorRuntime.awrap(shared.streams.consume(stream));

        case 4:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function queryBackground(query, udf) {
  var job;
  return regeneratorRuntime.async(function queryBackground$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(query.background(udf.module, udf.func, udf.args));

        case 2:
          job = _context3.sent;
          console.info('Running query in background - Job ID:', job.jobID);

        case 4:
        case "end":
          return _context3.stop();
      }
    }
  });
}

function queryApply(query, udf) {
  var result;
  return regeneratorRuntime.async(function queryApply$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return regeneratorRuntime.awrap(query.apply(udf.module, udf.func, udf.args));

        case 2:
          result = _context4.sent;
          console.info('Query result:', result);

        case 4:
        case "end":
          return _context4.stop();
      }
    }
  });
}

exports.command = 'query';
exports.describe = 'Execute a query and print the results';
exports.handler = shared.run(query);
exports.builder = {
  bins: {
    describe: 'List of bins to fetch for each record',
    type: 'array',
    group: 'Command:'
  },
  equal: {
    desc: 'Applies an equal filter to the query',
    group: 'Command:',
    nargs: 2,
    conflicts: ['range', 'geoWithinRadius']
  },
  range: {
    desc: 'Applies a range filter to the query',
    group: 'Command:',
    nargs: 3,
    conflicts: ['equal', 'geoWithinRadius']
  },
  geoWithinRadius: {
    desc: 'Applies a geospatial "within-radius" filter to the query',
    group: 'Command:',
    nargs: 4,
    conflicts: ['equal', 'range']
  },
  udf: {
    desc: 'UDF module, function & arguments to apply to the query',
    group: 'Command:',
    type: 'array'
  },
  background: {
    desc: 'Run the query in the background (with Record UDF)',
    group: 'Command:',
    type: 'boolean'
  }
};