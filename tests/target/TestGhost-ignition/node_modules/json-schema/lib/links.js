"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.join.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/web.dom-collections.iterator.js");

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}
/** 
 * JSON Schema link handler
 * Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)
 * Licensed under the MIT (MIT-LICENSE.txt) license.
 */


(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], function () {
      return factory();
    });
  } else if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals
    root.jsonSchemaLinks = factory();
  }
})(void 0, function () {
  // setup primitive classes to be JSON Schema types
  var exports = {};
  exports.cacheLinks = true;

  exports.getLink = function (relation, instance, schema) {
    // gets the URI of the link for the given relation based on the instance and schema
    // for example:
    // getLink(
    // 		"brother", 
    // 		{"brother_id":33}, 
    // 		{links:[{rel:"brother", href:"Brother/{brother_id}"}]}) ->
    //	"Brother/33"
    var links = schema.__linkTemplates;

    if (!links) {
      links = {};
      var schemaLinks = schema.links;

      if (schemaLinks && schemaLinks instanceof Array) {
        schemaLinks.forEach(function (link) {
          /*			// TODO: allow for multiple same-name relations
          			if(links[link.rel]){
          				if(!(links[link.rel] instanceof Array)){
          					links[link.rel] = [links[link.rel]];
          				}
          			}*/
          links[link.rel] = link.href;
        });
      }

      if (exports.cacheLinks) {
        schema.__linkTemplates = links;
      }
    }

    var linkTemplate = links[relation];
    return linkTemplate && exports.substitute(linkTemplate, instance);
  };

  exports.substitute = function (linkTemplate, instance) {
    return linkTemplate.replace(/\{([^\}]*)\}/g, function (t, property) {
      var value = instance[decodeURIComponent(property)];

      if (value instanceof Array) {
        // the value is an array, it should produce a URI like /Table/(4,5,8) and store.get() should handle that as an array of values
        return '(' + value.join(',') + ')';
      }

      return value;
    });
  };

  return exports;
});