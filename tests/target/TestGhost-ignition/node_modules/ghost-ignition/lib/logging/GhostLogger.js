"use strict";

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.replace");

var each = require('lodash/each');

var upperFirst = require('lodash/upperFirst');

var toArray = require('lodash/toArray');

var isObject = require('lodash/isObject');

var isEmpty = require('lodash/isEmpty');

var includes = require('lodash/includes');

var bunyan = require('bunyan');

var fs = require('fs-extra');

var jsonStringifySafe = require('json-stringify-safe');

var GhostPrettyStream = require('./PrettyStream');
/**
 * @description Ghost's logger class.
 *
 * The logger handles any stdout/stderr logs and streams it into the configured transports.
 */


class GhostLogger {
  constructor(options) {
    var _this = this;

    options = options || {};
    this.name = options.name || 'Log';
    this.env = options.env || 'development';
    this.domain = options.domain || 'localhost';
    this.transports = options.transports || ['stdout'];
    this.level = process.env.LEVEL || options.level || 'info';
    this.logBody = options.logBody || false;
    this.mode = process.env.MODE || options.mode || 'short';
    this.path = options.path || process.cwd();
    this.loggly = options.loggly || {};
    this.gelf = options.gelf || {}; // CASE: stdout has to be on the first position in the transport,  because if the GhostLogger itself logs, you won't see the stdout print

    if (this.transports.indexOf('stdout') !== -1 && this.transports.indexOf('stdout') !== 0) {
      this.transports.splice(this.transports.indexOf('stdout'), 1);
      this.transports = ['stdout'].concat(this.transports);
    } // CASE: special env variable to enable long mode and level info


    if (process.env.LOIN) {
      this.level = 'info';
      this.mode = 'long';
    } // CASE: ensure we have a trailing slash


    if (!this.path.match(/\/$|\\$/)) {
      this.path = this.path + '/';
    }

    this.rotation = options.rotation || {
      enabled: false,
      period: '1w',
      count: 100
    };
    this.streams = {};
    this.setSerializers();

    if (includes(this.transports, 'stderr') && !includes(this.transports, 'stdout')) {
      this.transports.push('stdout');
    }

    this.transports.forEach(function (transport) {
      var transportFn = `set${upperFirst(transport)}Stream`;

      if (!_this[transportFn]) {
        throw new Error(`${upperFirst(transport)} is an invalid transport`);
      }

      _this[transportFn]();
    });
  }
  /**
   * @description Setup stdout stream.
   */


  setStdoutStream() {
    var prettyStdOut = new GhostPrettyStream({
      mode: this.mode
    });
    prettyStdOut.pipe(process.stdout);
    this.streams.stdout = {
      name: 'stdout',
      log: bunyan.createLogger({
        name: this.name,
        streams: [{
          type: 'raw',
          stream: prettyStdOut,
          level: this.level
        }],
        serializers: this.serializers
      })
    };
  }
  /**
   * @description Setup stderr stream.
   */


  setStderrStream() {
    var prettyStdErr = new GhostPrettyStream({
      mode: this.mode
    });
    prettyStdErr.pipe(process.stderr);
    this.streams.stderr = {
      name: 'stderr',
      log: bunyan.createLogger({
        name: this.name,
        streams: [{
          type: 'raw',
          stream: prettyStdErr,
          level: 'error'
        }],
        serializers: this.serializers
      })
    };
  }
  /**
   * @description Setup loggly.
   */


  setLogglyStream() {
    var Bunyan2Loggly = require('bunyan-loggly');

    var logglyStream = new Bunyan2Loggly({
      token: this.loggly.token,
      subdomain: this.loggly.subdomain,
      tags: this.loggly.tags
    });
    this.streams.loggly = {
      name: 'loggly',
      match: this.loggly.match,
      log: bunyan.createLogger({
        name: this.name,
        streams: [{
          type: 'raw',
          stream: logglyStream,
          level: 'error'
        }],
        serializers: this.serializers
      })
    };
  }
  /**
   * @description Setup gelf.
   */


  setGelfStream() {
    var gelfStream = require('gelf-stream');

    var stream = gelfStream.forBunyan(this.gelf.host || 'localhost', this.gelf.port || 12201, this.gelf.options || {});
    this.streams.gelf = {
      name: 'gelf',
      log: bunyan.createLogger({
        name: this.name,
        streams: [{
          type: 'raw',
          stream: stream,
          level: this.level
        }],
        serializers: this.serializers
      })
    };
  }
  /**
   * @description Setup file stream.
   *
   * By default we log into two files
   * 1. file-errors: all errors only
   * 2. file-all: everything
   */


  setFileStream() {
    // e.g. http://my-domain.com --> http___my_domain_com
    var sanitizedDomain = this.domain.replace(/[^\w]/gi, '_'); // CASE: target log folder does not exist, show warning

    if (!fs.pathExistsSync(this.path)) {
      this.error('Target log folder does not exist: ' + this.path);
      return;
    }

    if (this.rotation.enabled) {
      this.streams['rotation-errors'] = {
        name: 'rotation-errors',
        log: bunyan.createLogger({
          name: this.name,
          streams: [{
            type: 'rotating-file',
            path: `${this.path}${sanitizedDomain}_${this.env}.error.log`,
            period: this.rotation.period,
            count: this.rotation.count,
            level: "error"
          }],
          serializers: this.serializers
        })
      };
      this.streams['rotation-all'] = {
        name: 'rotation-all',
        log: bunyan.createLogger({
          name: this.name,
          streams: [{
            type: 'rotating-file',
            path: `${this.path}${sanitizedDomain}_${this.env}.log`,
            period: this.rotation.period,
            count: this.rotation.count,
            level: this.level
          }],
          serializers: this.serializers
        })
      };
    } else {
      this.streams['file-errors'] = {
        name: 'file',
        log: bunyan.createLogger({
          name: this.name,
          streams: [{
            path: `${this.path}${sanitizedDomain}_${this.env}.error.log`,
            level: 'error'
          }],
          serializers: this.serializers
        })
      };
      this.streams['file-all'] = {
        name: 'file',
        log: bunyan.createLogger({
          name: this.name,
          streams: [{
            path: `${this.path}${sanitizedDomain}_${this.env}.log`,
            level: this.level
          }],
          serializers: this.serializers
        })
      };
    }
  } // @TODO: res.on('finish') has no access to the response body

  /**
   * @description Serialize the log input.
   *
   * The goals are:
   *   - avoiding to log to much (pick useful information from request/response
   *   - removing/replacing sensitive data from logging to a stream/transport
   */


  setSerializers() {
    var _this2 = this;

    this.serializers = {
      req: function req(_req) {
        var requestLog = {
          meta: {
            requestId: _req.requestId,
            userId: _req.userId
          },
          url: _req.url,
          method: _req.method,
          originalUrl: _req.originalUrl,
          params: _req.params,
          headers: _this2.removeSensitiveData(_req.headers),
          query: _this2.removeSensitiveData(_req.query)
        };

        if (_this2.logBody) {
          requestLog.body = _this2.removeSensitiveData(_req.body);
        }

        return requestLog;
      },
      res: function res(_res) {
        return {
          _headers: _this2.removeSensitiveData(_res._headers),
          statusCode: _res.statusCode,
          responseTime: _res.responseTime
        };
      },
      err: function err(_err) {
        return {
          id: _err.id,
          domain: _this2.domain,
          code: _err.code,
          name: _err.errorType,
          statusCode: _err.statusCode,
          level: _err.level,
          message: _err.message,
          context: jsonStringifySafe(_err.context),
          help: jsonStringifySafe(_err.help),
          stack: _err.stack,
          hideStack: _err.hideStack,
          errorDetails: jsonStringifySafe(_err.errorDetails)
        };
      }
    };
  }
  /**
   * @description Remove sensitive data.
   * @param {Object} obj
   */


  removeSensitiveData(obj) {
    var _this3 = this;

    var newObj = {};
    each(obj, function (value, key) {
      try {
        if (isObject(value)) {
          value = _this3.removeSensitiveData(value);
        }

        if (key.match(/pin|password|pass|key|authorization|bearer|cookie/gi)) {
          newObj[key] = '**REDACTED**';
        } else {
          newObj[key] = value;
        }
      } catch (err) {
        newObj[key] = value;
      }
    });
    return newObj;
  }
  /**
   * @description Centralised log function.
   *
   * Arguments can contain lot's of different things, we prepare the arguments here.
   * This function allows us to use logging very flexible!
   *
   * logging.info('HEY', 'DU') --> is one string
   * logging.info({}, {}) --> is one object
   * logging.error(new Error()) --> is {err: new Error()}
   */


  log(type, args) {
    var _this4 = this;

    var modifiedMessages = [];
    var modifiedObject = {};
    var modifiedArguments = [];
    each(args, function (value) {
      if (value instanceof Error) {
        modifiedObject.err = value;
      } else if (isObject(value)) {
        each(Object.keys(value), function (key) {
          modifiedObject[key] = value[key];
        });
      } else {
        modifiedMessages.push(value);
      }
    });

    if (!isEmpty(modifiedObject)) {
      if (modifiedObject.err) {
        modifiedMessages.push(modifiedObject.err.message);
      }

      modifiedArguments.push(modifiedObject);
    }

    modifiedArguments.push(...modifiedMessages);
    each(this.streams, function (logger) {
      // If we have both a stdout and a stderr stream, don't log errors to stdout
      // because it would result in duplicate logs
      if (type === 'error' && logger.name === 'stdout' && includes(_this4.transports, 'stderr')) {
        return;
      }
      /**
       * @NOTE
       * Only `loggly` offers the `match` option.
       * And currently `loggly` is by default configured to only send errors (not configureable).
       * e.g. level info would get ignored.
       *
       * @NOTE
       * The `match` feature is not completed. We hardcode checking if the level/type is `error` for now.
       * Otherwise each `level:info` would has to run through the matching logic.
       *
       * @NOTE
       * Matching a string in the whole req/res object massively slows down the process, because it's a sync
       * operation.
       *
       * If we want to extend the feature, we can only offer matching certain keys e.g. status code, headers.
       * If we want to extend the feature, we have to do proper performance testing.
       *
       * `jsonStringifySafe` can match a string in an object, which has circular dependencies.
       * https://github.com/moll/json-stringify-safe
       */


      if (logger.match && type === 'error') {
        if (new RegExp(logger.match).test(jsonStringifySafe(modifiedArguments[0].err || null).replace(/"/g, ''))) {
          logger.log[type](...modifiedArguments);
        }
      } else {
        logger.log[type](...modifiedArguments);
      }
    });
  }

  trace() {
    this.log('trace', toArray(arguments));
  }

  debug() {
    this.log('debug', toArray(arguments));
  }

  info() {
    this.log('info', toArray(arguments));
  }

  warn() {
    this.log('warn', toArray(arguments));
  }

  error() {
    this.log('error', toArray(arguments));
  }

  fatal() {
    this.log('fatal', toArray(arguments));
  }

}

module.exports = GhostLogger;