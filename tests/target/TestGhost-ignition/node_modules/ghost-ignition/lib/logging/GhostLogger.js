"use strict";

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/es.array.index-of.js");

require("core-js/modules/es.array.splice.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.object.keys.js");

require("core-js/modules/es.regexp.constructor.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.string.match.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/web.dom-collections.for-each.js");

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var each = require('lodash/each');

var upperFirst = require('lodash/upperFirst');

var toArray = require('lodash/toArray');

var isObject = require('lodash/isObject');

var isEmpty = require('lodash/isEmpty');

var includes = require('lodash/includes');

var bunyan = require('bunyan');

var fs = require('fs-extra');

var jsonStringifySafe = require('json-stringify-safe');

var GhostPrettyStream = require('./PrettyStream');
/**
 * @description Ghost's logger class.
 *
 * The logger handles any stdout/stderr logs and streams it into the configured transports.
 */


var GhostLogger =
/*#__PURE__*/
function () {
  function GhostLogger(options) {
    var _this = this;

    _classCallCheck(this, GhostLogger);

    options = options || {};
    this.name = options.name || 'Log';
    this.env = options.env || 'development';
    this.domain = options.domain || 'localhost';
    this.transports = options.transports || ['stdout'];
    this.level = process.env.LEVEL || options.level || 'info';
    this.logBody = options.logBody || false;
    this.mode = process.env.MODE || options.mode || 'short';
    this.path = options.path || process.cwd();
    this.loggly = options.loggly || {};
    this.gelf = options.gelf || {}; // CASE: stdout has to be on the first position in the transport,  because if the GhostLogger itself logs, you won't see the stdout print

    if (this.transports.indexOf('stdout') !== -1 && this.transports.indexOf('stdout') !== 0) {
      this.transports.splice(this.transports.indexOf('stdout'), 1);
      this.transports = ['stdout'].concat(this.transports);
    } // CASE: special env variable to enable long mode and level info


    if (process.env.LOIN) {
      this.level = 'info';
      this.mode = 'long';
    } // CASE: ensure we have a trailing slash


    if (!this.path.match(/\/$|\\$/)) {
      this.path = this.path + '/';
    }

    this.rotation = options.rotation || {
      enabled: false,
      period: '1w',
      count: 100
    };
    this.streams = {};
    this.setSerializers();

    if (includes(this.transports, 'stderr') && !includes(this.transports, 'stdout')) {
      this.transports.push('stdout');
    }

    this.transports.forEach(function (transport) {
      var transportFn = "set".concat(upperFirst(transport), "Stream");

      if (!_this[transportFn]) {
        throw new Error("".concat(upperFirst(transport), " is an invalid transport"));
      }

      _this[transportFn]();
    });
  }
  /**
   * @description Setup stdout stream.
   */


  _createClass(GhostLogger, [{
    key: "setStdoutStream",
    value: function setStdoutStream() {
      var prettyStdOut = new GhostPrettyStream({
        mode: this.mode
      });
      prettyStdOut.pipe(process.stdout);
      this.streams.stdout = {
        name: 'stdout',
        log: bunyan.createLogger({
          name: this.name,
          streams: [{
            type: 'raw',
            stream: prettyStdOut,
            level: this.level
          }],
          serializers: this.serializers
        })
      };
    }
    /**
     * @description Setup stderr stream.
     */

  }, {
    key: "setStderrStream",
    value: function setStderrStream() {
      var prettyStdErr = new GhostPrettyStream({
        mode: this.mode
      });
      prettyStdErr.pipe(process.stderr);
      this.streams.stderr = {
        name: 'stderr',
        log: bunyan.createLogger({
          name: this.name,
          streams: [{
            type: 'raw',
            stream: prettyStdErr,
            level: 'error'
          }],
          serializers: this.serializers
        })
      };
    }
    /**
     * @description Setup loggly.
     */

  }, {
    key: "setLogglyStream",
    value: function setLogglyStream() {
      var Bunyan2Loggly = require('bunyan-loggly');

      var logglyStream = new Bunyan2Loggly({
        token: this.loggly.token,
        subdomain: this.loggly.subdomain,
        tags: this.loggly.tags
      });
      this.streams.loggly = {
        name: 'loggly',
        match: this.loggly.match,
        log: bunyan.createLogger({
          name: this.name,
          streams: [{
            type: 'raw',
            stream: logglyStream,
            level: 'error'
          }],
          serializers: this.serializers
        })
      };
    }
    /**
     * @description Setup gelf.
     */

  }, {
    key: "setGelfStream",
    value: function setGelfStream() {
      var gelfStream = require('gelf-stream');

      var stream = gelfStream.forBunyan(this.gelf.host || 'localhost', this.gelf.port || 12201, this.gelf.options || {});
      this.streams.gelf = {
        name: 'gelf',
        log: bunyan.createLogger({
          name: this.name,
          streams: [{
            type: 'raw',
            stream: stream,
            level: this.level
          }],
          serializers: this.serializers
        })
      };
    }
    /**
     * @description Setup file stream.
     *
     * By default we log into two files
     * 1. file-errors: all errors only
     * 2. file-all: everything
     */

  }, {
    key: "setFileStream",
    value: function setFileStream() {
      // e.g. http://my-domain.com --> http___my_domain_com
      var sanitizedDomain = this.domain.replace(/[^\w]/gi, '_'); // CASE: target log folder does not exist, show warning

      if (!fs.pathExistsSync(this.path)) {
        this.error('Target log folder does not exist: ' + this.path);
        return;
      }

      if (this.rotation.enabled) {
        this.streams['rotation-errors'] = {
          name: 'rotation-errors',
          log: bunyan.createLogger({
            name: this.name,
            streams: [{
              type: 'rotating-file',
              path: "".concat(this.path).concat(sanitizedDomain, "_").concat(this.env, ".error.log"),
              period: this.rotation.period,
              count: this.rotation.count,
              level: "error"
            }],
            serializers: this.serializers
          })
        };
        this.streams['rotation-all'] = {
          name: 'rotation-all',
          log: bunyan.createLogger({
            name: this.name,
            streams: [{
              type: 'rotating-file',
              path: "".concat(this.path).concat(sanitizedDomain, "_").concat(this.env, ".log"),
              period: this.rotation.period,
              count: this.rotation.count,
              level: this.level
            }],
            serializers: this.serializers
          })
        };
      } else {
        this.streams['file-errors'] = {
          name: 'file',
          log: bunyan.createLogger({
            name: this.name,
            streams: [{
              path: "".concat(this.path).concat(sanitizedDomain, "_").concat(this.env, ".error.log"),
              level: 'error'
            }],
            serializers: this.serializers
          })
        };
        this.streams['file-all'] = {
          name: 'file',
          log: bunyan.createLogger({
            name: this.name,
            streams: [{
              path: "".concat(this.path).concat(sanitizedDomain, "_").concat(this.env, ".log"),
              level: this.level
            }],
            serializers: this.serializers
          })
        };
      }
    } // @TODO: res.on('finish') has no access to the response body

    /**
     * @description Serialize the log input.
     *
     * The goals are:
     *   - avoiding to log to much (pick useful information from request/response
     *   - removing/replacing sensitive data from logging to a stream/transport
     */

  }, {
    key: "setSerializers",
    value: function setSerializers() {
      var _this2 = this;

      this.serializers = {
        req: function req(_req) {
          var requestLog = {
            meta: {
              requestId: _req.requestId,
              userId: _req.userId
            },
            url: _req.url,
            method: _req.method,
            originalUrl: _req.originalUrl,
            params: _req.params,
            headers: _this2.removeSensitiveData(_req.headers),
            query: _this2.removeSensitiveData(_req.query)
          };

          if (_this2.logBody) {
            requestLog.body = _this2.removeSensitiveData(_req.body);
          }

          return requestLog;
        },
        res: function res(_res) {
          return {
            _headers: _this2.removeSensitiveData(_res._headers),
            statusCode: _res.statusCode,
            responseTime: _res.responseTime
          };
        },
        err: function err(_err) {
          return {
            id: _err.id,
            domain: _this2.domain,
            code: _err.code,
            name: _err.errorType,
            statusCode: _err.statusCode,
            level: _err.level,
            message: _err.message,
            context: jsonStringifySafe(_err.context),
            help: jsonStringifySafe(_err.help),
            stack: _err.stack,
            hideStack: _err.hideStack,
            errorDetails: jsonStringifySafe(_err.errorDetails)
          };
        }
      };
    }
    /**
     * @description Remove sensitive data.
     * @param {Object} obj
     */

  }, {
    key: "removeSensitiveData",
    value: function removeSensitiveData(obj) {
      var _this3 = this;

      var newObj = {};
      each(obj, function (value, key) {
        try {
          if (isObject(value)) {
            value = _this3.removeSensitiveData(value);
          }

          if (key.match(/pin|password|pass|key|authorization|bearer|cookie/gi)) {
            newObj[key] = '**REDACTED**';
          } else {
            newObj[key] = value;
          }
        } catch (err) {
          newObj[key] = value;
        }
      });
      return newObj;
    }
    /**
     * @description Centralised log function.
     *
     * Arguments can contain lot's of different things, we prepare the arguments here.
     * This function allows us to use logging very flexible!
     *
     * logging.info('HEY', 'DU') --> is one string
     * logging.info({}, {}) --> is one object
     * logging.error(new Error()) --> is {err: new Error()}
     */

  }, {
    key: "log",
    value: function log(type, args) {
      var _this4 = this;

      var modifiedMessages = [];
      var modifiedObject = {};
      var modifiedArguments = [];
      each(args, function (value) {
        if (value instanceof Error) {
          modifiedObject.err = value;
        } else if (isObject(value)) {
          each(Object.keys(value), function (key) {
            modifiedObject[key] = value[key];
          });
        } else {
          modifiedMessages.push(value);
        }
      });

      if (!isEmpty(modifiedObject)) {
        if (modifiedObject.err) {
          modifiedMessages.push(modifiedObject.err.message);
        }

        modifiedArguments.push(modifiedObject);
      }

      modifiedArguments.push.apply(modifiedArguments, modifiedMessages);
      each(this.streams, function (logger) {
        // If we have both a stdout and a stderr stream, don't log errors to stdout
        // because it would result in duplicate logs
        if (type === 'error' && logger.name === 'stdout' && includes(_this4.transports, 'stderr')) {
          return;
        }
        /**
         * @NOTE
         * Only `loggly` offers the `match` option.
         * And currently `loggly` is by default configured to only send errors (not configureable).
         * e.g. level info would get ignored.
         *
         * @NOTE
         * The `match` feature is not completed. We hardcode checking if the level/type is `error` for now.
         * Otherwise each `level:info` would has to run through the matching logic.
         *
         * @NOTE
         * Matching a string in the whole req/res object massively slows down the process, because it's a sync
         * operation.
         *
         * If we want to extend the feature, we can only offer matching certain keys e.g. status code, headers.
         * If we want to extend the feature, we have to do proper performance testing.
         *
         * `jsonStringifySafe` can match a string in an object, which has circular dependencies.
         * https://github.com/moll/json-stringify-safe
         */


        if (logger.match && type === 'error') {
          if (new RegExp(logger.match).test(jsonStringifySafe(modifiedArguments[0].err || null).replace(/"/g, ''))) {
            var _logger$log;

            (_logger$log = logger.log)[type].apply(_logger$log, modifiedArguments);
          }
        } else {
          var _logger$log2;

          (_logger$log2 = logger.log)[type].apply(_logger$log2, modifiedArguments);
        }
      });
    }
  }, {
    key: "trace",
    value: function trace() {
      this.log('trace', toArray(arguments));
    }
  }, {
    key: "debug",
    value: function debug() {
      this.log('debug', toArray(arguments));
    }
  }, {
    key: "info",
    value: function info() {
      this.log('info', toArray(arguments));
    }
  }, {
    key: "warn",
    value: function warn() {
      this.log('warn', toArray(arguments));
    }
  }, {
    key: "error",
    value: function error() {
      this.log('error', toArray(arguments));
    }
  }, {
    key: "fatal",
    value: function fatal() {
      this.log('fatal', toArray(arguments));
    }
  }]);

  return GhostLogger;
}();

module.exports = GhostLogger;