"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * argv.js: Simple memory-based store for command-line arguments.
 *
 * (C) 2011, Charlie Robbins and the Contributors.
 *
 */
var util = require('util'),
    common = require('../common'),
    Memory = require('./memory').Memory; //
// ### function Argv (options)
// #### @options {Object} Options for this instance.
// Constructor function for the Argv nconf store, a simple abstraction
// around the Memory store that can read command-line arguments.
//


var Argv = exports.Argv = function (options, usage) {
  Memory.call(this, options);
  options = options || {};
  this.type = 'argv';
  this.readOnly = true;
  this.options = options;
  this.usage = usage;

  if (typeof options.parseValues === 'boolean') {
    this.parseValues = options.parseValues;
    delete options.parseValues;
  } else {
    this.parseValues = false;
  }

  if (typeof options.transform === 'function') {
    this.transform = options.transform;
    delete options.transform;
  } else {
    this.transform = false;
  }

  if (typeof options.separator === 'string' || options.separator instanceof RegExp) {
    this.separator = options.separator;
    delete options.separator;
  } else {
    this.separator = '';
  }
}; // Inherit from the Memory store


util.inherits(Argv, Memory); //
// ### function loadSync ()
// Loads the data passed in from `process.argv` into this instance.
//

Argv.prototype.loadSync = function () {
  this.loadArgv();
  return this.store;
}; //
// ### function loadArgv ()
// Loads the data passed in from the command-line arguments
// into this instance.
//


Argv.prototype.loadArgv = function () {
  var self = this,
      yargs,
      argv;
  yargs = isYargs(this.options) ? this.options : _typeof(this.options) === 'object' ? require('yargs')(process.argv.slice(2)).options(this.options) : require('yargs')(process.argv.slice(2));

  if (typeof this.usage === 'string') {
    yargs.usage(this.usage);
  }

  argv = yargs.argv;

  if (!argv) {
    return;
  }

  if (this.transform) {
    argv = common.transform(argv, this.transform);
  }

  this.readOnly = false;
  Object.keys(argv).forEach(function (key) {
    var val = argv[key];

    if (typeof val !== 'undefined') {
      if (self.parseValues) {
        val = common.parseValues(val);
      }

      if (self.separator) {
        self.set(common.key.apply(common, key.split(self.separator)), val);
      } else {
        self.set(key, val);
      }
    }
  });
  this.showHelp = yargs.showHelp;
  this.help = yargs.help;
  this.readOnly = true;
  return this.store;
};

function isYargs(obj) {
  return (typeof obj === 'function' || _typeof(obj) === 'object') && 'argv' in obj;
}