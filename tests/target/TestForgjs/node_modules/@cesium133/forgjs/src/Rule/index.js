"use strict";

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.object.keys.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.match.js");

require("core-js/modules/es.string.split.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.object.keys.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.match.js");

require("core-js/modules/es.string.split.js");

require("core-js/modules/web.dom-collections.for-each.js");

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var ErrorCollector = require('./ErrorCollector');

var _require = require('./util'),
    getErrorFromObject = _require.getErrorFromObject,
    getErrorFromFunctionOrString = _require.getErrorFromFunctionOrString;

var _require2 = require('../testFunctions'),
    TEST_FUNCTIONS = _require2.TEST_FUNCTIONS,
    OPTIONAL = _require2.OPTIONAL;

var _require3 = require('./../util'),
    AND = _require3.AND,
    OR = _require3.OR,
    isObject = _require3.isObject;

var OPERATORS = {
  '&': AND,
  '|': OR
};
/**
 * The Rule class validates only one value
 * once a rule is created it can be used multiple times
 */

var Rule =
/*#__PURE__*/
function () {
  /**
   *
   * @param {String|Object} obj the rule object it describes a the test that are ran by the Rule
   * @param {String} error the error returned when the tested input is not correct
   */
  function Rule(obj, error) {
    _classCallCheck(this, Rule);

    if (typeof obj === 'string' || obj instanceof String) {
      this.rule = {
        type: obj
      };
    } else {
      this.rule = obj;
    }

    this.error = error;
    this.errorCollector = new ErrorCollector();
    this.testEntryObject();
  }
  /**
   *
   * @param {any} val the value to be tested
   * @param {Object|String} obj the error object or string thats showed on error
   * @param {String} path the path to the tested value this is used when
   * using validator to keep track of the prop value ex: obj.min
   *
   * @return {boolean}
   */


  _createClass(Rule, [{
    key: "test",
    value: function test(val, obj, path) {
      this.errorCollector.clear();
      var types = this.getTypes();
      var operators = this.getRuleOperators();
      var ret = this.testOneRule(val, obj, types[0], path);

      for (var i = 1; i < types.length; i += 1) {
        var operator = operators[i] || operators[i - 1];
        ret = operator(ret, this.testOneRule(val, obj, types[i], path));
      }

      return ret;
    }
    /**
     * converts array from string if multiple types given in type
     * its the case for exemple int|float
     * @private
     * @return {[String]}
     */

  }, {
    key: "getTypes",
    value: function getTypes() {
      return this.rule.type.split(/[&|]/);
    }
    /**
     * Returns a list of the operators when multiple types given
     * its the case for example int|float
     * @private
     * @returns {[String]}
     */

  }, {
    key: "getRuleOperators",
    value: function getRuleOperators() {
      var ret = [];
      var operators = this.rule.type.match(/[&|]/g) || '&';

      for (var i = 0; i < operators.length; i += 1) {
        ret.push(OPERATORS[operators[i]]);
      }

      return ret;
    }
    /**
     * @private
     * @param val value to be tested
     * @param {Object} obj error object
     * @param {String} type the type from getTypes()
     * @param {String} path the path to the value if Validator is used
     *
     * @returns {boolean}
     */

  }, {
    key: "testOneRule",
    value: function testOneRule(val, obj, type, path) {
      if (Rule.TEST_FUNCTIONS[type].optional(val, this.rule.optional, obj) === true) {
        return true;
      }

      var keys = Object.keys(this.rule);
      keys.sort(function (key) {
        if (key === 'type') return -1;
        return 0;
      });

      for (var i = 0; i < keys.length; i += 1) {
        var key = keys[i];
        var testFunction = Rule.TEST_FUNCTIONS[type][key];

        if (testFunction(val, this.rule[key], obj) === false && testFunction !== OPTIONAL) {
          this.errorCollector.collect(this.getError(path, val, key));
          return false;
        }
      }

      return true;
    }
    /**
     * Tests the validity of the constructor object
     * thows an error if the object is invalid
     */

  }, {
    key: "testEntryObject",
    value: function testEntryObject() {
      var _this = this;

      if (!this.rule.type) {
        throw Error('`type` is required');
      }

      var types = this.getTypes();
      types.forEach(function (type) {
        _this.testEntryObjectOneType(type);
      });
    }
    /**
     * Tests the validity of the constructor object
     * thows an error if the object is invalid
     * tests if all the keys are valid
     */

  }, {
    key: "testEntryObjectOneType",
    value: function testEntryObjectOneType(type) {
      var keys = Object.keys(this.rule);

      for (var i = 0; i < keys.length; i += 1) {
        var key = keys[i];

        if (!Rule.TEST_FUNCTIONS[type]) {
          throw Error("The `".concat(type, "` type doesn't exist"));
        }

        if (!Rule.TEST_FUNCTIONS[type][key]) {
          throw new Error("`".concat(type, "` doesn't have \"").concat(key, "\" test!"));
        }
      }
    }
    /**
     * returns a list of errors if they are present
     * @return {[String]}
     */

  }, {
    key: "getError",
    value: function getError(path, value, key) {
      if (isObject(this.error)) {
        return getErrorFromObject(this.error, path, value, key);
      }

      return getErrorFromFunctionOrString(this.error, path, value);
    }
    /**
     * Add custom rule to the Rule class
     * @param {String} name the name of the rule
     * @param {Function} rule the validation function
     */

  }], [{
    key: "addCustom",
    value: function addCustom(name, rule) {
      Rule.TEST_FUNCTIONS[name] = rule;
      Rule.TEST_FUNCTIONS[name].optional = OPTIONAL;
    }
  }]);

  return Rule;
}();

Rule.TEST_FUNCTIONS = TEST_FUNCTIONS;
module.exports = Rule;