"use strict";

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.number.is-integer");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.repeat");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.bold");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var kindOf = require('kind-of');

var _require = require('cycle'),
    decycle = _require.decycle;

var _require2 = require('kleur'),
    red = _require2.red,
    cyan = _require2.cyan,
    blue = _require2.blue,
    green = _require2.green,
    magenta = _require2.magenta,
    bold = _require2.bold;
/**
 * Generate structured information about one or more objects that
 * includes each item type and value.
 *
 * @author Zeeshan Ahmad <ziishaned@gmail.com>
 */


var Dumper =
/*#__PURE__*/
function () {
  /**
   * @param {int} indentCount Number of spaces to indent the object with
   */
  function Dumper() {
    var indentCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;

    _classCallCheck(this, Dumper);

    this.spaces = ' '.repeat(indentCount);
  }
  /**
   * Iterates over each property of the provided object and make the output.
   *
   * @param {*} toDump
   * @param {string|null} indent
   * @return {string}
   */


  _createClass(Dumper, [{
    key: "generateDump",
    value: function generateDump(toDump) {
      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var dump = '';
      var startWith = '';
      var endWith = '';

      switch (kindOf(toDump)) {
        case 'array':
          startWith = "".concat(bold().black('array'), " (size=").concat(toDump.length, ") [\n");
          endWith = "".concat(indent, "]");
          break;

        case 'object':
          toDump = decycle(toDump);
          startWith = "".concat(bold().black('object'), " (size=").concat(Object.keys(toDump).length, ") {\n");
          endWith = "".concat(indent, "}");
          break;

        default:
          return this.prepareValueDump(indent, toDump);
      } // For each key of the object, keep
      // preparing the inspection output


      for (var itemKey in toDump) {
        if (!Object.prototype.hasOwnProperty.call(toDump, itemKey)) {
          continue;
        }

        var originalValue = toDump[itemKey];
        var originalParamType = kindOf(originalValue);
        var valueDump = this.prepareValueDump(indent, originalValue);
        dump += this.makeArrowString(originalParamType, indent, itemKey, valueDump);
      }

      return startWith + dump + endWith;
    }
    /**
     * Prepare the dump output for the given value
     *
     * @param indent
     * @param originalValue
     * @return {*|string}
     */

  }, {
    key: "prepareValueDump",
    value: function prepareValueDump(indent, originalValue) {
      var displayValue = '';
      var displayType = kindOf(originalValue);

      switch (displayType) {
        case 'array':
        case 'object':
          displayType = '';
          displayValue = this.generateDump(originalValue, "".concat(indent).concat(this.spaces));
          break;

        case 'boolean':
          displayType = 'boolean';
          displayValue = magenta("".concat(originalValue));
          break;

        case 'string':
          displayType = 'string';
          displayValue = "".concat(red("\"".concat(originalValue, "\"")), " (length=").concat(originalValue.length, ")");
          break;

        case 'null':
          displayType = '';
          displayValue = blue('null');
          break;

        case 'undefined':
          displayType = '';
          displayValue = blue('undefined');
          break;

        case 'number':
          displayType = Number.isInteger(originalValue) ? 'int' : 'float';
          displayValue = green(originalValue);
          break;

        case 'function':
        case 'generatorfunction':
          displayType = '';
          displayValue = this.formatFunction(originalValue);
          break;

        case 'regexp':
          displayType = '';
          displayValue = blue(originalValue);
          break;

        default:
          displayType = '';
          displayValue = originalValue;
          break;
      }

      var spacer = displayType.length ? ' ' : '';
      return "".concat(cyan(displayType)).concat(spacer).concat(displayValue);
    }
    /**
     * Format function to log it inside the console.
     *
     * @param {*} originalValue
     * @return {string}
     */

  }, {
    key: "formatFunction",
    value: function formatFunction(originalValue) {
      return originalValue.toString().slice(0, 50).replace(/\n/g, '').replace(/\s+/g, ' ');
    }
    /**
     * Make the arrow string.
     *
     * @param {string} paramType
     * @param {string} indent
     * @param {string|number} key
     * @param {*} valueDump
     * @return {string}
     */

  }, {
    key: "makeArrowString",
    value: function makeArrowString(paramType, indent, key, valueDump) {
      var startWith = "".concat(indent).concat(this.spaces);
      var valuePart = "".concat(valueDump, ",\n");
      var keyPart;

      if (Number.isInteger(parseInt(key)) || paramType === 'array' && typeof key !== 'string') {
        keyPart = "[".concat(key, "]");
      } else {
        keyPart = "'".concat(key, "'");
      }

      return "".concat(startWith + keyPart, " => ").concat(valuePart);
    }
  }]);

  return Dumper;
}();

module.exports = Dumper;